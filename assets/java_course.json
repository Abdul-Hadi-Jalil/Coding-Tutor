{
  "course_title": "Java Beginner Level",
  "days": [
    {
      "title": "Day 1 – Introduction to Java",
      "definition": "Java is a popular programming language used to create applications that run on computers, phones, and other devices.",
      "explanation": "Think of Java like a universal language that lets you write instructions once and run them anywhere. It's like having a recipe that works in any kitchen! Java is known for being reliable, secure, and able to run on different devices without needing changes. When you write Java code, it gets compiled into bytecode that runs on the Java Virtual Machine (JVM), making it platform-independent.",
      "code_example": "// Your first Java program\npublic class HelloWorld {\n    public static void main(String[] args) {\n        // This line prints text to the screen\n        System.out.println(\"Hello, World!\");\n    }\n}",
      "real_world_example": "Java is used everywhere! Major companies like Google, Amazon, and Netflix use Java for their backend systems. Android apps are primarily built using Java, and many banking applications rely on Java for secure transactions.",
      "interactive_tasks": [
        "Modify the HelloWorld program to print your name instead of 'Hello, World!'",
        "Add a second print statement that displays your favorite hobby",
        "Create a program that prints three different greetings on separate lines"
      ],
      "quiz": [
        {
          "question": "What is Java primarily known for?",
          "options": ["Platform independence", "Being the fastest language", "Only working on Windows", "Not needing compilation"],
          "answer": "Platform independence",
          "reasoning": "Java's 'write once, run anywhere' capability makes it platform independent."
        },
        {
          "question": "Which method is the entry point of a Java program?",
          "options": ["start()", "main()", "run()", "execute()"],
          "answer": "main()",
          "reasoning": "The main() method is where Java programs begin execution."
        },
        {
          "question": "What does System.out.println() do?",
          "options": ["Reads user input", "Creates a file", "Prints output to console", "Defines a variable"],
          "answer": "Prints output to console",
          "reasoning": "System.out.println() displays text on the console screen."
        },
        {
          "question": "Which company originally developed Java?",
          "options": ["Microsoft", "Google", "Sun Microsystems", "Apple"],
          "answer": "Sun Microsystems",
          "reasoning": "Java was originally developed by James Gosling at Sun Microsystems."
        },
        {
          "question": "What is the file extension for Java source files?",
          "options": [".java", ".class", ".exe", ".jar"],
          "answer": ".java",
          "reasoning": "Java source code files use the .java extension."
        },
        {
          "question": "Which keyword defines a class in Java?",
          "options": ["class", "define", "struct", "object"],
          "answer": "class",
          "reasoning": "The 'class' keyword is used to define a new class in Java."
        },
        {
          "question": "What is JVM?",
          "options": ["Java Virtual Machine", "Java Variable Manager", "Java Visual Module", "Java Version Manager"],
          "answer": "Java Virtual Machine",
          "reasoning": "JVM stands for Java Virtual Machine, which executes Java bytecode."
        }
      ]
    },
    {
      "title": "Day 2 – Setting up Java Environment",
      "definition": "Setting up Java environment involves installing JDK (Java Development Kit) and configuring your system to compile and run Java programs.",
      "explanation": "To start coding in Java, you need two main things: the JDK which includes the compiler and tools, and an IDE (Integrated Development Environment) where you'll write your code. It's like setting up a workshop - you need both the tools (JDK) and a workbench (IDE). Popular IDEs include IntelliJ IDEA, Eclipse, and VS Code. We'll also learn about environment variables that help your computer find Java commands.",
      "code_example": "// Simple program to verify Java installation\npublic class CheckJavaInstallation {\n    public static void main(String[] args) {\n        // Display Java version\n        System.out.println(\"Java Version: \" + System.getProperty(\"java.version\"));\n        \n        // Display Java installation directory\n        System.out.println(\"Java Home: \" + System.getProperty(\"java.home\"));\n    }\n}",
      "real_world_example": "Professional Java developers use proper environment setup to ensure their code compiles and runs consistently across different machines. Companies have standardized development environments to make sure all team members can work on the same projects without compatibility issues.",
      "interactive_tasks": [
        "Write a program that displays your Java version and vendor information",
        "Create a simple program that compiles and runs successfully",
        "Modify the check program to also display the operating system name"
      ],
      "quiz": [
        {
          "question": "What does JDK stand for?",
          "options": ["Java Development Kit", "Java Deployment Kit", "Java Design Kit", "Java Diagnostic Kit"],
          "answer": "Java Development Kit",
          "reasoning": "JDK stands for Java Development Kit, which contains tools for developing Java applications."
        },
        {
          "question": "Which command compiles a Java file?",
          "options": ["java", "javac", "compile", "jvm"],
          "answer": "javac",
          "reasoning": "The 'javac' command is used to compile Java source files."
        },
        {
          "question": "What is an IDE?",
          "options": ["Integrated Development Environment", "Internal Development Engine", "Interactive Design Element", "International Data Exchange"],
          "answer": "Integrated Development Environment",
          "reasoning": "IDE stands for Integrated Development Environment, a software for writing and testing code."
        },
        {
          "question": "Which environment variable points to Java installation?",
          "options": ["JAVA_HOME", "JDK_PATH", "JAVA_PATH", "JVM_HOME"],
          "answer": "JAVA_HOME",
          "reasoning": "JAVA_HOME environment variable specifies the Java installation directory."
        },
        {
          "question": "What command runs a compiled Java program?",
          "options": ["javac", "java", "run", "execute"],
          "answer": "java",
          "reasoning": "The 'java' command executes compiled Java bytecode."
        },
        {
          "question": "Which file contains compiled Java bytecode?",
          "options": [".java file", ".class file", ".exe file", ".jar file"],
          "answer": ".class file",
          "reasoning": "Compiled Java code is stored in .class files as bytecode."
        },
        {
          "question": "What does JRE stand for?",
          "options": ["Java Runtime Environment", "Java Resource Engine", "Java Runtime Engine", "Java Resource Environment"],
          "answer": "Java Runtime Environment",
          "reasoning": "JRE stands for Java Runtime Environment, needed to run Java applications."
        }
      ]
    },
    {
      "title": "Day 3 – Syntax and Structure",
      "definition": "Java syntax refers to the set of rules that define how Java programs are written and structured, similar to grammar in human languages.",
      "explanation": "Just like sentences follow grammar rules, Java code follows syntax rules. Every Java program must have a class definition, a main method, and uses semicolons to end statements. Think of classes as blueprints, methods as actions, and statements as individual instructions. We'll learn about case sensitivity, proper naming conventions, and the basic structure that every Java program follows.",
      "code_example": "// Demonstrating basic Java syntax\npublic class SyntaxDemo {\n    // Main method - program entry point\n    public static void main(String[] args) {\n        // Variable declaration and initialization\n        int number = 10;\n        String message = \"Hello Java!\";\n        \n        // Method call with semicolon\n        System.out.println(message);\n        System.out.println(\"Number is: \" + number);\n        \n        // Arithmetic operation\n        int result = number * 5;\n        System.out.println(\"Result: \" + result);\n    }\n}",
      "real_world_example": "Proper syntax is crucial in real-world applications because even small errors can cause programs to fail. Companies use coding standards and style guides to ensure all code follows consistent syntax, making it easier for teams to collaborate and maintain large codebases.",
      "interactive_tasks": [
        "Write a program that declares three different variables and prints them",
        "Fix the syntax errors in a provided buggy program",
        "Create a program that demonstrates multiple arithmetic operations"
      ],
      "quiz": [
        {
          "question": "What character ends every Java statement?",
          "options": [".", ",", ";", ":"],
          "answer": ";",
          "reasoning": "Semicolon (;) is used to terminate statements in Java."
        },
        {
          "question": "Is Java case-sensitive?",
          "options": ["Yes", "No", "Only for variables", "Only for class names"],
          "answer": "Yes",
          "reasoning": "Java is case-sensitive, meaning 'myVar' and 'myvar' are different."
        },
        {
          "question": "Which of these is a valid class name?",
          "options": ["MyClass", "my-class", "123Class", "class"],
            "answer": "MyClass",
            "reasoning": "Class names should start with a capital letter and use camel case."
            },
            {
              "question": "What is the correct way to declare the main method?",
              "options": ["public static void main(String[] args)", "public void main(String[] args)", "static void main(String[] args)", "public static main(String[] args)"],
              "answer": "public static void main(String[] args)",
              "reasoning": "The main method must be public, static, void, and take String[] args parameter."
            },
            {
              "question": "Which symbol is used for string concatenation?",
              "options": ["+", "&", "*", "|"],
              "answer": "+",
              "reasoning": "The plus (+) operator concatenates strings in Java."
            },
            {
              "question": "What does 'void' mean in a method declaration?",
              "options": ["Method returns no value", "Method takes no parameters", "Method is empty", "Method is virtual"],
              "answer": "Method returns no value",
              "reasoning": "Void indicates that a method doesn't return any value."
            },
            {
              "question": "Which of these is NOT a Java keyword?",
              "options": ["class", "main", "public", "static"],
              "answer": "main",
              "reasoning": "'main' is an identifier, not a reserved keyword in Java."
            }
          ]
        },
        {
          "title": "Day 4 – Variables and Data Types",
          "definition": "Variables are containers that store data in memory, and data types define what kind of data can be stored and how much space it needs.",
          "explanation": "Think of variables like labeled boxes where you can store different things. Each box has a specific type that determines what you can put in it. Java has two main categories of data types: primitive types (basic building blocks like numbers and characters) and reference types (more complex objects). We'll learn how to declare variables, assign values, and understand when to use each data type.",
          "code_example": "// Demonstrating variables and data types\npublic class VariablesDemo {\n    public static void main(String[] args) {\n        // Primitive data types\n        byte smallNumber = 100;          // 8-bit integer\n        short mediumNumber = 1000;       // 16-bit integer\n        int age = 25;                    // 32-bit integer (most common)\n        long bigNumber = 1000000000L;    // 64-bit integer\n        \n        float price = 19.99f;            // 32-bit floating point\n        double salary = 55000.75;        // 64-bit floating point (most common)\n        \n        char grade = 'A';                // Single character\n        boolean isJavaFun = true;        // true or false\n        \n        // Reference data type\n        String name = \"John Doe\";        // Sequence of characters\n        \n        // Displaying variables\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Age: \" + age);\n        System.out.println(\"Salary: $\" + salary);\n        System.out.println(\"Is Java fun? \" + isJavaFun);\n    }\n}",
          "real_world_example": "In real applications, variables store user information, application settings, calculation results, and more. For example, a banking app uses variables to store account balances, a game uses variables to track player scores, and an e-commerce site uses variables for product prices and quantities.",
          "interactive_tasks": [
            "Create a program that stores your personal information in variables and displays them",
            "Write a program that calculates the area of a rectangle using variables for length and width",
            "Declare variables of all primitive types and assign appropriate values"
          ],
          "quiz": [
            {
              "question": "Which data type would you use for true/false values?",
              "options": ["boolean", "int", "String", "char"],
              "answer": "boolean",
              "reasoning": "Boolean data type stores only true or false values."
            },
            {
              "question": "What is the default value of an int variable?",
              "options": ["0", "null", "1", "undefined"],
              "answer": "0",
              "reasoning": "Primitive int variables are initialized to 0 by default."
            },
            {
              "question": "Which data type can store decimal numbers?",
              "options": ["double", "int", "char", "boolean"],
              "answer": "double",
              "reasoning": "Double and float data types can store decimal numbers."
            },
            {
              "question": "What is the size of a char in Java?",
              "options": ["16-bit", "8-bit", "32-bit", "64-bit"],
              "answer": "16-bit",
              "reasoning": "Char data type uses 16 bits to store Unicode characters."
            },
            {
              "question": "Which symbol is used for String literals?",
              "options": ["Double quotes", "Single quotes", "Backticks", "Parentheses"],
              "answer": "Double quotes",
              "reasoning": "String literals are enclosed in double quotes, while char uses single quotes."
            },
            {
              "question": "What is the range of a byte data type?",
              "options": ["-128 to 127", "0 to 255", "-32768 to 32767", "0 to 65535"],
              "answer": "-128 to 127",
              "reasoning": "Byte is an 8-bit signed integer with range -128 to 127."
            },
            {
              "question": "Which of these is a reference data type?",
              "options": ["String", "int", "boolean", "char"],
              "answer": "String",
              "reasoning": "String is a reference type, while the others are primitive types."
            }
          ]
        },
        {
          "title": "Day 5 – Operators and Expressions",
          "definition": "Operators are special symbols that perform operations on variables and values, and expressions combine variables, values, and operators to produce results.",
          "explanation": "Think of operators as tools in your programming toolbox. Arithmetic operators (+, -, *, /) work with numbers, comparison operators (==, >, <) compare values, and logical operators (&&, ||, !) combine boolean conditions. We'll also learn about assignment operators (=, +=, -=) that store values in variables. Understanding operators helps you perform calculations and make decisions in your programs.",
          "code_example": "// Demonstrating operators and expressions\npublic class OperatorsDemo {\n    public static void main(String[] args) {\n        int a = 15;\n        int b = 4;\n        \n        // Arithmetic operators\n        System.out.println(\"a + b = \" + (a + b));  // Addition\n        System.out.println(\"a - b = \" + (a - b));  // Subtraction\n        System.out.println(\"a * b = \" + (a * b));  // Multiplication\n        System.out.println(\"a / b = \" + (a / b));  // Division\n        System.out.println(\"a % b = \" + (a % b));  // Modulus (remainder)\n        \n        // Comparison operators\n        System.out.println(\"a == b: \" + (a == b)); // Equal to\n        System.out.println(\"a != b: \" + (a != b)); // Not equal to\n        System.out.println(\"a > b: \" + (a > b));   // Greater than\n        System.out.println(\"a < b: \" + (a < b));   // Less than\n        \n        // Logical operators\n        boolean x = true;\n        boolean y = false;\n        System.out.println(\"x && y: \" + (x && y)); // AND\n        System.out.println(\"x || y: \" + (x || y)); // OR\n        System.out.println(\"!x: \" + (!x));         // NOT\n        \n        // Assignment operators\n        int c = 10;\n        c += 5;  // Same as c = c + 5\n        System.out.println(\"c after += 5: \" + c);\n    }\n}",
          "real_world_example": "Operators are used everywhere in real applications. Calculator apps use arithmetic operators, login systems use comparison operators to check credentials, and recommendation systems use logical operators to combine multiple conditions. E-commerce sites use operators to calculate discounts, taxes, and totals.",
          "interactive_tasks": [
            "Write a program that calculates the area and perimeter of a circle",
            "Create a program that compares two numbers and displays which is larger",
            "Write a program that uses compound assignment operators to modify a variable"
          ],
          "quiz": [
            {
              "question": "Which operator gives the remainder of division?",
              "options": ["%", "/", "*", "&"],
              "answer": "%",
              "reasoning": "The modulus operator (%) returns the remainder of division."
            },
            {
              "question": "What does the && operator do?",
              "options": ["Logical AND", "Logical OR", "Addition", "Assignment"],
              "answer": "Logical AND",
              "reasoning": "&& is the logical AND operator that returns true only if both operands are true."
            },
            {
              "question": "Which operator checks if two values are equal?",
              "options": ["==", "=", "!=", "==="],
              "answer": "==",
              "reasoning": "The == operator compares two values for equality."
            },
            {
              "question": "What is the result of 10 / 3 in Java?",
              "options": ["3", "3.333", "3.0", "4"],
              "answer": "3",
              "reasoning": "Integer division truncates the decimal part, giving 3."
            },
            {
              "question": "Which operator increases a variable by 1?",
              "options": ["++", "+=", "--", "=+"],
              "answer": "++",
              "reasoning": "The increment operator (++) increases a variable's value by 1."
            },
            {
              "question": "What does the != operator do?",
              "options": ["Not equal", "Equal", "Assignment", "Logical NOT"],
              "answer": "Not equal",
              "reasoning": "The != operator checks if two values are not equal."
            },
            {
              "question": "Which operator has the highest precedence?",
              "options": ["*", "+", "=", "=="],
              "answer": "*",
              "reasoning": "Multiplication (*) has higher precedence than addition and comparison operators."
            }
          ]
        },
        {
          "title": "Day 6 – Input and Output",
          "definition": "Input refers to getting data into your program (from users or files), and output refers to displaying data from your program (to screen or files).",
          "explanation": "Think of input as listening and output as speaking. Your program needs to communicate with the outside world! We use Scanner class to read input from the keyboard and System.out to display output. We'll learn how to import the Scanner class, create Scanner objects, and use different methods to read various types of input like integers, doubles, and strings.",
          "code_example": "// Demonstrating input and output with Scanner\nimport java.util.Scanner;  // Import Scanner class\n\npublic class InputOutputDemo {\n    public static void main(String[] args) {\n        // Create Scanner object to read input\n        Scanner scanner = new Scanner(System.in);\n        \n        // Reading different types of input\n        System.out.print(\"Enter your name: \");\n        String name = scanner.nextLine();  // Read a line of text\n        \n        System.out.print(\"Enter your age: \");\n        int age = scanner.nextInt();       // Read an integer\n        \n        System.out.print(\"Enter your height in meters: \");\n        double height = scanner.nextDouble();  // Read a double\n        \n        // Clear the buffer\n        scanner.nextLine();\n        \n        System.out.print(\"Are you a student? (true/false): \");\n        boolean isStudent = scanner.nextBoolean();  // Read a boolean\n        \n        // Display the collected information\n        System.out.println(\"\\n=== User Information ===\");\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Age: \" + age);\n        System.out.println(\"Height: \" + height + \" meters\");\n        System.out.println(\"Student: \" + isStudent);\n        \n        // Close the scanner\n        scanner.close();\n    }\n}",
          "real_world_example": "Input/output is fundamental in all applications. Login forms read username/password input, ATMs read card inputs and display account information, games read controller inputs and display game states, and mobile apps use touch inputs and display responses. Even web applications handle input from forms and output HTML pages.",
          "interactive_tasks": [
            "Create a program that asks for user's name and age, then displays a greeting",
            "Write a simple calculator that takes two numbers and an operator as input",
            "Create a program that collects student information and displays a report card"
          ],
          "quiz": [
            {
              "question": "Which class is used to read user input in Java?",
              "options": ["Scanner", "Reader", "Input", "System.in"],
              "answer": "Scanner",
              "reasoning": "The Scanner class is commonly used to read input from various sources."
            },
            {
              "question": "What is the correct way to import Scanner?",
              "options": ["import java.util.Scanner;", "import Scanner;", "include java.util.Scanner;", "using java.util.Scanner;"],
              "answer": "import java.util.Scanner;",
              "reasoning": "Scanner is in java.util package, so we import it with import java.util.Scanner;"
            },
            {
              "question": "Which method reads a whole line of text?",
              "options": ["nextLine()", "next()", "readLine()", "getLine()"],
              "answer": "nextLine()",
              "reasoning": "nextLine() method reads an entire line of text including spaces."
            },
            {
              "question": "What does System.out.println() do?",
              "options": ["Prints output and moves to next line", "Reads input", "Prints output on same line", "Creates a new line"],
              "answer": "Prints output and moves to next line",
              "reasoning": "println() prints output and adds a newline character at the end."
            },
            {
              "question": "Which method reads an integer from input?",
              "options": ["nextInt()", "readInt()", "getInt()", "scanInt()"],
              "answer": "nextInt()",
              "reasoning": "nextInt() method reads the next integer from the input."
            },
            {
              "question": "Why should you close the Scanner?",
              "options": ["To free resources", "To stop the program", "To clear memory", "To save data"],
              "answer": "To free resources",
              "reasoning": "Closing Scanner releases system resources associated with it."
            },
            {
              "question": "What is the difference between print() and println()?",
              "options": ["println() adds newline, print() doesn't", "print() is faster", "println() reads input", "print() only works with strings"],
              "answer": "println() adds newline, print() doesn't",
              "reasoning": "println() adds a newline after printing, while print() does not."
            }
          ]
        },
        {
          "title": "Day 7 – Comments and Best Practices",
          "definition": "Comments are non-executable notes in your code that explain what the code does, and best practices are guidelines for writing clean, maintainable code.",
          "explanation": "Think of comments as sticky notes for your future self and other developers. They explain why you wrote certain code, making it easier to understand later. We have single-line comments (//) for short notes and multi-line comments (/* */) for longer explanations. Best practices include using meaningful variable names, proper indentation, and following coding conventions that make your code readable and professional.",
          "code_example": "// This is a single-line comment\n\n/*\n * This is a multi-line comment\n * It can span multiple lines\n * Useful for detailed explanations\n */\n\n/**\n * This is a JavaDoc comment\n * Used for documentation\n * @author John Doe\n * @version 1.0\n */\npublic class CommentsBestPractices {\n    \n    /**\n     * Calculates the area of a rectangle\n     * @param length the length of the rectangle\n     * @param width the width of the rectangle\n     * @return the area of the rectangle\n     */\n    public static double calculateArea(double length, double width) {\n        // Input validation\n        if (length <= 0 || width <= 0) {\n            System.out.println(\"Error: Length and width must be positive\");\n            return -1;  // Return -1 to indicate error\n        }\n        \n        // Calculate area using formula: area = length * width\n        double area = length * width;\n        \n        return area;  // Return the calculated area\n    }\n    \n    public static void main(String[] args) {\n        // Good variable names make code self-documenting\n        double rectangleLength = 5.5;\n        double rectangleWidth = 3.2;\n        \n        // Call the method and store result\n        double area = calculateArea(rectangleLength, rectangleWidth);\n        \n        // Display the result with proper formatting\n        System.out.println(\"Rectangle Area: \" + area);\n        \n        // Example of consistent indentation and spacing\n        for (int i = 1; i <= 3; i++) {\n            System.out.println(\"Iteration: \" + i);\n        }\n    }\n}",
          "real_world_example": "In professional development, comments and best practices are crucial for team collaboration. Companies have coding standards that all developers must follow. Good comments explain complex algorithms, business rules, or why certain approaches were chosen. Clean code with proper naming and structure reduces bugs and makes maintenance easier, saving companies time and money.",
          "interactive_tasks": [
            "Add appropriate comments to an uncommented program explaining each section",
            "Rewrite a poorly formatted program with proper indentation and variable names",
            "Create a well-documented method that calculates compound interest"
          ],
          "quiz": [
            {
              "question": "Which symbol starts a single-line comment?",
              "options": ["//", "/*", "#", "--"],
              "answer": "//",
              "reasoning": "Double slash (//) is used for single-line comments in Java."
            },
            {
              "question": "What is the purpose of JavaDoc comments?",
              "options": ["Generate documentation", "Debug code", "Improve performance", "Handle errors"],
              "answer": "Generate documentation",
              "reasoning": "JavaDoc comments are used to generate API documentation automatically."
            },
            {
              "question": "Which variable naming is considered best practice?",
              "options": ["calculateArea", "calcArea", "ca", "CALCULATEAREA"],
              "answer": "calculateArea",
              "reasoning": "Descriptive camelCase names like 'calculateArea' are best practice."
            },
            {
              "question": "What should comments primarily explain?",
              "options": ["Why code exists", "What code does", "How to compile", "Variable types"],
              "answer": "Why code exists",
              "reasoning": "Good comments explain the reasoning behind code, not just what it does."
            },
            {
              "question": "Which is NOT a best practice?",
              "options": ["Using magic numbers", "Proper indentation", "Meaningful names", "Consistent style"],
              "answer": "Using magic numbers",
              "reasoning": "Magic numbers (unnamed numerical constants) should be avoided."
            },
            {
              "question": "What does JavaDoc start with?",
              "options": ["/**", "/*", "//", "#*"],
              "answer": "/**",
              "reasoning": "JavaDoc comments start with /** and end with */."
            },
            {
              "question": "Why is consistent indentation important?",
              "options": ["Improves readability", "Makes code faster", "Prevents errors", "Reduces file size"],
              "answer": "Improves readability",
              "reasoning": "Consistent indentation makes code structure clear and easy to read."
            }
          ]
        },
        {
          "title": "Day 8 – Conditional Statements (if, else, else if)",
          "definition": "Conditional statements allow your program to make decisions and execute different code blocks based on whether conditions are true or false.",
          "explanation": "Think of conditional statements like crossroads where your program chooses which path to take. The 'if' statement checks a condition - if it's true, the code block runs. 'else' provides an alternative when the condition is false. 'else if' lets you check multiple conditions in sequence. It's like having multiple choices and picking the first one that matches your criteria.",
          "code_example": "// Demonstrating conditional statements\npublic class ConditionalDemo {\n    public static void main(String[] args) {\n        int score = 85;\n        char grade;\n        \n        // Simple if statement\n        if (score >= 50) {\n            System.out.println(\"You passed the exam!\");\n        }\n        \n        // if-else statement\n        if (score >= 90) {\n            grade = 'A';\n        } else {\n            grade = 'B';\n        }\n        \n        // if-else if-else chain\n        if (score >= 90) {\n            grade = 'A';\n            System.out.println(\"Excellent!\");\n        } else if (score >= 80) {\n            grade = 'B';\n            System.out.println(\"Good job!\");\n        } else if (score >= 70) {\n            grade = 'C';\n            System.out.println(\"Fair\");\n        } else if (score >= 60) {\n            grade = 'D';\n            System.out.println(\"Needs improvement\");\n        } else {\n            grade = 'F';\n            System.out.println(\"Failed\");\n        }\n        \n        System.out.println(\"Your grade is: \" + grade);\n        \n        // Nested if statements\n        int age = 25;\n        boolean hasLicense = true;\n        \n        if (age >= 18) {\n            if (hasLicense) {\n                System.out.println(\"You can drive a car!\");\n            } else {\n                System.out.println(\"You need a license to drive.\");\n            }\n        } else {\n            System.out.println(\"You're too young to drive.\");\n        }\n    }\n}",
          "real_world_example": "Conditional statements are used everywhere in real applications. Login systems check if credentials are correct, e-commerce sites apply discounts based on purchase amounts, games change behavior based on player actions, and banking apps verify if users have sufficient funds before transactions. Weather apps use conditions to display different icons based on temperature and conditions.",
          "interactive_tasks": [
            "Write a program that checks if a number is positive, negative, or zero",
            "Create a program that determines if a year is a leap year",
            "Write a program that categorizes a person's age group (child, teen, adult, senior)"
          ],
          "quiz": [
            {
              "question": "Which keyword is used for the default case in if statements?",
              "options": ["else", "default", "otherwise", "elif"],
              "answer": "else",
              "reasoning": "The 'else' clause executes when all previous conditions are false."
            },
            {
              "question": "What is the result of (10 > 5) in an if condition?",
              "options": ["true", "false", "10", "5"],
              "answer": "true",
              "reasoning": "10 > 5 is a true comparison, so the condition evaluates to true."
            },
            {
              "question": "How many else if blocks can you have?",
              "options": ["As many as needed", "Only one", "Maximum three", "Maximum ten"],
              "answer": "As many as needed",
              "reasoning": "You can have multiple else if blocks to check various conditions."
            },
            {
              "question": "What happens if multiple conditions are true in if-else if chain?",
              "options": ["Only first true block executes", "All true blocks execute", "Compiler error", "Random block executes"],
              "answer": "Only first true block executes",
              "reasoning": "In if-else if chain, only the first true condition's block executes."
            },
            {
              "question": "Which operator has higher precedence in conditions?",
              "options": ["Comparison > Logical", "Logical > Comparison", "Same precedence", "Depends on context"],
              "answer": "Comparison > Logical",
              "reasoning": "Comparison operators have higher precedence than logical operators."
            },
            {
              "question": "What is nested if statement?",
              "options": ["if inside another if", "Multiple if statements", "if with else", "if with else if"],
              "answer": "if inside another if",
              "reasoning": "Nested if means an if statement inside another if statement."
            },
            {
              "question": "Which condition checks if x is between 5 and 10?",
              "options": ["x >= 5 && x <= 10", "5 <= x <= 10", "x > 5 && x < 10", "x == 5 || x == 10"],
              "answer": "x >= 5 && x <= 10",
              "reasoning": "This checks if x is greater than or equal to 5 AND less than or equal to 10."
            }
          ]
        },
        {
          "title": "Day 9 – Switch Statement",
          "definition": "The switch statement is a multi-way branch statement that allows a variable to be tested for equality against a list of values, providing an alternative to long if-else if chains.",
          "explanation": "Think of the switch statement like a menu at a restaurant - you choose one option from several available choices. It's particularly useful when you have one variable that can have multiple specific values, and you want to execute different code for each value. The switch statement is often cleaner and more readable than long chains of if-else statements when dealing with multiple discrete values.",
          "code_example": "// Demonstrating switch statement\npublic class SwitchDemo {\n    public static void main(String[] args) {\n        int dayOfWeek = 3;\n        String dayName;\n        \n        // Basic switch statement\n        switch (dayOfWeek) {\n            case 1:\n                dayName = \"Monday\";\n                break;\n            case 2:\n                dayName = \"Tuesday\";\n                break;\n            case 3:\n                dayName = \"Wednesday\";\n                break;\n            case 4:\n                dayName = \"Thursday\";\n                break;\n            case 5:\n                dayName = \"Friday\";\n                break;\n            case 6:\n                dayName = \"Saturday\";\n                break;\n            case 7:\n                dayName = \"Sunday\";\n                break;\n            default:\n                dayName = \"Invalid day\";\n                break;\n        }\n        \n        System.out.println(\"Day \" + dayOfWeek + \" is: \" + dayName);\n        \n        // Switch with multiple cases sharing same code\n        char grade = 'B';\n        \n        switch (grade) {\n            case 'A':\n            case 'B':\n            case 'C':\n                System.out.println(\"You passed!\");\n                break;\n            case 'D':\n            case 'F':\n                System.out.println(\"You failed!\");\n                break;\n            default:\n                System.out.println(\"Invalid grade\");\n        }\n        \n        // Enhanced switch (Java 14+)\n        String season = \"Summer\";\n        \n        String message = switch (season) {\n            case \"Spring\" -> \"Flowers are blooming!\";\n            case \"Summer\" -> \"It's hot outside!\";\n            case \"Fall\" -> \"Leaves are falling!\";\n            case \"Winter\" -> \"It's cold and snowy!\";\n            default -> \"Unknown season\";\n        };\n        \n        System.out.println(message);\n    }\n}",
          "real_world_example": "Switch statements are commonly used in menu-driven applications, command processors, state machines, and anywhere you need to handle multiple specific cases. For example, ATM machines use switch-like logic for different transaction types, vending machines use it for product selection, and game controllers use it to handle different button presses. Restaurant ordering systems also use switch logic for menu items.",
          "interactive_tasks": [
            "Write a program that uses switch to display the month name for a given number (1-12)",
            "Create a simple calculator using switch for different operations (+, -, *, /)",
            "Write a program that categorizes a vehicle type based on its number of wheels using switch"
          ],
          "quiz": [
            {
              "question": "What happens if you forget break in a switch case?",
              "options": ["Fall-through to next case", "Compiler error", "Runtime error", "Default case executes"],
              "answer": "Fall-through to next case",
              "reasoning": "Without break, execution continues to the next case (fall-through)."
            },
            {
              "question": "Which data type can NOT be used in switch?",
              "options": ["double", "int", "char", "String"],
              "answer": "double",
              "reasoning": "Switch doesn't support double/float due to precision issues."
            },
            {
              "question": "What is the purpose of default case?",
              "options": ["Handles unmatched cases", "Required in every switch", "First case to execute", "Terminates switch"],
              "answer": "Handles unmatched cases",
              "reasoning": "Default case executes when no other cases match."
            },
            {
              "question": "When is switch preferred over if-else?",
              "options": ["Multiple discrete values", "Range comparisons", "Complex conditions", "Single condition"],
              "answer": "Multiple discrete values",
              "reasoning": "Switch is cleaner when testing one variable against multiple specific values."
            },
            {
              "question": "What does enhanced switch (->) do?",
              "options": ["Returns value directly", "Requires break", "Is slower", "Only for integers"],
              "answer": "Returns value directly",
              "reasoning": "Enhanced switch with -> can return values without break statements."
            },
            {
              "question": "Can switch work with Strings?",
              "options": ["Yes, in Java 7+", "No, never", "Only in latest Java", "Only with single chars"],
              "answer": "Yes, in Java 7+",
              "reasoning": "Switch supports Strings starting from Java 7."
            },
            {
              "question": "What is case fall-through?",
              "options": ["Execution continues to next case", "Case values overlap", "Default case executes", "Switch fails"],
              "answer": "Execution continues to next case",
              "reasoning": "Fall-through means execution continues to subsequent cases without break."
            }
          ]
        },
        {
          "title": "Day 10 – Loops (for, while, do-while)",
          "definition": "Loops are control structures that repeat a block of code multiple times until a specified condition is met, allowing you to automate repetitive tasks.",
          "explanation": "Think of loops like a factory assembly line that repeats the same process over and over. Java has three main types of loops: 'for' loops are great when you know exactly how many times you want to repeat, 'while' loops keep going as long as a condition remains true, and 'do-while' loops always execute at least once before checking the condition. Each has its own use cases and understanding when to use which makes your code more efficient.",
          "code_example": "// Demonstrating different types of loops\npublic class LoopsDemo {\n    public static void main(String[] args) {\n        // For loop - when you know how many iterations\n        System.out.println(\"For loop counting 1 to 5:\");\n        for (int i = 1; i <= 5; i++) {\n            System.out.println(\"Count: \" + i);\n        }\n        \n        // While loop - when you don't know exact iterations\n        System.out.println(\"\\nWhile loop counting down from 5:\");\n        int count = 5;\n        while (count > 0) {\n            System.out.println(\"Countdown: \" + count);\n            count--;  // Decrement count\n        }\n        \n        // Do-while loop - executes at least once\n        System.out.println(\"\\nDo-while loop (runs at least once):\");\n        int number = 10;\n        do {\n            System.out.println(\"Number is: \" + number);\n            number++;\n        } while (number < 5);  // Condition is false, but loop ran once\n        \n        // Practical example: Sum of numbers\n        System.out.println(\"\\nCalculating sum of first 10 numbers:\");\n        int sum = 0;\n        for (int i = 1; i <= 10; i++) {\n            sum += i;\n            System.out.println(\"Added \" + i + \", total: \" + sum);\n        }\n        System.out.println(\"Final sum: \" + sum);\n        \n        // Loop with user input simulation\n        System.out.println(\"\\nSimulating user input validation:\");\n        int userInput = 0;\n        // This would normally use Scanner, simulating here\n        while (userInput < 1 || userInput > 100) {\n            System.out.println(\"Please enter a number between 1-100 (simulating 50):\");\n            userInput = 50;  // Simulating valid input\n        }\n        System.out.println(\"Valid input received: \" + userInput);\n    }\n}",
          "real_world_example": "Loops are fundamental in real-world programming. Social media apps use loops to display feeds of posts, games use loops for animation frames, banking apps use loops to process transactions, and e-commerce sites use loops to display product catalogs. Data processing applications heavily rely on loops to analyze large datasets, and web servers use loops to handle multiple client requests.",
          "interactive_tasks": [
            "Write a program that prints multiplication tables using nested for loops",
            "Create a program that calculates factorial of a number using a while loop",
            "Write a number guessing game that continues until the user guesses correctly"
          ],
          "quiz": [
            {
              "question": "Which loop always executes at least once?",
              "options": ["do-while", "for", "while", "for-each"],
              "answer": "do-while",
              "reasoning": "Do-while checks condition after execution, so it always runs at least once."
            },
            {
              "question": "What are the three parts of a for loop?",
              "options": ["Initialization, condition, increment", "Start, check, end", "Begin, test, update", "First, second, third"],
              "answer": "Initialization, condition, increment",
              "reasoning": "For loops have: initialization, condition check, and increment/decrement."
            },
            {
              "question": "When should you use a while loop?",
              "options": ["When iterations are unknown", "When you know exact count", "For arrays only", "For single execution"],
              "answer": "When iterations are unknown",
              "reasoning": "While loops are ideal when you don't know how many iterations are needed."
            },
            {
              "question": "What is an infinite loop?",
              "options": ["Loop that never ends", "Very long loop", "Loop with many iterations", "Broken loop"],
              "answer": "Loop that never ends",
              "reasoning": "Infinite loop occurs when the termination condition is never met."
            },
            {
              "question": "Which loop is best for iterating arrays?",
              "options": ["for", "while", "do-while", "All are equal"],
              "answer": "for",
              "reasoning": "For loops are commonly used with arrays when index is needed."
            },
            {
              "question": "What does i++ mean in a loop?",
              "options": ["Increment i by 1", "Decrement i by 1", "Add i to itself", "Check if i is positive"],
              "answer": "Increment i by 1",
              "reasoning": "i++ is the increment operator that increases i by 1."
            },
            {
              "question": "How do you prevent infinite loops?",
              "options": ["Ensure condition becomes false", "Use break statements", "Limit iterations", "All of the above"],
              "answer": "All of the above",
              "reasoning": "Multiple strategies can prevent infinite loops in different scenarios."
            }
          ]
        },
        {
          "title": "Day 11 – Nested Loops",
          "definition": "Nested loops are loops within loops, where one loop runs completely for each iteration of the outer loop, useful for working with multi-dimensional data.",
          "explanation": "Think of nested loops like a clock - the minute hand (inner loop) makes a full circle for each position of the hour hand (outer loop). This pattern is extremely useful for working with grids, tables, matrices, or any situation where you need to process data in multiple dimensions. The inner loop completes all its iterations for each single iteration of the outer loop, creating a multiplicative effect.",
          "code_example": "// Demonstrating nested loops\npublic class NestedLoopsDemo {\n    public static void main(String[] args) {\n        // Basic nested loops - pattern printing\n        System.out.println(\"Rectangle pattern:\");\n        for (int row = 1; row <= 4; row++) {      // Outer loop for rows\n            for (int col = 1; col <= 6; col++) {   // Inner loop for columns\n                System.out.print(\"* \");\n            }\n            System.out.println();  // New line after each row\n        }\n        \n        // Right triangle pattern\n        System.out.println(\"\\nRight triangle pattern:\");\n        for (int i = 1; i <= 5; i++) {\n            for (int j = 1; j <= i; j++) {\n                System.out.print(\"* \");\n            }\n            System.out.println();\n        }\n        \n        // Multiplication table\n        System.out.println(\"\\nMultiplication table (1-5):\");\n        for (int i = 1; i <= 5; i++) {           // Outer loop for rows\n            for (int j = 1; j <= 5; j++) {       // Inner loop for columns\n                System.out.print(i * j + \"\\t\");   // Tab separated\n            }\n            System.out.println();\n        }\n        \n        // 2D array processing\n        System.out.println(\"\\n2D Array processing:\");\n        int[][] matrix = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        \n        for (int i = 0; i < matrix.length; i++) {         // Rows\n            for (int j = 0; j < matrix[i].length; j++) {  // Columns\n                System.out.print(matrix[i][j] + \" \");\n            }\n            System.out.println();\n        }\n        \n        // Sum of all elements in 2D array\n        int total = 0;\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[i].length; j++) {\n                total += matrix[i][j];\n            }\n        }\n        System.out.println(\"Sum of all elements: \" + total);\n    }\n}",
          "real_world_example": "Nested loops are essential in real-world applications. Image processing uses nested loops to manipulate pixels in 2D arrays, spreadsheet applications use them to process cells in rows and columns, game development uses them for grid-based games like chess or tic-tac-toe, and data analysis uses them to process tables of information. Computer graphics heavily rely on nested loops for rendering scenes.",
          "interactive_tasks": [
            "Write a program that prints a pyramid pattern using nested loops",
            "Create a program that finds the largest number in a 2D array",
            "Write a program that simulates a simple seating chart with rows and columns"
          ],
          "quiz": [
            {
              "question": "How many times does inner loop run if outer runs 5 times and inner 3 times?",
              "options": ["15", "5", "3", "8"],
              "answer": "15",
              "reasoning": "Inner loop runs completely for each outer iteration: 5 × 3 = 15 times."
            },
            {
              "question": "What is the time complexity of nested loops?",
              "options": ["O(n²)", "O(n)", "O(log n)", "O(1)"],
              "answer": "O(n²)",
              "reasoning": "Nested loops typically have quadratic time complexity O(n²)."
            },
            {
              "question": "Which loop controls rows in a grid?",
              "options": ["Outer loop", "Inner loop", "Middle loop", "Row loop"],
              "answer": "Outer loop",
              "reasoning": "Typically, outer loop controls rows and inner loop controls columns."
            },
            {
              "question": "What happens if you use same variable in nested loops?",
              "options": ["Compilation error", "Runtime error", "Infinite loop", "Works fine"],
              "answer": "Compilation error",
              "reasoning": "Java doesn't allow redeclaring the same variable in nested scopes."
            },
            {
              "question": "When should you avoid nested loops?",
              "options": ["With large datasets", "For simple tasks", "With arrays", "For patterns"],
              "answer": "With large datasets",
              "reasoning": "Nested loops can be inefficient with large data due to O(n²) complexity."
            },
            {
              "question": "How to break out of nested loops?",
              "options": ["Use labeled break", "Use multiple breaks", "Return from method", "All of the above"],
              "answer": "All of the above",
              "reasoning": "Multiple strategies exist for breaking out of nested loops."
            },
            {
              "question": "What prints for 2x2 nested loops both counting 1-2?",
              "options": ["4 iterations", "2 iterations", "1 iteration", "8 iterations"],
              "answer": "4 iterations",
              "reasoning": "2 outer × 2 inner = 4 total iterations."
            }
          ]
        },
        {
          "title": "Day 12 – Break and Continue",
          "definition": "Break and continue are jump statements that alter the normal flow of loops - break exits the loop entirely, while continue skips the current iteration and moves to the next one.",
          "explanation": "Think of break like an emergency exit - it immediately gets you out of the loop. Continue is like saying 'skip this one and move to the next'. Break is useful when you find what you're looking for and don't need to continue searching. Continue is handy when you want to skip certain iterations based on conditions but keep the loop running for other cases.",
          "code_example": "// Demonstrating break and continue statements\npublic class BreakContinueDemo {\n    public static void main(String[] args) {\n        // Break example - exit loop when condition met\n        System.out.println(\"Break example - stop at first negative number:\");\n        int[] numbers = {5, 12, 8, -3, 15, 7};\n        \n        for (int i = 0; i < numbers.length; i++) {\n            if (numbers[i] < 0) {\n                System.out.println(\"Found negative number: \" + numbers[i]);\n                break;  // Exit loop immediately\n            }\n            System.out.println(\"Processing: \" + numbers[i]);\n        }\n        \n        // Continue example - skip even numbers\n        System.out.println(\"\\nContinue example - print only odd numbers:\");\n        for (int i = 1; i <= 10; i++) {\n            if (i % 2 == 0) {\n                continue;  // Skip even numbers\n            }\n            System.out.println(\"Odd number: \" + i);\n        }\n        \n        // Break in while loop\n        System.out.println(\"\\nBreak in while loop - count until 7:\");\n        int count = 1;\n        while (true) {  // Infinite loop\n            System.out.println(\"Count: \" + count);\n            if (count == 7) {\n                System.out.println(\"Reached 7, breaking loop\");\n                break;  // Exit infinite loop\n            }\n            count++;\n        }\n        \n        // Continue with nested loops\n        System.out.println(\"\\nContinue in nested loops - skip specific combinations:\");\n        for (int i = 1; i <= 3; i++) {\n            for (int j = 1; j <= 3; j++) {\n                if (i == 2 && j == 2) {\n                    System.out.println(\"Skipping (2,2)\");\n                    continue;  // Skip only this iteration\n                }\n                System.out.println(\"(\" + i + \",\" + j + \")\");\n            }\n        }\n        \n        // Labeled break - break out of specific loop\n        System.out.println(\"\\nLabeled break - exit outer loop:\");\n        outerLoop:  // Label for outer loop\n        for (int i = 1; i <= 3; i++) {\n            for (int j = 1; j <= 3; j++) {\n                if (i == 2 && j == 2) {\n                    System.out.println(\"Breaking outer loop at (2,2)\");\n                    break outerLoop;  // Break out of labeled loop\n                }\n                System.out.println(\"(\" + i + \",\" + j + \")\");\n            }\n        }\n        \n        // Practical example: Search in array\n        System.out.println(\"\\nSearch example - find first multiple of 7:\");\n        int[] data = {12, 45, 23, 14, 67, 28, 91, 34};\n        boolean found = false;\n        \n        for (int num : data) {\n            if (num % 7 == 0) {\n                System.out.println(\"Found first multiple of 7: \" + num);\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found) {\n            System.out.println(\"No multiples of 7 found\");\n        }\n    }\n}",
          "real_world_example": "Break and continue are widely used in real applications. Search functions use break when the target is found to improve performance. Data validation uses continue to skip invalid records while processing the rest. Game loops use break to exit when the game ends. File processing uses continue to skip corrupted files. Menu systems use break to exit when users choose to quit.",
          "interactive_tasks": [
            "Write a program that finds the first prime number in an array using break",
            "Create a program that processes numbers but skips negative values using continue",
            "Write a number guessing game that breaks when the correct number is guessed"
          ],
          "quiz": [
            {
              "question": "What does break statement do?",
              "options": ["Exits the loop", "Skips current iteration", "Restarts loop", "Pauses loop"],
              "answer": "Exits the loop",
              "reasoning": "Break immediately terminates the loop and continues with code after the loop."
            },
            {
              "question": "When is continue useful?",
              "options": ["Skip specific iterations", "Exit loop early", "Start new loop", "Fix errors"],
              "answer": "Skip specific iterations",
              "reasoning": "Continue skips the current iteration and moves to the next one."
            },
            {
              "question": "Can break be used outside loops?",
              "options": ["Yes, in switch", "No, never", "Only in for loops", "Only in while loops"],
              "answer": "Yes, in switch",
              "reasoning": "Break is also used in switch statements to prevent fall-through."
            },
            {
              "question": "What is labeled break?",
              "options": ["Break specific outer loop", "Break with message", "Break all loops", "Break with condition"],
              "answer": "Break specific outer loop",
              "reasoning": "Labeled break exits a specific outer loop in nested loops."
            },
            {
              "question": "Does continue work in switch statements?",
              "options": ["No", "Yes", "Only in enhanced switch", "Only with labels"],
              "answer": "No",
              "reasoning": "Continue only works within loops, not in switch statements."
            },
            {
              "question": "What happens after continue executes?",
              "options": ["Next iteration starts", "Loop ends", "Program ends", "Previous iteration repeats"],
              "answer": "Next iteration starts",
              "reasoning": "Continue jumps to the next iteration of the loop."
            },
            {
              "question": "When should you use break in a loop?",
              "options": ["When target is found", "To skip one item", "To make loop faster", "To avoid conditions"],
              "answer": "When target is found",
              "reasoning": "Break is ideal for search scenarios when the target is located."
            }
          ]
        },
        {
          "title": "Day 13 – Mini Challenge Project",
          "definition": "A mini project that combines all control flow concepts learned so far to create a practical application, reinforcing your understanding through hands-on coding.",
          "explanation": "Today we'll build a complete Number Guessing Game that uses everything we've learned: variables, input/output, conditionals, loops, and control statements. This is your chance to see how all the pieces fit together in a real program. We'll create a game where the computer picks a random number and the player has to guess it, with hints and limited attempts.",
          "code_example": "// Number Guessing Game - Mini Project\nimport java.util.Scanner;\nimport java.util.Random;\n\npublic class NumberGuessingGame {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Random random = new Random();\n        \n        // Game configuration\n        final int MAX_ATTEMPTS = 7;\n        final int MIN_NUMBER = 1;\n        final int MAX_NUMBER = 100;\n        \n        boolean playAgain = true;\n        int totalGames = 0;\n        int totalWins = 0;\n        \n        System.out.println(\"🎯 Welcome to the Number Guessing Game!\");\n        System.out.println(\"========================================\");\n        \n        // Main game loop\n        while (playAgain) {\n            totalGames++;\n            int secretNumber = random.nextInt(MAX_NUMBER - MIN_NUMBER + 1) + MIN_NUMBER;\n            int attempts = 0;\n            boolean hasWon = false;\n            \n            System.out.println(\"\\n🎮 Game \" + totalGames + \" - I'm thinking of a number between \" + MIN_NUMBER + \" and \" + MAX_NUMBER);\n            System.out.println(\"You have \" + MAX_ATTEMPTS + \" attempts to guess it!\");\n            \n            // Guessing loop\n            while (attempts < MAX_ATTEMPTS && !hasWon) {\n                attempts++;\n                int remainingAttempts = MAX_ATTEMPTS - attempts;\n                \n                System.out.print(\"\\nAttempt \" + attempts + \"/\" + MAX_ATTEMPTS + \". Enter your guess: \");\n                \n                // Input validation\n                if (!scanner.hasNextInt()) {\n                    System.out.println(\"❌ Please enter a valid number!\");\n                    scanner.next(); // Clear invalid input\n                    attempts--; // Don't count invalid attempts\n                    continue;\n                }\n                \n                int guess = scanner.nextInt();\n                \n                // Check guess\n                if (guess < MIN_NUMBER || guess > MAX_NUMBER) {\n                    System.out.println(\"❌ Please enter a number between \" + MIN_NUMBER + \" and \" + MAX_NUMBER + \"!\");\n                    attempts--; // Don't count invalid guesses\n                } else if (guess == secretNumber) {\n                    System.out.println(\"🎉 CONGRATULATIONS! You guessed the number \" + secretNumber + \" correctly!\");\n                    System.out.println(\"⭐ It took you \" + attempts + \" attempt(s).\");\n                    hasWon = true;\n                    totalWins++;\n                } else if (guess < secretNumber) {\n                    System.out.println(\"📈 Too low! Try a higher number.\");\n                    if (remainingAttempts > 0) {\n                        System.out.println(\"💡 Hint: The number is between \" + (guess + 1) + \" and \" + MAX_NUMBER);\n                    }\n                } else {\n                    System.out.println(\"📉 Too high! Try a lower number.\");\n                    if (remainingAttempts > 0) {\n                        System.out.println(\"💡 Hint: The number is between \" + MIN_NUMBER + \" and \" + (guess - 1));\n                    }\n                }\n                \n                // Show remaining attempts\n                if (!hasWon && remainingAttempts > 0) {\n                    System.out.println(\"🔄 \" + remainingAttempts + \" attempt(s) remaining.\");\n                }\n            }\n            \n            // Game over message\n            if (!hasWon) {\n                System.out.println(\"\\n💔 GAME OVER! The secret number was: \" + secretNumber);\n                System.out.println(\"Better luck next time!\");\n            }\n            \n            // Play again option\n            System.out.print(\"\\n🔄 Would you like to play again? (yes/no): \");\n            scanner.nextLine(); // Clear buffer\n            String response = scanner.nextLine().toLowerCase();\n            \n            if (!response.equals(\"yes\") && !response.equals(\"y\")) {\n                playAgain = false;\n                System.out.println(\"\\n📊 Game Statistics:\");\n                System.out.println(\"Total games played: \" + totalGames);\n                System.out.println(\"Games won: \" + totalWins);\n                System.out.println(\"Win rate: \" + (totalWins * 100 / totalGames) + \"%\");\n                System.out.println(\"\\nThanks for playing! 👋\");\n            }\n        }\n        \n        scanner.close();\n    }\n}",
          "real_world_example": "This mini project demonstrates fundamental programming concepts used in real games and applications. The pattern of main game loops, input validation, state tracking, and user interaction is used in everything from simple mobile games to complex business applications. The skills you practice here are directly applicable to building login systems, form validators, and interactive applications.",
          "interactive_tasks": [
            "Add a difficulty system with different number ranges and attempt limits",
            "Implement a scoring system that gives more points for fewer attempts",
            "Add a high score tracker that persists between game sessions"
          ],
          "quiz": [
            {
              "question": "What is the purpose of the main game loop?",
              "options": ["Allow multiple games", "Handle single guess", "Generate random numbers", "Display messages"],
              "answer": "Allow multiple games",
              "reasoning": "The outer while loop allows players to play multiple games without restarting."
            },
            {
              "question": "Why do we use input validation?",
              "options": ["Handle invalid user input", "Make game harder", "Increase attempts", "Generate random numbers"],
              "answer": "Handle invalid user input",
              "reasoning": "Input validation prevents crashes and handles unexpected user inputs gracefully."
            },
            {
              "question": "What does the continue statement do in the validation?",
              "options": ["Skip invalid attempt", "End game", "Restart game", "Generate new number"],
              "answer": "Skip invalid attempt",
              "reasoning": "Continue skips the current invalid attempt without counting it."
            },
            {
              "question": "How is the random number generated?",
              "options": ["Random class", "Math.random()", "System.random()", "All of the above"],
              "answer": "Random class",
              "reasoning": "We use Random class with nextInt() method for random number generation."
            },
            {
              "question": "What tracking variables are used?",
              "options": ["totalGames, totalWins", "playerName, score", "time, date", "level, difficulty"],
              "answer": "totalGames, totalWins",
              "reasoning": "We track total games played and wins for statistics."
            },
            {
              "question": "Why use constants for game configuration?",
              "options": ["Easy to modify", "Improve performance", "Required by Java", "Make code longer"],
              "answer": "Easy to modify",
              "reasoning": "Constants make it easy to change game settings in one place."
            },
            {
              "question": "What programming concepts are demonstrated?",
              "options": ["All control flow concepts", "Only loops", "Only conditionals", "Only variables"],
              "answer": "All control flow concepts",
              "reasoning": "The project uses variables, conditionals, loops, break, continue, and methods."
            }
          ]
        },
        {
          "title": "Day 14 – Defining and Calling Methods",
          "definition": "Methods are blocks of code that perform specific tasks and can be reused throughout your program, making code organized and maintainable.",
          "explanation": "Think of methods like kitchen appliances - each has a specific purpose (toaster toasts, blender blends) and you can use them whenever needed without knowing how they work internally. Methods help you avoid repeating code, make your programs easier to understand, and allow you to break complex problems into smaller, manageable pieces. We define methods with a name, return type, and parameters, then call them whenever we need their functionality.",
          "code_example": "// Demonstrating method definition and calling\npublic class MethodsDemo {\n    \n    // Method without parameters and return value\n    public static void greetUser() {\n        System.out.println(\"Hello! Welcome to our program!\");\n        System.out.println(\"We're glad to have you here!\");\n    }\n    \n    // Method with parameters but no return value\n    public static void displayMessage(String message, int times) {\n        for (int i = 0; i < times; i++) {\n            System.out.println((i + 1) + \". \" + message);\n        }\n    }\n    \n    // Method with parameters and return value\n    public static int calculateSquare(int number) {\n        int square = number * number;\n        return square;  // Return the result\n    }\n    \n    // Method with multiple parameters and return value\n    public static double calculateRectangleArea(double length, double width) {\n        return length * width;\n    }\n    \n    // Method that calls other methods\n    public static void printSquareInfo(int num) {\n        int result = calculateSquare(num);\n        System.out.println(\"The square of \" + num + \" is: \" + result);\n    }\n    \n    // Method with conditional logic\n    public static String checkNumber(int number) {\n        if (number > 0) {\n            return \"Positive\";\n        } else if (number < 0) {\n            return \"Negative\";\n        } else {\n            return \"Zero\";\n        }\n    }\n    \n    // Main method - program entry point\n    public static void main(String[] args) {\n        System.out.println(\"=== Method Demonstration ===\\n\");\n        \n        // Calling method without parameters\n        greetUser();\n        \n        System.out.println(\"\\n--- Calling methods with parameters ---\");\n        \n        // Calling method with parameters\n        displayMessage(\"Java is fun!\", 3);\n        \n        // Calling method that returns a value\n        int num = 5;\n        int squared = calculateSquare(num);\n        System.out.println(\"\\nSquare of \" + num + \" is: \" + squared);\n        \n        // Using returned value directly\n        System.out.println(\"Square of 8 is: \" + calculateSquare(8));\n        \n        // Calling method with multiple parameters\n        double area = calculateRectangleArea(5.5, 3.2);\n        System.out.println(\"Rectangle area: \" + area);\n        \n        System.out.println(\"\\n--- Method chaining ---\");\n        \n        // Calling method that calls other methods\n        printSquareInfo(7);\n        \n        System.out.println(\"\\n--- Methods with conditional logic ---\");\n        \n        // Using method with conditional return\n        System.out.println(\"10 is: \" + checkNumber(10));\n        System.out.println(\"-5 is: \" + checkNumber(-5));\n        System.out.println(\"0 is: \" + checkNumber(0));\n        \n        // Practical example: Calculator methods\n        System.out.println(\"\\n--- Calculator Example ---\");\n        \n        int a = 15, b = 4;\n        System.out.println(a + \" + \" + b + \" = \" + add(a, b));\n        System.out.println(a + \" - \" + b + \" = \" + subtract(a, b));\n        System.out.println(a + \" * \" + b + \" = \" + multiply(a, b));\n        System.out.println(a + \" / \" + b + \" = \" + divide(a, b));\n    }\n    \n    // Additional calculator methods\n    public static int add(int x, int y) {\n        return x + y;\n    }\n    \n    public static int subtract(int x, int y) {\n        return x - y;\n    }\n    \n    public static int multiply(int x, int y) {\n        return x * y;\n    }\n    \n    public static double divide(int x, int y) {\n        if (y == 0) {\n            System.out.println(\"Error: Division by zero!\");\n            return 0;\n        }\n        return (double) x / y;\n    }\n}",
          "real_world_example": "Methods are fundamental in all professional software development. Web applications use methods to handle HTTP requests, process data, and generate responses. Mobile apps use methods to handle user interactions, manage data, and communicate with servers. Game development uses methods for game logic, rendering, and user input. Methods enable code reuse, team collaboration, and maintainable software architecture.",
          "interactive_tasks": [
            "Create a method that converts temperature between Celsius and Fahrenheit",
            "Write a method that checks if a number is prime and returns boolean",
            "Create a method that generates and returns a random password string"
          ],
          "quiz": [
            {
              "question": "What is the purpose of methods?",
              "options": ["Code reuse and organization", "Make programs faster", "Only for mathematics", "Required by Java"],
              "answer": "Code reuse and organization",
              "reasoning": "Methods help organize code into reusable, manageable pieces."
            },
            {
              "question": "What does 'void' mean in method declaration?",
              "options": ["No return value", "Takes no parameters", "Method is empty", "Returns null"],
              "answer": "No return value",
              "reasoning": "Void indicates the method doesn't return any value."
            },
            {
              "question": "What are method parameters?",
              "options": ["Input values for method", "Return values", "Method names", "Local variables"],
              "answer": "Input values for method",
              "reasoning": "Parameters are values passed to methods for processing."
            },
            {
              "question": "How do you call a method?",
              "options": ["methodName();", "call methodName;", "execute methodName;", "run methodName;"],
              "answer": "methodName();",
              "reasoning": "Methods are called using their name followed by parentheses."
            },
            {
              "question": "What is method signature?",
              "options": ["Method name + parameters", "Return type only", "Method body", "Access modifier"],
              "answer": "Method name + parameters",
              "reasoning": "Method signature includes name and parameter types (not return type)."
            },
            {
              "question": "Can methods call other methods?",
              "options": ["Yes", "No", "Only static methods", "Only in same class"],
              "answer": "Yes",
              "reasoning": "Methods can call other methods, including themselves (recursion)."
            },
            {
              "question": "What is method overloading?",
              "options": ["Same name, different parameters", "Different name, same parameters", "Same everything", "Different return types only"],
              "answer": "Same name, different parameters",
              "reasoning": "Overloading means multiple methods with same name but different parameters."
            }
          ]
        },
        {
          "title": "Day 15 – Parameters and Return Values",
          "definition": "Parameters are variables in method declarations that receive values from method calls, and return values are results that methods send back to the caller.",
          "explanation": "Think of parameters like order forms - they specify what information a method needs to do its job. Return values are like the finished product that gets delivered back. Parameters allow methods to work with different data each time they're called, while return values let methods produce results that can be used elsewhere in your program. Understanding how to effectively use parameters and return values is key to writing flexible, reusable methods.",
          "code_example": "// Demonstrating parameters and return values\npublic class ParametersReturnDemo {\n    \n    // Method with multiple parameters and return value\n    public static double calculateCircleArea(double radius) {\n        return Math.PI * radius * radius;\n    }\n    \n    // Method with multiple parameters\n    public static String createFullName(String firstName, String lastName, String middleName) {\n        if (middleName == null || middleName.isEmpty()) {\n            return firstName + \" \" + lastName;\n        } else {\n            return firstName + \" \" + middleName + \" \" + lastName;\n        }\n    }\n    \n    // Method that returns boolean\n    public static boolean isEven(int number) {\n        return number % 2 == 0;\n    }\n    \n    // Method that returns array\n    public static int[] generateNumbers(int start, int end, int step) {\n        int size = (end - start) / step + 1;\n        int[] numbers = new int[size];\n        \n        for (int i = 0; i < size; i++) {\n            numbers[i] = start + (i * step);\n        }\n        \n        return numbers;\n    }\n    \n    // Method with default parameter simulation (using overloading)\n    public static double calculateDiscount(double price) {\n        return calculateDiscount(price, 10.0); // Default 10% discount\n    }\n    \n    public static double calculateDiscount(double price, double discountPercent) {\n        return price * (1 - discountPercent / 100);\n    }\n    \n    // Method that modifies parameters (primitive vs reference)\n    public static void modifyValues(int primitiveParam, int[] referenceParam) {\n        primitiveParam = 100; // This won't affect original\n        if (referenceParam.length > 0) {\n            referenceParam[0] = 999; // This will affect original array\n        }\n    }\n    \n    // Method with variable arguments (varargs)\n    public static double findAverage(int... numbers) {\n        if (numbers.length == 0) {\n            return 0.0;\n        }\n        \n        int sum = 0;\n        for (int num : numbers) {\n            sum += num;\n        }\n        \n        return (double) sum / numbers.length;\n    }\n    \n    // Method that returns multiple values using array\n    public static double[] calculateCircleProperties(double radius) {\n        double area = Math.PI * radius * radius;\n        double circumference = 2 * Math.PI * radius;\n        double diameter = 2 * radius;\n        \n        return new double[]{area, circumference, diameter};\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"=== Parameters and Return Values ===\\n\");\n        \n        // Using method with return value\n        double area = calculateCircleArea(5.0);\n        System.out.println(\"Circle area with radius 5: \" + area);\n        \n        // Using method with multiple parameters\n        String fullName1 = createFullName(\"John\", \"Doe\", \"Michael\");\n        String fullName2 = createFullName(\"Jane\", \"Smith\", null);\n        System.out.println(\"Full name 1: \" + fullName1);\n        System.out.println(\"Full name 2: \" + fullName2);\n        \n        // Using boolean return method\n        System.out.println(\"\\nEven number check:\");\n        System.out.println(\"Is 10 even? \" + isEven(10));\n        System.out.println(\"Is 7 even? \" + isEven(7));\n        \n        // Using method that returns array\n        int[] numberSequence = generateNumbers(0, 20, 5);\n        System.out.println(\"\\nGenerated numbers: \");\n        for (int num : numberSequence) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n        \n        // Using overloaded methods (default parameter simulation)\n        System.out.println(\"\\nDiscount calculations:\");\n        System.out.println(\"Price $100 with default discount: $\" + calculateDiscount(100.0));\n        System.out.println(\"Price $100 with 25% discount: $\" + calculateDiscount(100.0, 25.0));\n        \n        // Demonstrating parameter passing\n        System.out.println(\"\\nParameter passing demonstration:\");\n        int primitiveValue = 50;\n        int[] referenceValue = {1, 2, 3};\n        \n        System.out.println(\"Before modification:\");\n        System.out.println(\"primitiveValue: \" + primitiveValue);\n        System.out.println(\"referenceValue[0]: \" + referenceValue[0]);\n        \n        modifyValues(primitiveValue, referenceValue);\n        \n        System.out.println(\"After modification:\");\n        System.out.println(\"primitiveValue: \" + primitiveValue + \" (unchanged - primitive)\");\n        System.out.println(\"referenceValue[0]: \" + referenceValue[0] + \" (changed - reference)\");\n        \n        // Using varargs\n        System.out.println(\"\\nAverage calculations:\");\n        System.out.println(\"Average of 10, 20, 30: \" + findAverage(10, 20, 30));\n        System.out.println(\"Average of 5, 15, 25, 35, 45: \" + findAverage(5, 15, 25, 35, 45));\n        System.out.println(\"Average of no numbers: \" + findAverage());\n        \n        // Using method that returns multiple values\n        System.out.println(\"\\nCircle properties for radius 7:\");\n        double[] properties = calculateCircleProperties(7.0);\n        System.out.println(\"Area: \" + properties[0]);\n        System.out.println(\"Circumference: \" + properties[1]);\n        System.out.println(\"Diameter: \" + properties[2]);\n        \n        // Practical example: Student grade calculator\n        System.out.println(\"\\n=== Student Grade Calculator ===\");\n        double[] grades = {85.5, 92.0, 78.5, 88.0, 95.5};\n        double averageGrade = calculateAverage(grades);\n        String letterGrade = convertToLetterGrade(averageGrade);\n        \n        System.out.println(\"Grades: \");\n        for (double grade : grades) {\n            System.out.print(grade + \" \");\n        }\n        System.out.println(\"\\nAverage: \" + averageGrade);\n        System.out.println(\"Letter Grade: \" + letterGrade);\n    }\n    \n    // Helper methods for grade calculator\n    public static double calculateAverage(double[] grades) {\n        if (grades.length == 0) return 0.0;\n        \n        double sum = 0;\n        for (double grade : grades) {\n            sum += grade;\n        }\n        return sum / grades.length;\n    }\n    \n    public static String convertToLetterGrade(double average) {\n        if (average >= 90) return \"A\";\n        else if (average >= 80) return \"B\";\n        else if (average >= 70) return \"C\";\n        else if (average >= 60) return \"D\";\n        else return \"F\";\n    }\n}",
          "real_world_example": "Parameters and return values are used extensively in real applications. API endpoints take parameters in requests and return data in responses. Database queries take search parameters and return result sets. Mathematical libraries take input values and return computed results. User authentication systems take credentials as parameters and return authentication status. E-commerce systems take order details and return order confirmation with tracking numbers.",
          "interactive_tasks": [
            "Create a method that takes three numbers and returns the largest one",
            "Write a method that converts seconds to hours, minutes, and seconds and returns them as an array",
            "Create a method that validates email format and returns boolean"
          ],
          "quiz": [
            {
              "question": "What are method parameters?",
              "options": ["Input values for method", "Return values from method", "Local variables", "Method names"],
              "answer": "Input values for method",
              "reasoning": "Parameters are the values passed to a method when it's called."
            },
            {
              "question": "What is the return type of a method that doesn't return anything?",
              "options": ["void", "null", "int", "String"],
              "answer": "void",
              "reasoning": "Void indicates a method doesn't return any value."
            },
            {
              "question": "Can a method have multiple return statements?",
              "options": ["Yes, with conditions", "No, only one", "Only in void methods", "Only with loops"],
              "answer": "Yes, with conditions",
              "reasoning": "Methods can have multiple return statements with conditional logic."
            },
            {
              "question": "What happens to primitive parameters when modified?",
              "options": ["Changes are local", "Affects original", "Causes error", "Returns new value"],
              "answer": "Changes are local",
              "reasoning": "Primitive parameters are passed by value, so changes don't affect originals."
            },
            {
              "question": "What are varargs?",
              "options": ["Variable number of arguments", "Various arguments", "Valid arguments", "Void arguments"],
              "answer": "Variable number of arguments",
              "reasoning": "Varargs allow methods to accept variable number of arguments of same type."
            },
            {
              "question": "How to return multiple values from a method?",
              "options": ["Using array or object", "Multiple return statements", "Not possible", "Using global variables"],
              "answer": "Using array or object",
              "reasoning": "Arrays or objects can bundle multiple values for return."
            },
            {
              "question": "What is method overloading?",
              "options": ["Same name, different parameters", "Different return types", "Same parameters", "Different names"],
              "answer": "Same name, different parameters",
              "reasoning": "Overloading means multiple methods with same name but different parameters."
            }
          ]
        },
        {
          "title": "Day 16 – Arrays",
          "definition": "Arrays are data structures that store multiple values of the same type in contiguous memory locations, accessible through a single variable name and index.",
          "explanation": "Think of arrays like a row of lockers - each locker has a number (index) and can store one item. All lockers are the same size (same data type) and are arranged in order. Arrays let you work with collections of data efficiently. Instead of creating many separate variables, you create one array that can hold many values. This makes it easy to perform operations on entire sets of data, like finding averages, searching for values, or sorting.",
          "code_example": "// Demonstrating arrays in Java\npublic class ArraysDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Arrays Demonstration ===\\n\");\n        \n        // Array declaration and initialization\n        int[] numbers = new int[5];  // Array of 5 integers\n        \n        // Assigning values to array elements\n        numbers[0] = 10;  // First element (index 0)\n        numbers[1] = 20;  // Second element (index 1)\n        numbers[2] = 30;\n        numbers[3] = 40;\n        numbers[4] = 50;  // Last element (index 4)\n        \n        // Alternative initialization\n        int[] scores = {85, 92, 78, 90, 88};  // Declare and initialize\n        \n        // Accessing array elements\n        System.out.println(\"First number: \" + numbers[0]);\n        System.out.println(\"Third score: \" + scores[2]);\n        \n        // Array length\n        System.out.println(\"\\nArray lengths:\");\n        System.out.println(\"Numbers array length: \" + numbers.length);\n        System.out.println(\"Scores array length: \" + scores.length);\n        \n        // Looping through arrays\n        System.out.println(\"\\nNumbers array:\");\n        for (int i = 0; i < numbers.length; i++) {\n            System.out.println(\"Index \" + i + \": \" + numbers[i]);\n        }\n        \n        // Enhanced for loop (for-each)\n        System.out.println(\"\\nScores array (for-each):\");\n        for (int score : scores) {\n            System.out.println(\"Score: \" + score);\n        }\n        \n        // String array\n        String[] fruits = {\"Apple\", \"Banana\", \"Orange\", \"Grape\", \"Mango\"};\n        \n        System.out.println(\"\\nFruits:\");\n        for (String fruit : fruits) {\n            System.out.println(\"• \" + fruit);\n        }\n        \n        // Array operations\n        System.out.println(\"\\n=== Array Operations ===\");\n        \n        // Finding sum and average\n        int sum = 0;\n        for (int score : scores) {\n            sum += score;\n        }\n        double average = (double) sum / scores.length;\n        System.out.println(\"Sum of scores: \" + sum);\n        System.out.println(\"Average score: \" + average);\n        \n        // Finding maximum value\n        int max = scores[0];\n        for (int i = 1; i < scores.length; i++) {\n            if (scores[i] > max) {\n                max = scores[i];\n            }\n        }\n        System.out.println(\"Highest score: \" + max);\n        \n        // Finding minimum value\n        int min = scores[0];\n        for (int i = 1; i < scores.length; i++) {\n            if (scores[i] < min) {\n                min = scores[i];\n            }\n        }\n        System.out.println(\"Lowest score: \" + min);\n        \n        // Searching in array\n        int searchValue = 90;\n        boolean found = false;\n        int position = -1;\n        \n        for (int i = 0; i < scores.length; i++) {\n            if (scores[i] == searchValue) {\n                found = true;\n                position = i;\n                break;\n            }\n        }\n        \n        if (found) {\n            System.out.println(\"Value \" + searchValue + \" found at index: \" + position);\n        } else {\n            System.out.println(\"Value \" + searchValue + \" not found\");\n        }\n        \n        // Modifying array elements\n        System.out.println(\"\\n=== Modifying Arrays ===\");\n        \n        int[] values = {1, 2, 3, 4, 5};\n        System.out.println(\"Original array:\");\n        printArray(values);\n        \n        // Double each value\n        for (int i = 0; i < values.length; i++) {\n            values[i] = values[i] * 2;\n        }\n        \n        System.out.println(\"After doubling:\");\n        printArray(values);\n        \n        // Array as method parameter\n        System.out.println(\"\\n=== Arrays with Methods ===\");\n        \n        int[] testArray = {12, 45, 23, 67, 34, 89};\n        System.out.println(\"Test array:\");\n        printArray(testArray);\n        \n        System.out.println(\"Sum: \" + calculateSum(testArray));\n        System.out.println(\"Average: \" + calculateAverage(testArray));\n        System.out.println(\"Maximum: \" + findMaximum(testArray));\n        \n        // Array copying\n        System.out.println(\"\\n=== Array Copying ===\");\n        \n        int[] original = {1, 2, 3, 4, 5};\n        int[] copy = new int[original.length];\n        \n        // Manual copying\n        for (int i = 0; i < original.length; i++) {\n            copy[i] = original[i];\n        }\n        \n        System.out.println(\"Original array:\");\n        printArray(original);\n        System.out.println(\"Copied array:\");\n        printArray(copy);\n        \n        // Modify copy to show they're separate\n        copy[0] = 100;\n        System.out.println(\"After modifying copy:\");\n        System.out.println(\"Original[0]: \" + original[0]);\n        System.out.println(\"Copy[0]: \" + copy[0]);\n    }\n    \n    // Method to print array\n    public static void printArray(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i]);\n            if (i < arr.length - 1) {\n                System.out.print(\", \");\n            }\n        }\n        System.out.println();\n    }\n    \n    // Method to calculate sum of array\n    public static int calculateSum(int[] arr) {\n        int sum = 0;\n        for (int num : arr) {\n            sum += num;\n        }\n        return sum;\n    }\n    \n    // Method to calculate average\n    public static double calculateAverage(int[] arr) {\n        if (arr.length == 0) return 0.0;\n        int sum = calculateSum(arr);\n        return (double) sum / arr.length;\n    }\n    \n    // Method to find maximum\n    public static int findMaximum(int[] arr) {\n        if (arr.length == 0) return -1;\n        \n        int max = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        return max;\n    }\n}",
          "real_world_example": "Arrays are fundamental in real-world programming. Social media apps use arrays to store user posts, games use arrays for high scores and player inventories, banking apps use arrays for transaction histories, and e-commerce sites use arrays for shopping cart items. Data analysis applications process large arrays of numbers, and image processing works with arrays of pixel values. Arrays provide efficient storage and access for collections of related data.",
          "interactive_tasks": [
            "Create a program that stores 10 numbers in an array and finds their sum and average",
            "Write a program that reverses the elements of an array",
            "Create a program that finds the most frequent number in an array"
          ],
          "quiz": [
            {
              "question": "What is the first index of an array?",
              "options": ["0", "1", "-1", "first"],
              "answer": "0",
              "reasoning": "Array indices start at 0 in Java, not 1."
            },
            {
              "question": "How do you get the length of an array?",
              "options": [".length", ".size()", ".count()", ".getLength()"],
              "answer": ".length",
              "reasoning": "Arrays have a length property, not a method."
            },
            {
              "question": "What happens if you access an invalid index?",
              "options": ["ArrayIndexOutOfBoundsException", "NullPointerException", "Compiler error", "Returns 0"],
              "answer": "ArrayIndexOutOfBoundsException",
              "reasoning": "Accessing beyond array bounds throws ArrayIndexOutOfBoundsException."
            },
            {
              "question": "Which loop is best for array iteration?",
              "options": ["for or for-each", "while only", "do-while only", "No loops needed"],
              "answer": "for or for-each",
              "reasoning": "For loops with index or for-each loops are ideal for arrays."
            },
            {
              "question": "Can arrays store different data types?",
              "options": ["No, same type only", "Yes, any types", "Only numbers", "Only objects"],
              "answer": "No, same type only",
              "reasoning": "Java arrays can only store elements of the same data type."
            },
            {
              "question": "What is the default value for int array elements?",
              "options": ["0", "null", "1", "undefined"],
              "answer": "0",
              "reasoning": "Primitive int arrays are initialized with 0 values."
            },
            {
              "question": "How to copy arrays properly?",
              "options": ["Loop or System.arraycopy", "Use = operator", "Cannot be copied", "Use copy() method"],
              "answer": "Loop or System.arraycopy",
              "reasoning": "Assignment copies reference; proper copying requires looping or System.arraycopy."
            }
          ]
        },
        {
          "title": "Day 17 – Multi-Dimensional Arrays",
          "definition": "Multi-dimensional arrays are arrays of arrays, allowing you to store data in tabular form with rows and columns, useful for representing grids, matrices, and tables.",
          "explanation": "Think of a 2D array like a spreadsheet with rows and columns, or a chess board with ranks and files. A 3D array would be like a stack of spreadsheets. Multi-dimensional arrays let you organize data in multiple dimensions, making them perfect for representing anything that has a grid-like structure. In Java, 2D arrays are the most common, but you can have arrays with even more dimensions for complex data structures.",
          "code_example": "// Demonstrating multi-dimensional arrays\npublic class MultiDimensionalArraysDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Multi-Dimensional Arrays ===\\n\");\n        \n        // 2D array declaration and initialization\n        int[][] matrix = new int[3][4];  // 3 rows, 4 columns\n        \n        // Assigning values to 2D array\n        matrix[0][0] = 1;  // Row 0, Column 0\n        matrix[0][1] = 2;\n        matrix[0][2] = 3;\n        matrix[0][3] = 4;\n        \n        matrix[1][0] = 5;  // Row 1, Column 0\n        matrix[1][1] = 6;\n        matrix[1][2] = 7;\n        matrix[1][3] = 8;\n        \n        matrix[2][0] = 9;  // Row 2, Column 0\n        matrix[2][1] = 10;\n        matrix[2][2] = 11;\n        matrix[2][3] = 12;\n        \n        // Alternative initialization\n        int[][] predefinedMatrix = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        \n        // Displaying 2D arrays\n        System.out.println(\"3x4 Matrix:\");\n        print2DArray(matrix);\n        \n        System.out.println(\"\\n3x3 Predefined Matrix:\");\n        print2DArray(predefinedMatrix);\n        \n        // Accessing elements\n        System.out.println(\"\\nElement at [1][2]: \" + matrix[1][2]);\n        System.out.println(\"Element at [2][1]: \" + predefinedMatrix[2][1]);\n        \n        // Array dimensions\n        System.out.println(\"\\nMatrix dimensions:\");\n        System.out.println(\"Rows: \" + matrix.length);\n        System.out.println(\"Columns in row 0: \" + matrix[0].length);\n        \n        // Jagged arrays (arrays with different row lengths)\n        System.out.println(\"\\n=== Jagged Arrays ===\");\n        \n        int[][] jaggedArray = new int[3][];  // 3 rows, unknown columns\n        jaggedArray[0] = new int[2];  // Row 0 has 2 columns\n        jaggedArray[1] = new int[4];  // Row 1 has 4 columns\n        jaggedArray[2] = new int[3];  // Row 2 has 3 columns\n        \n        // Initialize jagged array\n        int value = 1;\n        for (int i = 0; i < jaggedArray.length; i++) {\n            for (int j = 0; j < jaggedArray[i].length; j++) {\n                jaggedArray[i][j] = value++;\n            }\n        }\n        \n        System.out.println(\"Jagged Array:\");\n        printJaggedArray(jaggedArray);\n        \n        // 3D arrays\n        System.out.println(\"\\n=== 3D Arrays ===\");\n        \n        int[][][] threeDArray = new int[2][3][4];  // 2 layers, 3 rows, 4 columns\n        \n        // Initialize 3D array\n        int counter = 1;\n        for (int i = 0; i < threeDArray.length; i++) {\n            for (int j = 0; j < threeDArray[i].length; j++) {\n                for (int k = 0; k < threeDArray[i][j].length; k++) {\n                    threeDArray[i][j][k] = counter++;\n                }\n            }\n        }\n        \n        System.out.println(\"3D Array (first layer):\");\n        print2DArray(threeDArray[0]);\n        \n        System.out.println(\"\\n3D Array (second layer):\");\n        print2DArray(threeDArray[1]);\n        \n        // Practical examples\n        System.out.println(\"\\n=== Practical Examples ===\");\n        \n        // Student grades table\n        String[] students = {\"Alice\", \"Bob\", \"Charlie\"};\n        String[] subjects = {\"Math\", \"Science\", \"English\"};\n        int[][] grades = {\n            {85, 92, 78},  // Alice's grades\n            {76, 88, 90},  // Bob's grades\n            {92, 95, 87}   // Charlie's grades\n        };\n        \n        System.out.println(\"Student Grade Report:\");\n        System.out.print(\"Student\\t\\t\");\n        for (String subject : subjects) {\n            System.out.print(subject + \"\\t\");\n        }\n        System.out.println(\"Average\");\n        \n        for (int i = 0; i < students.length; i++) {\n            System.out.print(students[i] + \"\\t\\t\");\n            int sum = 0;\n            for (int j = 0; j < subjects.length; j++) {\n                System.out.print(grades[i][j] + \"\\t\\t\");\n                sum += grades[i][j];\n            }\n            double average = (double) sum / subjects.length;\n            System.out.printf(\"%.2f\\n\", average);\n        }\n        \n        // Matrix operations\n        System.out.println(\"\\n=== Matrix Operations ===\");\n        \n        int[][] matrixA = {{1, 2, 3}, {4, 5, 6}};\n        int[][] matrixB = {{7, 8, 9}, {10, 11, 12}};\n        \n        System.out.println(\"Matrix A:\");\n        print2DArray(matrixA);\n        \n        System.out.println(\"Matrix B:\");\n        print2DArray(matrixB);\n        \n        System.out.println(\"Matrix A + B:\");\n        int[][] sumMatrix = addMatrices(matrixA, matrixB);\n        print2DArray(sumMatrix);\n        \n        // Transpose of matrix\n        System.out.println(\"Transpose of Matrix A:\");\n        int[][] transposeA = transposeMatrix(matrixA);\n        print2DArray(transposeA);\n    }\n    \n    // Method to print 2D array\n    public static void print2DArray(int[][] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[i].length; j++) {\n                System.out.print(arr[i][j] + \"\\t\");\n            }\n            System.out.println();\n        }\n    }\n    \n    // Method to print jagged array\n    public static void printJaggedArray(int[][] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(\"Row \" + i + \": \");\n            for (int j = 0; j < arr[i].length; j++) {\n                System.out.print(arr[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n    \n    // Method to add two matrices\n    public static int[][] addMatrices(int[][] a, int[][] b) {\n        if (a.length != b.length || a[0].length != b[0].length) {\n            System.out.println(\"Matrices must have same dimensions!\");\n            return null;\n        }\n        \n        int[][] result = new int[a.length][a[0].length];\n        \n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < a[i].length; j++) {\n                result[i][j] = a[i][j] + b[i][j];\n            }\n        }\n        \n        return result;\n    }\n    \n    // Method to transpose matrix\n    public static int[][] transposeMatrix(int[][] matrix) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        \n        int[][] transpose = new int[cols][rows];\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                transpose[j][i] = matrix[i][j];\n            }\n        }\n        \n        return transpose;\n    }\n}",
          "real_world_example": "Multi-dimensional arrays are essential in many real-world applications. Image processing uses 2D arrays to represent pixels in images, game development uses them for game boards and maps, scientific computing uses them for matrices in simulations, and spreadsheet applications use them to store cell data. 3D arrays are used in medical imaging (CT scans), computer graphics (3D models), and data analysis for multi-dimensional datasets.",
          "interactive_tasks": [
            "Create a program that represents a tic-tac-toe board using a 2D array",
            "Write a program that finds the sum of each row and column in a 2D array",
            "Create a program that rotates a 2D array by 90 degrees"
          ],
          "quiz": [
            {
              "question": "How do you declare a 2D array?",
              "options": ["int[][] arr;", "int[] arr[];", "int arr[][];", "All of the above"],
              "answer": "All of the above",
              "reasoning": "All three syntaxes are valid for declaring 2D arrays in Java."
            },
            {
              "question": "What is a jagged array?",
              "options": ["Rows have different lengths", "All rows same length", "3D array", "Empty array"],
              "answer": "Rows have different lengths",
              "reasoning": "Jagged arrays have rows with different numbers of columns."
            },
            {
              "question": "How to access element in row 2, column 3?",
              "options": ["arr[1][2]", "arr[2][3]", "arr(2,3)", "arr.get(2,3)"],
              "answer": "arr[1][2]",
              "reasoning": "Array indices start at 0, so row 2 is index 1, column 3 is index 2."
            },
            {
              "question": "What does arr.length give for 2D array?",
              "options": ["Number of rows", "Number of columns", "Total elements", "Row length"],
              "answer": "Number of rows",
              "reasoning": "For 2D arrays, arr.length gives the number of rows."
            },
            {
              "question": "How to get columns in specific row?",
              "options": ["arr[row].length", "arr.length[row]", "arr.columns", "arr[row].columns"],
              "answer": "arr[row].length",
              "reasoning": "arr[row].length gives columns in that specific row."
            },
            {
              "question": "Can 2D arrays have different data types?",
              "options": ["No, same type throughout", "Yes, different per row", "Yes, different per cell", "Only numbers allowed"],
              "answer": "No, same type throughout",
              "reasoning": "All elements in 2D arrays must be the same data type."
            },
            {
              "question": "What is the default value for boolean 2D array?",
              "options": ["false", "true", "null", "0"],
              "answer": "false",
              "reasoning": "Boolean arrays are initialized with false values."
            }
          ]
        },
        {
          "title": "Day 18 – String Handling",
          "definition": "String handling involves working with text data using Java's String class, which provides methods for manipulating, searching, and processing textual information.",
          "explanation": "Think of strings like sentences or words that you can manipulate - you can cut them, join them, search within them, change their case, and much more. Strings in Java are objects, not primitive types, which means they come with many useful built-in methods. However, strings are also immutable, meaning once created, they cannot be changed. Understanding how to work with strings efficiently is crucial since text processing is fundamental to most applications.",
          "code_example": "// Demonstrating string handling in Java\npublic class StringHandlingDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== String Handling ===\\n\");\n        \n        // Different ways to create strings\n        String str1 = \"Hello\";  // String literal\n        String str2 = new String(\"World\");  // Using constructor\n        char[] charArray = {'J', 'a', 'v', 'a'};\n        String str3 = new String(charArray);  // From char array\n        \n        System.out.println(\"String 1: \" + str1);\n        System.out.println(\"String 2: \" + str2);\n        System.out.println(\"String 3: \" + str3);\n        \n        // String concatenation\n        String greeting = str1 + \" \" + str2 + \"!\";\n        System.out.println(\"\\nConcatenated: \" + greeting);\n        \n        // Using concat method\n        String fullGreeting = str1.concat(\" \").concat(str2).concat(\"!\");\n        System.out.println(\"Using concat: \" + fullGreeting);\n        \n        // String length\n        System.out.println(\"\\nLength of '\" + greeting + \"': \" + greeting.length());\n        \n        // Character access\n        System.out.println(\"\\nCharacter at position 4 in '\" + greeting + \"': \" + greeting.charAt(4));\n        \n        // String comparison\n        System.out.println(\"\\n=== String Comparison ===\");\n        \n        String s1 = \"hello\";\n        String s2 = \"hello\";\n        String s3 = \"HELLO\";\n        String s4 = new String(\"hello\");\n        \n        System.out.println(\"s1 == s2: \" + (s1 == s2));  // true (string pool)\n        System.out.println(\"s1 == s4: \" + (s1 == s4));  // false (different objects)\n        System.out.println(\"s1.equals(s2): \" + s1.equals(s2));  // true\n        System.out.println(\"s1.equals(s4): \" + s1.equals(s4));  // true\n        System.out.println(\"s1.equals(s3): \" + s1.equals(s3));  // false\n        System.out.println(\"s1.equalsIgnoreCase(s3): \" + s1.equalsIgnoreCase(s3));  // true\n        \n        // String searching\n        System.out.println(\"\\n=== String Searching ===\");\n        \n        String text = \"The quick brown fox jumps over the lazy dog\";\n        \n        System.out.println(\"Text: \" + text);\n        System.out.println(\"Contains 'fox': \" + text.contains(\"fox\"));\n        System.out.println(\"Index of 'brown': \" + text.indexOf(\"brown\"));\n        System.out.println(\"Last index of 'the': \" + text.lastIndexOf(\"the\"));\n        System.out.println(\"Starts with 'The': \" + text.startsWith(\"The\"));\n        System.out.println(\"Ends with 'dog': \" + text.endsWith(\"dog\"));\n        \n        // String extraction\n        System.out.println(\"\\n=== String Extraction ===\");\n        \n        System.out.println(\"Substring from index 10: \" + text.substring(10));\n        System.out.println(\"Substring from 10 to 15: \" + text.substring(10, 15));\n        \n        // String modification\n        System.out.println(\"\\n=== String Modification ===\");\n        \n        System.out.println(\"Uppercase: \" + text.toUpperCase());\n        System.out.println(\"Lowercase: \" + text.toLowerCase());\n        System.out.println(\"Replace 'fox' with 'cat': \" + text.replace(\"fox\", \"cat\"));\n        System.out.println(\"Trim spaces: '\" + \"   hello world   \".trim() + \"'\");\n        \n        // String splitting\n        System.out.println(\"\\n=== String Splitting ===\");\n        \n        String csv = \"apple,banana,orange,grape\";\n        String[] fruits = csv.split(\",\");\n        \n        System.out.println(\"CSV: \" + csv);\n        System.out.println(\"Split fruits:\");\n        for (String fruit : fruits) {\n            System.out.println(\"  - \" + fruit);\n        }\n        \n        // Multi-line string splitting\n        String multiLine = \"Line 1\\nLine 2\\nLine 3\";\n        String[] lines = multiLine.split(\"\\n\");\n        \n        System.out.println(\"\\nMulti-line text:\");\n        for (String line : lines) {\n            System.out.println(\"  \" + line);\n        }\n        \n        // String building with StringBuilder\n        System.out.println(\"\\n=== StringBuilder ===\");\n        \n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Hello\");\n        sb.append(\" \");\n        sb.append(\"World\");\n        sb.append(\"!\");\n        \n        System.out.println(\"StringBuilder result: \" + sb.toString());\n        \n        // More StringBuilder operations\n        sb.insert(5, \" Beautiful\");\n        System.out.println(\"After insert: \" + sb.toString());\n        \n        sb.replace(6, 15, \"Amazing\");\n        System.out.println(\"After replace: \" + sb.toString());\n        \n        sb.delete(5, 13);\n        System.out.println(\"After delete: \" + sb.toString());\n        \n        sb.reverse();\n        System.out.println(\"Reversed: \" + sb.toString());\n        \n        // Practical examples\n        System.out.println(\"\\n=== Practical Examples ===\");\n        \n        // Email validation\n        String email = \"user@example.com\";\n        boolean isValidEmail = email.contains(\"@\") && email.contains(\".\");\n        System.out.println(\"Is '\" + email + \"' valid? \" + isValidEmail);\n        \n        // Password strength check\n        String password = \"SecurePass123!\";\n        boolean hasUpperCase = !password.equals(password.toLowerCase());\n        boolean hasLowerCase = !password.equals(password.toUpperCase());\n        boolean hasDigit = password.matches(\".*\\\\d.*\");\n        boolean hasSpecial = !password.matches(\"[A-Za-z0-9 ]*\");\n        \n        System.out.println(\"\\nPassword: \" + password);\n        System.out.println(\"Has uppercase: \" + hasUpperCase);\n        System.out.println(\"Has lowercase: \" + hasLowerCase);\n        System.out.println(\"Has digit: \" + hasDigit);\n        System.out.println(\"Has special char: \" + hasSpecial);\n        \n        // Word count\n        String sentence = \"This is a sample sentence for word counting.\";\n        String[] words = sentence.split(\"\\\\s+\");  // Split by whitespace\n        System.out.println(\"\\nSentence: '\" + sentence + \"'\");\n        System.out.println(\"Word count: \" + words.length);\n        \n        // Palindrome check\n        String palindrome = \"racecar\";\n        String reversed = new StringBuilder(palindrome).reverse().toString();\n        boolean isPalindrome = palindrome.equals(reversed);\n        System.out.println(\"\\nIs '\" + palindrome + \"' a palindrome? \" + isPalindrome);\n    }\n}",
          "real_world_example": "String handling is crucial in virtually all applications. Web forms use string validation for emails and passwords, search engines process string queries, text editors manipulate document content, social media apps process user posts and comments, and data processing applications parse CSV and JSON files. Chat applications handle message strings, and file systems work with path strings. Understanding string manipulation is essential for text processing in any domain.",
          "interactive_tasks": [
            "Write a program that counts vowels and consonants in a string",
            "Create a program that reverses words in a sentence but maintains word order",
            "Write a program that validates and formats phone numbers"
          ],
          "quiz": [
            {
              "question": "Are Java strings mutable?",
              "options": ["No, immutable", "Yes, mutable", "Sometimes", "Depends on creation"],
              "answer": "No, immutable",
              "reasoning": "Strings are immutable; operations create new strings rather than modifying existing ones."
            },
            {
              "question": "Which is better for frequent string modifications?",
              "options": ["StringBuilder", "String", "char array", "All equal"],
              "answer": "StringBuilder",
              "reasoning": "StringBuilder is mutable and more efficient for frequent modifications."
            },
            {
              "question": "What does trim() method do?",
              "options": ["Removes leading/trailing spaces", "Removes all spaces", "Makes string shorter", "Adds spaces"],
              "answer": "Removes leading/trailing spaces",
              "reasoning": "Trim removes whitespace from beginning and end of string."
            },
            {
              "question": "How to compare strings for equality?",
              "options": [".equals()", "==", ".compare()", ".same()"],
                "answer": ".equals()",
                "reasoning": "Use equals() for content comparison; == compares object references."
                },
                {
                  "question": "What does substring(2,5) return?",
                  "options": ["Chars from index 2 to 4", "Chars from 2 to 5", "First 5 chars", "Last 3 chars"],
                  "answer": "Chars from index 2 to 4",
                  "reasoning": "substring(start,end) returns from start to end-1."
                },
                {
                  "question": "Which method splits string by delimiter?",
                  "options": [".split()", ".divide()", ".break()", ".tokenize()"],
                    "answer": ".split()",
                    "reasoning": "split() method divides string into array using regex delimiter."
                    },
                    {
                      "question": "What is string interning?",
                      "options": ["String pool reuse", "Internationalization", "Internal storage", "Interface implementation"],
                      "answer": "String pool reuse",
                      "reasoning": "Interning stores literals in pool to reuse identical strings."
                    }
                  ]
                },
                {
                  "title": "Day 19 – Common Array and String Operations",
                  "definition": "Common array and string operations include sorting, searching, filtering, and transforming data - essential tasks that you'll frequently perform in programming.",
                  "explanation": "Think of arrays and strings like raw materials that need processing. Just like wood needs cutting, sanding, and finishing, arrays and strings need sorting, searching, and transforming to be useful. Today we'll learn the most common operations you'll use daily as a programmer. These include finding elements, sorting data, converting between formats, and performing bulk operations. Mastering these will make you much more efficient at solving real programming problems.",
                  "code_example": "// Demonstrating common array and string operations\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.ArrayList;\n\npublic class CommonOperationsDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Common Array and String Operations ===\\n\");\n        \n        // Array sorting\n        System.out.println(\"=== Array Sorting ===\");\n        \n        int[] numbers = {5, 2, 8, 1, 9, 3, 7, 4, 6};\n        System.out.println(\"Original array: \" + Arrays.toString(numbers));\n        \n        Arrays.sort(numbers);\n        System.out.println(\"Sorted array: \" + Arrays.toString(numbers));\n        \n        // String array sorting\n        String[] names = {\"John\", \"Alice\", \"Bob\", \"Charlie\", \"Diana\"};\n        System.out.println(\"\\nOriginal names: \" + Arrays.toString(names));\n        \n        Arrays.sort(names);\n        System.out.println(\"Sorted names: \" + Arrays.toString(names));\n        \n        // Reverse sorting\n        Arrays.sort(names, Collections.reverseOrder());\n        System.out.println(\"Reverse sorted names: \" + Arrays.toString(names));\n        \n        // Array searching\n        System.out.println(\"\\n=== Array Searching ===\");\n        \n        int[] sortedNumbers = {1, 3, 5, 7, 9, 11, 13, 15};\n        int searchKey = 7;\n        \n        int index = Arrays.binarySearch(sortedNumbers, searchKey);\n        System.out.println(\"Array: \" + Arrays.toString(sortedNumbers));\n        System.out.println(\"Index of \" + searchKey + \": \" + index);\n        \n        // Manual search\n        int manualIndex = -1;\n        for (int i = 0; i < sortedNumbers.length; i++) {\n            if (sortedNumbers[i] == searchKey) {\n                manualIndex = i;\n                break;\n            }\n        }\n        System.out.println(\"Manual search index: \" + manualIndex);\n        \n        // Array copying\n        System.out.println(\"\\n=== Array Copying ===\");\n        \n        int[] original = {1, 2, 3, 4, 5};\n        int[] copy1 = Arrays.copyOf(original, original.length);\n        int[] copy2 = Arrays.copyOf(original, 3);  // First 3 elements\n        int[] copy3 = Arrays.copyOfRange(original, 1, 4);  // Elements 1-3\n        \n        System.out.println(\"Original: \" + Arrays.toString(original));\n        System.out.println(\"Full copy: \" + Arrays.toString(copy1));\n        System.out.println(\"First 3: \" + Arrays.toString(copy2));\n        System.out.println(\"Range 1-3: \" + Arrays.toString(copy3));\n        \n        // Array comparison\n        System.out.println(\"\\n=== Array Comparison ===\");\n        \n        int[] arr1 = {1, 2, 3};\n        int[] arr2 = {1, 2, 3};\n        int[] arr3 = {1, 2, 4};\n        \n        System.out.println(\"arr1 equals arr2: \" + Arrays.equals(arr1, arr2));\n        System.out.println(\"arr1 equals arr3: \" + Arrays.equals(arr1, arr3));\n        \n        // Array filling\n        System.out.println(\"\\n=== Array Filling ===\");\n        \n        int[] emptyArray = new int[5];\n        System.out.println(\"Before fill: \" + Arrays.toString(emptyArray));\n        \n        Arrays.fill(emptyArray, 42);\n        System.out.println(\"After fill: \" + Arrays.toString(emptyArray));\n        \n        // Partial fill\n        int[] partialArray = new int[10];\n        Arrays.fill(partialArray, 2, 7, 99);  // Fill indices 2-6 with 99\n        System.out.println(\"Partial fill: \" + Arrays.toString(partialArray));\n        \n        // String operations\n        System.out.println(\"\\n=== Common String Operations ===\");\n        \n        // String joining\n        String[] words = {\"Hello\", \"world\", \"from\", \"Java\"};\n        String joined = String.join(\" \", words);\n        System.out.println(\"Joined string: \" + joined);\n        \n        // String formatting\n        String name = \"Alice\";\n        int age = 25;\n        double salary = 55000.75;\n        \n        String formatted = String.format(\"Name: %s, Age: %d, Salary: $%.2f\", name, age, salary);\n        System.out.println(\"Formatted: \" + formatted);\n        \n        // String repetition (Java 11+)\n        String repeated = \"Java \".repeat(3);\n        System.out.println(\"Repeated: \" + repeated);\n        \n        // String blank check (Java 11+)\n        String emptyString = \"\";\n        String blankString = \"   \";\n        String normalString = \"Hello\";\n        \n        System.out.println(\"\\nBlank checks:\");\n        System.out.println(\"'\" + emptyString + \"' is empty: \" + emptyString.isEmpty());\n        System.out.println(\"'\" + blankString + \"' is blank: \" + blankString.isBlank());\n        System.out.println(\"'\" + normalString + \"' is blank: \" + normalString.isBlank());\n        \n        // Practical examples\n        System.out.println(\"\\n=== Practical Examples ===\");\n        \n        // Remove duplicates from array\n        int[] withDuplicates = {1, 2, 2, 3, 4, 4, 4, 5, 5};\n        System.out.println(\"Array with duplicates: \" + Arrays.toString(withDuplicates));\n        \n        int[] withoutDuplicates = removeDuplicates(withDuplicates);\n        System.out.println(\"Without duplicates: \" + Arrays.toString(withoutDuplicates));\n        \n        // Count word frequency\n        String text = \"apple banana apple orange banana apple grape\";\n        System.out.println(\"\\nText: \" + text);\n        countWordFrequency(text);\n        \n        // Find common elements\n        int[] array1 = {1, 2, 3, 4, 5};\n        int[] array2 = {3, 4, 5, 6, 7};\n        System.out.println(\"\\nArray 1: \" + Arrays.toString(array1));\n        System.out.println(\"Array 2: \" + Arrays.toString(array2));\n        \n        int[] common = findCommonElements(array1, array2);\n        System.out.println(\"Common elements: \" + Arrays.toString(common));\n        \n        // String palindrome check\n        String[] testWords = {\"racecar\", \"hello\", \"madam\", \"world\", \"level\"};\n        System.out.println(\"\\nPalindrome check:\");\n        for (String word : testWords) {\n            System.out.println(word + \": \" + isPalindrome(word));\n        }\n        \n        // Array statistics\n        int[] data = {12, 45, 23, 67, 34, 89, 56, 23, 78, 45};\n        System.out.println(\"\\nArray statistics:\");\n        System.out.println(\"Data: \" + Arrays.toString(data));\n        System.out.println(\"Sum: \" + calculateSum(data));\n        System.out.println(\"Average: \" + calculateAverage(data));\n        System.out.println(\"Min: \" + findMin(data));\n        System.out.println(\"Max: \" + findMax(data));\n    }\n    \n    // Method to remove duplicates from array\n    public static int[] removeDuplicates(int[] arr) {\n        if (arr.length == 0) return arr;\n        \n        Arrays.sort(arr);\n        ArrayList<Integer> resultList = new ArrayList<>();\n        resultList.add(arr[0]);\n        \n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] != arr[i - 1]) {\n                resultList.add(arr[i]);\n            }\n        }\n        \n        // Convert back to array\n        int[] result = new int[resultList.size()];\n        for (int i = 0; i < resultList.size(); i++) {\n            result[i] = resultList.get(i);\n        }\n        \n        return result;\n    }\n    \n    // Method to count word frequency\n    public static void countWordFrequency(String text) {\n        String[] words = text.split(\"\\\\s+\");\n        Arrays.sort(words);\n        \n        System.out.println(\"Word frequency:\");\n        \n        int count = 1;\n        for (int i = 1; i < words.length; i++) {\n            if (words[i].equals(words[i - 1])) {\n                count++;\n            } else {\n                System.out.println(words[i - 1] + \": \" + count);\n                count = 1;\n            }\n        }\n        // Print last word\n        if (words.length > 0) {\n            System.out.println(words[words.length - 1] + \": \" + count);\n        }\n    }\n    \n    // Method to find common elements\n    public static int[] findCommonElements(int[] arr1, int[] arr2) {\n        ArrayList<Integer> commonList = new ArrayList<>();\n        \n        for (int num1 : arr1) {\n            for (int num2 : arr2) {\n                if (num1 == num2 && !commonList.contains(num1)) {\n                    commonList.add(num1);\n                }\n            }\n        }\n        \n        // Convert to array\n        int[] result = new int[commonList.size()];\n        for (int i = 0; i < commonList.size(); i++) {\n            result[i] = commonList.get(i);\n        }\n        \n        return result;\n    }\n    \n    // Method to check palindrome\n    public static boolean isPalindrome(String str) {\n        String clean = str.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n        return clean.equals(new StringBuilder(clean).reverse().toString());\n    }\n    \n    // Statistical methods\n    public static int calculateSum(int[] arr) {\n        int sum = 0;\n        for (int num : arr) {\n            sum += num;\n        }\n        return sum;\n    }\n    \n    public static double calculateAverage(int[] arr) {\n        if (arr.length == 0) return 0.0;\n        return (double) calculateSum(arr) / arr.length;\n    }\n    \n    public static int findMin(int[] arr) {\n        if (arr.length == 0) return -1;\n        int min = arr[0];\n        for (int num : arr) {\n            if (num < min) min = num;\n        }\n        return min;\n    }\n    \n    public static int findMax(int[] arr) {\n        if (arr.length == 0) return -1;\n        int max = arr[0];\n        for (int num : arr) {\n            if (num > max) max = num;\n        }\n        return max;\n    }\n}",
                  "real_world_example": "These common operations are used extensively in real applications. E-commerce sites sort products and search inventory, social media apps filter and search user content, data analysis tools process and transform datasets, and file systems organize and search files. Search engines use string operations for query processing, banking apps sort transactions, and gaming applications manage and search player data. Mastering these operations is essential for efficient programming.",
                  "interactive_tasks": [
                    "Write a program that sorts students by grade and displays the top performers",
                    "Create a program that finds the longest word in a text",
                    "Write a program that removes all vowels from a string"
                  ],
                  "quiz": [
                    {
                      "question": "Which method sorts arrays?",
                      "options": ["Arrays.sort()", "Array.sort()", "Collections.sort()", "Sort.array()"],
                        "answer": "Arrays.sort()",
                        "reasoning": "Arrays.sort() is the standard method for sorting arrays."
                        },
                        {
                          "question": "What does binarySearch require?",
                          "options": ["Sorted array", "Unsorted array", "Any array", "Only string arrays"],
                          "answer": "Sorted array",
                          "reasoning": "Binary search only works on sorted arrays for efficiency."
                        },
                        {
                          "question": "How to join strings with delimiter?",
                          "options": ["String.join()", "String.concat()", "String.merge()", "String.combine()"],
                            "answer": "String.join()",
                            "reasoning": "String.join() joins strings with specified delimiter."
                            },
                            {
                              "question": "What does Arrays.fill() do?",
                              "options": ["Fills array with value", "Creates new array", "Sorts array", "Searches array"],
                              "answer": "Fills array with value",
                              "reasoning": "Arrays.fill() sets all elements to specified value."
                            },
                            {
                              "question": "How to check if string is empty?",
                              "options": [".isEmpty()", ".isBlank()", ".empty()", ".null()"],
                                "answer": ".isEmpty()",
                                "reasoning": "isEmpty() checks for zero length; isBlank() also checks for whitespace."
                                },
                                {
                                  "question": "What does Arrays.copyOfRange() do?",
                                  "options": ["Copies specified range", "Copies entire array", "Creates empty array", "Sorts subarray"],
                                  "answer": "Copies specified range",
                                  "reasoning": "copyOfRange() copies elements from start to end-1 index."
                                },
                                {
                                  "question": "How to compare array contents?",
                                  "options": ["Arrays.equals()", "== operator", ".compare()", ".same()"],
                                    "answer": "Arrays.equals()",
                                    "reasoning": "Arrays.equals() compares content; == compares references."
                                    }
                                  ]
                                },
                                {
                                  "title": "Day 20 – Classes and Objects",
                                  "definition": "Classes are blueprints for creating objects, and objects are instances of classes that contain both data (attributes) and behavior (methods) in object-oriented programming.",
                                  "explanation": "Think of a class like a cookie cutter and objects like the actual cookies. The cookie cutter defines the shape (class defines structure), and each cookie made from it is an object with that shape. Classes define what data an object can hold (attributes) and what actions it can perform (methods). Objects are the actual entities you work with in your program. This is the foundation of Object-Oriented Programming (OOP), which helps organize code in a more natural and manageable way.",
                                  "code_example": "// Demonstrating classes and objects\n\n// Define a class (blueprint)\nclass Student {\n    // Attributes (data members)\n    String name;\n    int age;\n    double gpa;\n    String major;\n    \n    // Constructor - special method that initializes objects\n    public Student(String studentName, int studentAge, double studentGPA, String studentMajor) {\n        name = studentName;\n        age = studentAge;\n        gpa = studentGPA;\n        major = studentMajor;\n    }\n    \n    // Default constructor\n    public Student() {\n        name = \"Unknown\";\n        age = 0;\n        gpa = 0.0;\n        major = \"Undeclared\";\n    }\n    \n    // Methods (behaviors)\n    public void displayInfo() {\n        System.out.println(\"Student Information:\");\n        System.out.println(\"  Name: \" + name);\n        System.out.println(\"  Age: \" + age);\n        System.out.println(\"  GPA: \" + gpa);\n        System.out.println(\"  Major: \" + major);\n    }\n    \n    public void study() {\n        System.out.println(name + \" is studying \" + major);\n    }\n    \n    public void takeExam(String subject) {\n        System.out.println(name + \" is taking an exam in \" + subject);\n    }\n    \n    // Method with return value\n    public boolean isHonorStudent() {\n        return gpa >= 3.5;\n    }\n    \n    // Method to update GPA\n    public void updateGPA(double newGPA) {\n        if (newGPA >= 0.0 && newGPA <= 4.0) {\n            gpa = newGPA;\n            System.out.println(name + \"'s GPA updated to: \" + gpa);\n        } else {\n            System.out.println(\"Invalid GPA! Must be between 0.0 and 4.0\");\n        }\n    }\n}\n\n// Another class example\nclass BankAccount {\n    String accountNumber;\n    String accountHolder;\n    double balance;\n    \n    public BankAccount(String accNumber, String holder, double initialBalance) {\n        accountNumber = accNumber;\n        accountHolder = holder;\n        balance = initialBalance;\n    }\n    \n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            System.out.println(\"Deposited: $\" + amount);\n            System.out.println(\"New balance: $\" + balance);\n        } else {\n            System.out.println(\"Deposit amount must be positive!\");\n        }\n    }\n    \n    public void withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            System.out.println(\"Withdrawn: $\" + amount);\n            System.out.println(\"New balance: $\" + balance);\n        } else if (amount > balance) {\n            System.out.println(\"Insufficient funds!\");\n        } else {\n            System.out.println(\"Withdrawal amount must be positive!\");\n        }\n    }\n    \n    public void displayBalance() {\n        System.out.println(accountHolder + \"'s balance: $\" + balance);\n    }\n}\n\n// Main class to demonstrate objects\npublic class ClassesObjectsDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Classes and Objects Demonstration ===\\n\");\n        \n        // Creating objects (instances of Student class)\n        Student student1 = new Student(\"Alice Johnson\", 20, 3.8, \"Computer Science\");\n        Student student2 = new Student(\"Bob Smith\", 22, 3.2, \"Mathematics\");\n        Student student3 = new Student();  // Using default constructor\n        \n        // Using object methods\n        System.out.println(\"=== Student Objects ===\");\n        student1.displayInfo();\n        student1.study();\n        student1.takeExam(\"Data Structures\");\n        System.out.println(\"Is honor student? \" + student1.isHonorStudent());\n        \n        System.out.println(\"\\n---\");\n        student2.displayInfo();\n        student2.study();\n        System.out.println(\"Is honor student? \" + student2.isHonorStudent());\n        \n        System.out.println(\"\\n---\");\n        student3.displayInfo();\n        \n        // Modifying object attributes\n        System.out.println(\"\\n=== Modifying Objects ===\");\n        student3.name = \"Charlie Brown\";\n        student3.age = 19;\n        student3.updateGPA(3.6);\n        student3.major = \"Physics\";\n        student3.displayInfo();\n        \n        // Bank Account example\n        System.out.println(\"\\n=== Bank Account Example ===\");\n        BankAccount account1 = new BankAccount(\"ACC123456\", \"Alice Johnson\", 1000.0);\n        BankAccount account2 = new BankAccount(\"ACC789012\", \"Bob Smith\", 500.0);\n        \n        account1.displayBalance();\n        account1.deposit(250.0);\n        account1.withdraw(100.0);\n        account1.withdraw(2000.0);  // Should fail\n        \n        System.out.println(\"\\n---\");\n        account2.displayBalance();\n        account2.deposit(100.0);\n        \n        // Array of objects\n        System.out.println(\"\\n=== Array of Objects ===\");\n        Student[] students = new Student[3];\n        students[0] = new Student(\"Diana Prince\", 21, 3.9, \"Engineering\");\n        students[1] = new Student(\"Bruce Wayne\", 23, 3.4, \"Business\");\n        students[2] = new Student(\"Clark Kent\", 22, 3.7, \"Journalism\");\n        \n        System.out.println(\"Student Roster:\");\n        for (Student student : students) {\n            student.displayInfo();\n            System.out.println();\n        }\n        \n        // Finding honor students\n        System.out.println(\"Honor Students:\");\n        for (Student student : students) {\n            if (student.isHonorStudent()) {\n                System.out.println(\"  - \" + student.name + \" (GPA: \" + student.gpa + \")\");\n            }\n        }\n        \n        // Object comparison\n        System.out.println(\"\\n=== Object Comparison ===\");\n        Student s1 = new Student(\"John Doe\", 20, 3.5, \"CS\");\n        Student s2 = new Student(\"John Doe\", 20, 3.5, \"CS\");\n        \n        System.out.println(\"s1 == s2: \" + (s1 == s2));  // false (different objects)\n        System.out.println(\"s1.name.equals(s2.name): \" + s1.name.equals(s2.name));  // true\n        \n        // Null objects\n        System.out.println(\"\\n=== Null Objects ===\");\n        Student nullStudent = null;\n        // nullStudent.displayInfo();  // This would cause NullPointerException\n        \n        if (nullStudent != null) {\n            nullStudent.displayInfo();\n        } else {\n            System.out.println(\"Student object is null!\");\n        }\n    }\n}",
                                  "real_world_example": "Classes and objects are used everywhere in real software development. In banking systems, Account classes represent bank accounts. In e-commerce, Product classes represent items for sale. In social media, User classes represent people. In games, Player classes represent game characters. Car manufacturers use Car classes in their inventory systems. Hospital systems use Patient and Doctor classes. Understanding classes and objects is fundamental to building complex, maintainable software systems.",
                                  "interactive_tasks": [
                                    "Create a Book class with title, author, and price attributes, and methods to display and update information",
                                    "Write a Car class with make, model, year, and speed attributes, and methods to accelerate and brake",
                                    "Create a Rectangle class with length and width attributes, and methods to calculate area and perimeter"
                                  ],
                                  "quiz": [
                                    {
                                      "question": "What is a class?",
                                      "options": ["Blueprint for objects", "Instance of object", "Method container", "Variable type"],
                                      "answer": "Blueprint for objects",
                                      "reasoning": "A class defines the structure and behavior that objects will have."
                                    },
                                    {
                                      "question": "What is an object?",
                                      "options": ["Instance of a class", "Type of variable", "Method parameter", "Class definition"],
                                      "answer": "Instance of a class",
                                      "reasoning": "Objects are concrete instances created from class blueprints."
                                    },
                                    {
                                      "question": "What is a constructor?",
                                      "options": ["Special method that initializes objects", "Regular class method", "Variable declaration", "Return type"],
                                      "answer": "Special method that initializes objects",
                                      "reasoning": "Constructors are called when objects are created to initialize them."
                                    },
                                    {
                                      "question": "Can a class have multiple constructors?",
                                      "options": ["Yes, through overloading", "No, only one", "Only two", "Only if no methods"],
                                      "answer": "Yes, through overloading",
                                      "reasoning": "Constructor overloading allows multiple constructors with different parameters."
                                    },
                                    {
                                      "question": "What are attributes?",
                                      "options": ["Data members of class", "Class methods", "Constructors", "Return types"],
                                      "answer": "Data members of class",
                                      "reasoning": "Attributes (fields) store the data/state of objects."
                                    },
                                    {
                                      "question": "What is the 'new' keyword for?",
                                      "options": ["Creating objects", "Defining classes", "Calling methods", "Declaring variables"],
                                      "answer": "Creating objects",
                                      "reasoning": "'new' allocates memory and creates new object instances."
                                    },
                                    {
                                      "question": "What is the default value of object references?",
                                      "options": ["null", "0", "", "undefined"],
                                        "answer": "null",
                                        "reasoning": "Object references are initialized to null by default."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 21 – Constructors",
                                      "definition": "Constructors are special methods in a class that are automatically called when an object is created, used to initialize the object's initial state.",
                                      "explanation": "Think of constructors like a setup crew that prepares a new house before you move in. When you create a new object (like building a new house), the constructor automatically runs to set up the initial state (like installing utilities and furniture). Constructors have the same name as the class and don't have a return type. They ensure that every object starts with valid, initialized values. You can have multiple constructors with different parameters, giving flexibility in how objects are created.",
                                      "code_example": "// Demonstrating constructors\n\nclass Person {\n    // Attributes\n    String name;\n    int age;\n    String email;\n    \n    // Default constructor (no parameters)\n    public Person() {\n        name = \"Unknown\";\n        age = 0;\n        email = \"not provided\";\n        System.out.println(\"Default constructor called - Person created with default values\");\n    }\n    \n    // Parameterized constructor\n    public Person(String personName, int personAge) {\n        name = personName;\n        age = personAge;\n        email = \"not provided\";\n        System.out.println(\"Parameterized constructor (name, age) called\");\n    }\n    \n    // Another parameterized constructor\n    public Person(String personName, int personAge, String personEmail) {\n        name = personName;\n        age = personAge;\n        email = personEmail;\n        System.out.println(\"Parameterized constructor (name, age, email) called\");\n    }\n    \n    // Copy constructor - creates new object from existing object\n    public Person(Person original) {\n        this.name = original.name;\n        this.age = original.age;\n        this.email = original.email;\n        System.out.println(\"Copy constructor called - created copy of \" + original.name);\n    }\n    \n    // Method to display information\n    public void displayInfo() {\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Age: \" + age);\n        System.out.println(\"Email: \" + email);\n        System.out.println();\n    }\n}\n\nclass Car {\n    String make;\n    String model;\n    int year;\n    double price;\n    int mileage;\n    \n    // Constructor with validation\n    public Car(String carMake, String carModel, int carYear, double carPrice) {\n        if (carYear < 1886 || carYear > 2024) {\n            System.out.println(\"Invalid year! Setting to 2024\");\n            year = 2024;\n        } else {\n            year = carYear;\n        }\n        \n        if (carPrice < 0) {\n            System.out.println(\"Price cannot be negative! Setting to 0\");\n            price = 0;\n        } else {\n            price = carPrice;\n        }\n        \n        make = carMake;\n        model = carModel;\n        mileage = 0;  // Default value for new car\n        \n        System.out.println(\"New car created: \" + year + \" \" + make + \" \" + model);\n    }\n    \n    // Constructor chaining - calling another constructor\n    public Car(String carMake, String carModel) {\n        this(carMake, carModel, 2024, 0.0);  // Calls the main constructor\n        System.out.println(\"Chained constructor called\");\n    }\n    \n    // Default constructor with chaining\n    public Car() {\n        this(\"Unknown\", \"Unknown\", 2024, 0.0);\n        System.out.println(\"Default car constructor called\");\n    }\n    \n    public void displayCarInfo() {\n        System.out.println(year + \" \" + make + \" \" + model);\n        System.out.println(\"Price: $\" + price);\n        System.out.println(\"Mileage: \" + mileage + \" miles\");\n        System.out.println();\n    }\n    \n    public void drive(int miles) {\n        if (miles > 0) {\n            mileage += miles;\n            System.out.println(\"Drove \" + miles + \" miles. Total mileage: \" + mileage);\n        }\n    }\n}\n\n// Class with private constructor (Singleton pattern)\nclass DatabaseConnection {\n    private static DatabaseConnection instance;\n    private String connectionString;\n    \n    // Private constructor - cannot be called from outside\n    private DatabaseConnection() {\n        connectionString = \"jdbc:mysql://localhost:3306/mydatabase\";\n        System.out.println(\"Database connection created\");\n    }\n    \n    // Public method to get the single instance\n    public static DatabaseConnection getInstance() {\n        if (instance == null) {\n            instance = new DatabaseConnection();\n        }\n        return instance;\n    }\n    \n    public void connect() {\n        System.out.println(\"Connected to: \" + connectionString);\n    }\n}\n\npublic class ConstructorsDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Constructors Demonstration ===\\n\");\n        \n        // Using different constructors\n        System.out.println(\"=== Person Class Constructors ===\");\n        \n        Person person1 = new Person();  // Default constructor\n        person1.displayInfo();\n        \n        Person person2 = new Person(\"Alice Johnson\", 25);  // 2-parameter constructor\n        person2.displayInfo();\n        \n        Person person3 = new Person(\"Bob Smith\", 30, \"bob.smith@email.com\");  // 3-parameter constructor\n        person3.displayInfo();\n        \n        // Using copy constructor\n        Person person4 = new Person(person3);  // Copy of person3\n        person4.displayInfo();\n        \n        // Modifying copy to show they're separate\n        person4.name = \"Charlie Brown\";\n        System.out.println(\"After modifying copy:\");\n        System.out.println(\"Original: \" + person3.name);\n        System.out.println(\"Copy: \" + person4.name);\n        \n        System.out.println(\"\\n=== Car Class Constructors ===\");\n        \n        // Car with full parameters\n        Car car1 = new Car(\"Toyota\", \"Camry\", 2023, 25000.0);\n        car1.displayCarInfo();\n        \n        // Car with invalid parameters (testing validation)\n        Car car2 = new Car(\"Honda\", \"Civic\", 1800, -10000.0);\n        car2.displayCarInfo();\n        \n        // Car with chained constructor\n        Car car3 = new Car(\"Ford\", \"Mustang\");\n        car3.displayCarInfo();\n        \n        // Default car\n        Car car4 = new Car();\n        car4.displayCarInfo();\n        \n        // Using car methods\n        car1.drive(150);\n        car1.drive(75);\n        car1.displayCarInfo();\n        \n        System.out.println(\"\\n=== Singleton Pattern (Private Constructor) ===\");\n        \n        // Cannot do this: DatabaseConnection db = new DatabaseConnection();\n        // Constructor is private\n        \n        DatabaseConnection db1 = DatabaseConnection.getInstance();\n        db1.connect();\n        \n        DatabaseConnection db2 = DatabaseConnection.getInstance();\n        db2.connect();\n        \n        // Both references point to same object\n        System.out.println(\"db1 == db2: \" + (db1 == db2));\n        \n        System.out.println(\"\\n=== Constructor Best Practices ===\");\n        \n        // Array of objects with different constructors\n        Person[] people = new Person[4];\n        people[0] = new Person();\n        people[1] = new Person(\"John Doe\", 28);\n        people[2] = new Person(\"Jane Smith\", 32, \"jane.smith@company.com\");\n        people[3] = new Person(people[1]);  // Copy\n        \n        System.out.println(\"People array:\");\n        for (Person person : people) {\n            person.displayInfo();\n        }\n        \n        // Constructor with 'this' keyword\n        System.out.println(\"=== Using 'this' Keyword ===\");\n        \n        Person person5 = new Person(\"David Wilson\", 40, \"david@test.com\");\n        person5.displayInfo();\n    }\n}\n\n// Additional example showing 'this' keyword usage\nclass Student {\n    String name;\n    int age;\n    \n    // Using 'this' to distinguish between instance variables and parameters\n    public Student(String name, int age) {\n        this.name = name;  // this.name refers to instance variable\n        this.age = age;    // age refers to parameter\n    }\n    \n    // Method using 'this' to call another constructor\n    public Student(String name) {\n        this(name, 0);  // Calls the main constructor\n    }\n    \n    public void display() {\n        System.out.println(\"Student: \" + this.name + \", Age: \" + this.age);\n    }\n}",
                                      "real_world_example": "Constructors are essential in real-world applications for ensuring objects are properly initialized. Database connections use constructors to establish connections with proper credentials. File handlers use constructors to open files with correct paths and modes. GUI components use constructors to set up their initial appearance and behavior. Game objects use constructors to initialize their starting positions and states. Web requests use constructors to set up headers and parameters. Proper constructor design ensures objects start in valid, predictable states.",
                                      "interactive_tasks": [
                                        "Create a BankAccount class with constructors for different account types (savings, checking)",
                                        "Write a Book class with constructors that validate publication year and positive page count",
                                        "Create a Circle class with constructors that accept radius, diameter, or circumference"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "What is the purpose of a constructor?",
                                          "options": ["Initialize objects", "Destroy objects", "Call methods", "Define classes"],
                                          "answer": "Initialize objects",
                                          "reasoning": "Constructors set up initial state when objects are created."
                                        },
                                        {
                                          "question": "Can constructors have return types?",
                                          "options": ["No", "Yes, void", "Yes, any type", "Only int"],
                                          "answer": "No",
                                          "reasoning": "Constructors cannot have return types, not even void."
                                        },
                                        {
                                          "question": "What is constructor overloading?",
                                          "options": ["Multiple constructors with different parameters", "One constructor doing multiple things", "Constructors with same parameters", "Inheriting constructors"],
                                          "answer": "Multiple constructors with different parameters",
                                          "reasoning": "Overloading means multiple constructors with different parameter lists."
                                        },
                                        {
                                          "question": "What is a default constructor?",
                                          "options": ["No-argument constructor", "Constructor with defaults", "First constructor", "Auto-generated only"],
                                          "answer": "No-argument constructor",
                                          "reasoning": "Default constructor takes no parameters."
                                        },
                                        {
                                          "question": "What is constructor chaining?",
                                          "options": ["One constructor calling another", "Multiple constructors in chain", "Inheritance chain", "Method calling constructor"],
                                          "answer": "One constructor calling another",
                                          "reasoning": "Constructor chaining uses this() to call another constructor."
                                        },
                                        {
                                          "question": "When is constructor called?",
                                          "options": ["When object is created", "When program starts", "When method is called", "When class is loaded"],
                                          "answer": "When object is created",
                                          "reasoning": "Constructors are called automatically when new objects are instantiated."
                                        },
                                        {
                                          "question": "What is a copy constructor?",
                                          "options": ["Creates copy of existing object", "Copies classes", "Duplicates methods", "Copies variables only"],
                                          "answer": "Creates copy of existing object",
                                          "reasoning": "Copy constructor creates new object as copy of existing one."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 22 – Inheritance",
                                      "definition": "Inheritance is an object-oriented programming concept where a new class (child/subclass) derives properties and behaviors from an existing class (parent/superclass), promoting code reuse.",
                                      "explanation": "Think of inheritance like a family tree. Children inherit characteristics from their parents but can also have their own unique features. In programming, inheritance allows you to create a general class (parent) with common attributes and methods, then create more specific classes (children) that inherit those features and add their own specializations. This avoids code duplication and creates a logical hierarchy. The child class can use everything from the parent class and also override or extend functionality as needed.",
                                      "code_example": "// Demonstrating inheritance in Java\n\n// Parent class (Superclass)\nclass Animal {\n    // Protected access - accessible in subclasses\n    protected String name;\n    protected int age;\n    protected String sound;\n    \n    // Constructor\n    public Animal(String name, int age, String sound) {\n        this.name = name;\n        this.age = age;\n        this.sound = sound;\n    }\n    \n    // Default constructor\n    public Animal() {\n        this(\"Unknown Animal\", 0, \"...\");\n    }\n    \n    // Methods\n    public void makeSound() {\n        System.out.println(name + \" says: \" + sound);\n    }\n    \n    public void eat() {\n        System.out.println(name + \" is eating...\");\n    }\n    \n    public void sleep() {\n        System.out.println(name + \" is sleeping...\");\n    }\n    \n    public void displayInfo() {\n        System.out.println(\"Animal: \" + name);\n        System.out.println(\"Age: \" + age + \" years\");\n        System.out.println(\"Sound: \" + sound);\n    }\n}\n\n// Child class 1 (Subclass of Animal)\nclass Dog extends Animal {\n    private String breed;\n    private boolean isTrained;\n    \n    // Constructor\n    public Dog(String name, int age, String breed, boolean isTrained) {\n        // Call parent constructor using super()\n        super(name, age, \"Woof!\");\n        this.breed = breed;\n        this.isTrained = isTrained;\n    }\n    \n    // Default constructor\n    public Dog() {\n        super();  // Call default parent constructor\n        this.breed = \"Unknown\";\n        this.isTrained = false;\n    }\n    \n    // Additional methods specific to Dog\n    public void bark() {\n        System.out.println(name + \" is barking loudly!\");\n    }\n    \n    public void fetch() {\n        System.out.println(name + \" is fetching the ball!\");\n    }\n    \n    // Override parent method\n    @Override\n    public void displayInfo() {\n        super.displayInfo();  // Call parent method\n        System.out.println(\"Breed: \" + breed);\n        System.out.println(\"Trained: \" + (isTrained ? \"Yes\" : \"No\"));\n    }\n    \n    // Getters and setters\n    public String getBreed() {\n        return breed;\n    }\n    \n    public void setBreed(String breed) {\n        this.breed = breed;\n    }\n    \n    public boolean isTrained() {\n        return isTrained;\n    }\n    \n    public void setTrained(boolean trained) {\n        isTrained = trained;\n    }\n}\n\n// Child class 2 (Subclass of Animal)\nclass Cat extends Animal {\n    private String color;\n    private boolean isIndoor;\n    \n    public Cat(String name, int age, String color, boolean isIndoor) {\n        super(name, age, \"Meow!\");\n        this.color = color;\n        this.isIndoor = isIndoor;\n    }\n    \n    // Additional methods specific to Cat\n    public void purr() {\n        System.out.println(name + \" is purring...\");\n    }\n    \n    public void climb() {\n        System.out.println(name + \" is climbing a tree!\");\n    }\n    \n    // Override parent method\n    @Override\n    public void makeSound() {\n        System.out.println(name + \" purrs and says: \" + sound);\n    }\n    \n    @Override\n    public void displayInfo() {\n        super.displayInfo();\n        System.out.println(\"Color: \" + color);\n        System.out.println(\"Indoor cat: \" + (isIndoor ? \"Yes\" : \"No\"));\n    }\n}\n\n// Multi-level inheritance\nclass Puppy extends Dog {\n    private int monthsOld;\n    \n    public Puppy(String name, int months, String breed) {\n        super(name, 0, breed, false);  // Puppies are 0 years old, not trained\n        this.monthsOld = months;\n        this.sound = \"Yip!\";  // Puppies have different sound\n    }\n    \n    @Override\n    public void displayInfo() {\n        System.out.println(\"Puppy: \" + name);\n        System.out.println(\"Age: \" + monthsOld + \" months\");\n        System.out.println(\"Breed: \" + getBreed());\n        System.out.println(\"Sound: \" + sound);\n    }\n    \n    public void play() {\n        System.out.println(name + \" is playing happily!\");\n    }\n}\n\n// Another inheritance example: Vehicles\nclass Vehicle {\n    protected String brand;\n    protected int year;\n    protected double speed;\n    \n    public Vehicle(String brand, int year) {\n        this.brand = brand;\n        this.year = year;\n        this.speed = 0;\n    }\n    \n    public void accelerate(double amount) {\n        speed += amount;\n        System.out.println(brand + \" accelerating to \" + speed + \" mph\");\n    }\n    \n    public void brake(double amount) {\n        speed = Math.max(0, speed - amount);\n        System.out.println(brand + \" slowing down to \" + speed + \" mph\");\n    }\n    \n    public void displayInfo() {\n        System.out.println(year + \" \" + brand);\n        System.out.println(\"Current speed: \" + speed + \" mph\");\n    }\n}\n\nclass Car extends Vehicle {\n    private int doors;\n    private String fuelType;\n    \n    public Car(String brand, int year, int doors, String fuelType) {\n        super(brand, year);\n        this.doors = doors;\n        this.fuelType = fuelType;\n    }\n    \n    public void honk() {\n        System.out.println(brand + \" goes Beep Beep!\");\n    }\n    \n    @Override\n    public void displayInfo() {\n        super.displayInfo();\n        System.out.println(\"Doors: \" + doors);\n        System.out.println(\"Fuel: \" + fuelType);\n    }\n}\n\nclass Bicycle extends Vehicle {\n    private int gears;\n    \n    public Bicycle(String brand, int year, int gears) {\n        super(brand, year);\n        this.gears = gears;\n    }\n    \n    public void ringBell() {\n        System.out.println(brand + \" bicycle rings its bell!\");\n    }\n    \n    @Override\n    public void accelerate(double amount) {\n        // Bicycles accelerate slower\n        speed += amount * 0.5;\n        System.out.println(brand + \" bicycle pedaling to \" + speed + \" mph\");\n    }\n    \n    @Override\n    public void displayInfo() {\n        super.displayInfo();\n        System.out.println(\"Gears: \" + gears);\n    }\n}\n\npublic class InheritanceDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Inheritance Demonstration ===\\n\");\n        \n        System.out.println(\"=== Animal Inheritance Hierarchy ===\");\n        \n        // Create parent class object\n        Animal genericAnimal = new Animal(\"Generic\", 5, \"...\");\n        genericAnimal.displayInfo();\n        genericAnimal.makeSound();\n        \n        System.out.println(\"\\n--- Dog (Child Class) ---\");\n        \n        // Create child class objects\n        Dog myDog = new Dog(\"Buddy\", 3, \"Golden Retriever\", true);\n        myDog.displayInfo();  // Inherited method\n        myDog.makeSound();    // Inherited method\n        myDog.bark();         // Dog-specific method\n        myDog.fetch();        // Dog-specific method\n        myDog.eat();          // Inherited from Animal\n        \n        System.out.println(\"\\n--- Cat (Child Class) ---\");\n        \n        Cat myCat = new Cat(\"Whiskers\", 2, \"Gray\", true);\n        myCat.displayInfo();\n        myCat.makeSound();    // Overridden method\n        myCat.purr();         // Cat-specific method\n        myCat.climb();        // Cat-specific method\n        \n        System.out.println(\"\\n--- Multi-level Inheritance (Puppy) ---\");\n        \n        Puppy myPuppy = new Puppy(\"Max\", 6, \"Labrador\");\n        myPuppy.displayInfo();\n        myPuppy.makeSound();  // Inherited from Animal\n        myPuppy.bark();       // Inherited from Dog\n        myPuppy.play();       // Puppy-specific method\n        \n        System.out.println(\"\\n=== Vehicle Inheritance Hierarchy ===\");\n        \n        Car myCar = new Car(\"Toyota\", 2023, 4, \"Gasoline\");\n        myCar.displayInfo();\n        myCar.accelerate(30);\n        myCar.honk();\n        myCar.brake(10);\n        \n        System.out.println(\"\\n---\");\n        \n        Bicycle myBike = new Bicycle(\"Trek\", 2022, 21);\n        myBike.displayInfo();\n        myBike.accelerate(10);  // Overridden method\n        myBike.ringBell();\n        \n        System.out.println(\"\\n=== Polymorphism with Inheritance ===\");\n        \n        // Array of parent type holding different child objects\n        Animal[] animals = new Animal[3];\n        animals[0] = new Dog(\"Rex\", 4, \"German Shepherd\", true);\n        animals[1] = new Cat(\"Mittens\", 1, \"White\", false);\n        animals[2] = new Animal(\"Bird\", 2, \"Chirp!\");\n        \n        System.out.println(\"Animal sounds:\");\n        for (Animal animal : animals) {\n            animal.makeSound();  // Polymorphism - each calls its own version\n        }\n        \n        System.out.println(\"\\n=== instanceof Operator ===\");\n        \n        // Check object types\n        for (Animal animal : animals) {\n            System.out.print(animal.name + \" is: \");\n            if (animal instanceof Dog) {\n                System.out.println(\"a Dog\");\n            } else if (animal instanceof Cat) {\n                System.out.println(\"a Cat\");\n            } else {\n                System.out.println(\"an Animal\");\n            }\n        }\n        \n        System.out.println(\"\\n=== Method Overriding Demonstration ===\");\n        \n        // Show how overridden methods work\n        Animal dogAsAnimal = new Dog(\"Spot\", 2, \"Beagle\", false);\n        dogAsAnimal.makeSound();  // Calls Dog's overridden version\n        dogAsAnimal.displayInfo(); // Calls Dog's overridden version\n    }\n}",
                                      "real_world_example": "Inheritance is widely used in real software development. GUI frameworks use inheritance where Button, Label, and TextField classes inherit from a common Component class. Banking systems have Account as parent class with SavingsAccount and CheckingAccount as children. E-commerce systems have Product as parent with Book, Electronics, and Clothing as children. Game development uses inheritance for game entities where Player, Enemy, and Item inherit from GameObject. This promotes code reuse and logical organization.",
                                      "interactive_tasks": [
                                        "Create a Shape class with Circle and Rectangle subclasses that override area calculation",
                                        "Write an Employee class with Manager and Developer subclasses adding specific attributes",
                                        "Create a BankAccount hierarchy with SavingsAccount and CheckingAccount subclasses"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "What is inheritance?",
                                          "options": ["Child class gets parent's features", "Parent gets child's features", "Classes share methods", "Objects copy each other"],
                                          "answer": "Child class gets parent's features",
                                          "reasoning": "Inheritance allows subclasses to inherit attributes and methods from superclass."
                                        },
                                        {
                                          "question": "Which keyword is used for inheritance?",
                                          "options": ["extends", "inherits", "super", "parent"],
                                          "answer": "extends",
                                          "reasoning": "The 'extends' keyword is used to create inheritance relationships."
                                        },
                                        {
                                          "question": "What is method overriding?",
                                          "options": ["Child redefines parent method", "Parent redefines child method", "Creating new method", "Deleting method"],
                                          "answer": "Child redefines parent method",
                                          "reasoning": "Overriding allows subclasses to provide specific implementation of inherited methods."
                                        },
                                        {
                                          "question": "What does super() do?",
                                          "options": ["Calls parent constructor", "Calls child constructor", "Calls same class method", "Calls super class"],
                                          "answer": "Calls parent constructor",
                                          "reasoning": "super() calls the parent class constructor from child class."
                                        },
                                        {
                                          "question": "Can Java have multiple inheritance?",
                                          "options": ["No, only single inheritance", "Yes, multiple", "Only for interfaces", "Only for abstract classes"],
                                          "answer": "No, only single inheritance",
                                          "reasoning": "Java supports single inheritance for classes (one parent only)."
                                        },
                                        {
                                          "question": "What is protected access?",
                                          "options": ["Accessible in package and subclasses", "Accessible everywhere", "Only in same class", "Only in package"],
                                          "answer": "Accessible in package and subclasses",
                                          "reasoning": "Protected members are accessible within package and to subclasses."
                                        },
                                        {
                                          "question": "What is polymorphism?",
                                          "options": ["Same interface, different implementations", "Same implementation", "Different interfaces", "Method overloading"],
                                          "answer": "Same interface, different implementations",
                                          "reasoning": "Polymorphism allows objects of different types to be treated as same type."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 23 – Polymorphism",
                                      "definition": "Polymorphism means 'many forms' and allows objects of different classes to be treated as objects of a common superclass, enabling flexible and extensible code.",
                                      "explanation": "Think of polymorphism like a universal remote control that can operate different devices (TV, DVD, stereo). Each device responds differently to the same 'power' button, but you don't need separate remotes. In programming, polymorphism lets you write code that works with general types (like Animal) but automatically uses the specific behavior of actual objects (like Dog or Cat). This makes your code more flexible - you can add new types without changing existing code that uses the general interface.",
                                      "code_example": "// Demonstrating polymorphism in Java\n\n// Base class\nclass Shape {\n    protected String color;\n    \n    public Shape(String color) {\n        this.color = color;\n    }\n    \n    // This method will be overridden by subclasses\n    public double calculateArea() {\n        System.out.println(\"Calculating area for generic shape\");\n        return 0.0;\n    }\n    \n    public void displayInfo() {\n        System.out.println(\"Shape color: \" + color);\n    }\n    \n    // A method that won't be overridden\n    public final void setColor(String color) {\n        this.color = color;\n        System.out.println(\"Shape color changed to: \" + color);\n    }\n}\n\n// Subclass 1\nclass Circle extends Shape {\n    private double radius;\n    \n    public Circle(String color, double radius) {\n        super(color);\n        this.radius = radius;\n    }\n    \n    // Override calculateArea method\n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n    \n    @Override\n    public void displayInfo() {\n        System.out.println(\"Circle - Color: \" + color + \", Radius: \" + radius);\n        System.out.println(\"Area: \" + calculateArea());\n    }\n    \n    // Circle-specific method\n    public double calculateCircumference() {\n        return 2 * Math.PI * radius;\n    }\n}\n\n// Subclass 2\nclass Rectangle extends Shape {\n    private double length;\n    private double width;\n    \n    public Rectangle(String color, double length, double width) {\n        super(color);\n        this.length = length;\n        this.width = width;\n    }\n    \n    // Override calculateArea method\n    @Override\n    public double calculateArea() {\n        return length * width;\n    }\n    \n    @Override\n    public void displayInfo() {\n        System.out.println(\"Rectangle - Color: \" + color + \", Length: \" + length + \", Width: \" + width);\n        System.out.println(\"Area: \" + calculateArea());\n    }\n    \n    // Rectangle-specific method\n    public double calculatePerimeter() {\n        return 2 * (length + width);\n    }\n}\n\n// Subclass 3\nclass Triangle extends Shape {\n    private double base;\n    private double height;\n    \n    public Triangle(String color, double base, double height) {\n        super(color);\n        this.base = base;\n        this.height = height;\n    }\n    \n    // Override calculateArea method\n    @Override\n    public double calculateArea() {\n        return 0.5 * base * height;\n    }\n    \n    @Override\n    public void displayInfo() {\n        System.out.println(\"Triangle - Color: \" + color + \", Base: \" + base + \", Height: \" + height);\n        System.out.println(\"Area: \" + calculateArea());\n    }\n}\n\n// Interface for polymorphism\ninterface Payment {\n    void processPayment(double amount);\n    boolean validatePayment();\n    default void receipt() {\n        System.out.println(\"Payment processed successfully!\");\n    }\n}\n\n// Classes implementing Payment interface\nclass CreditCardPayment implements Payment {\n    private String cardNumber;\n    private String cardHolder;\n    \n    public CreditCardPayment(String cardNumber, String cardHolder) {\n        this.cardNumber = cardNumber;\n        this.cardHolder = cardHolder;\n    }\n    \n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing credit card payment of $\" + amount);\n        System.out.println(\"Card: \" + cardNumber + \" (\" + cardHolder + \")\");\n    }\n    \n    @Override\n    public boolean validatePayment() {\n        System.out.println(\"Validating credit card...\");\n        return cardNumber != null && cardNumber.length() == 16;\n    }\n}\n\nclass PayPalPayment implements Payment {\n    private String email;\n    \n    public PayPalPayment(String email) {\n        this.email = email;\n    }\n    \n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing PayPal payment of $\" + amount);\n        System.out.println(\"Email: \" + email);\n    }\n    \n    @Override\n    public boolean validatePayment() {\n        System.out.println(\"Validating PayPal account...\");\n        return email != null && email.contains(\"@\");\n    }\n    \n    @Override\n    public void receipt() {\n        System.out.println(\"PayPal payment completed! Check your email for receipt.\");\n    }\n}\n\nclass BankTransferPayment implements Payment {\n    private String accountNumber;\n    private String bankName;\n    \n    public BankTransferPayment(String accountNumber, String bankName) {\n        this.accountNumber = accountNumber;\n        this.bankName = bankName;\n    }\n    \n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing bank transfer of $\" + amount);\n        System.out.println(\"Bank: \" + bankName + \", Account: \" + accountNumber);\n    }\n    \n    @Override\n    public boolean validatePayment() {\n        System.out.println(\"Validating bank account...\");\n        return accountNumber != null && !accountNumber.isEmpty();\n    }\n}\n\n// Abstract class example\nabstract class Animal {\n    protected String name;\n    \n    public Animal(String name) {\n        this.name = name;\n    }\n    \n    // Abstract method - must be implemented by subclasses\n    public abstract void makeSound();\n    \n    // Concrete method\n    public void sleep() {\n        System.out.println(name + \" is sleeping...\");\n    }\n    \n    // Another concrete method\n    public void eat() {\n        System.out.println(name + \" is eating...\");\n    }\n}\n\nclass Dog extends Animal {\n    public Dog(String name) {\n        super(name);\n    }\n    \n    @Override\n    public void makeSound() {\n        System.out.println(name + \" says: Woof! Woof!\");\n    }\n    \n    // Dog-specific method\n    public void fetch() {\n        System.out.println(name + \" is fetching the ball!\");\n    }\n}\n\nclass Cat extends Animal {\n    public Cat(String name) {\n        super(name);\n    }\n    \n    @Override\n    public void makeSound() {\n        System.out.println(name + \" says: Meow!\");\n    }\n    \n    // Cat-specific method\n    public void climb() {\n        System.out.println(name + \" is climbing a tree!\");\n    }\n}\n\nclass Cow extends Animal {\n    public Cow(String name) {\n        super(name);\n    }\n    \n    @Override\n    public void makeSound() {\n        System.out.println(name + \" says: Moo!\");\n    }\n    \n    // Cow-specific method\n    public void produceMilk() {\n        System.out.println(name + \" is producing milk!\");\n    }\n}\n\npublic class PolymorphismDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Polymorphism Demonstration ===\\n\");\n        \n        System.out.println(\"=== Shape Polymorphism ===\");\n        \n        // Creating different shapes but storing as Shape type\n        Shape[] shapes = new Shape[3];\n        shapes[0] = new Circle(\"Red\", 5.0);\n        shapes[1] = new Rectangle(\"Blue\", 4.0, 6.0);\n        shapes[2] = new Triangle(\"Green\", 3.0, 4.0);\n        \n        // Polymorphic behavior - same method call, different results\n        System.out.println(\"Calculating areas polymorphically:\");\n        for (Shape shape : shapes) {\n            shape.displayInfo();  // Each calls its own version\n            System.out.println();\n        }\n        \n        // Calculate total area\n        double totalArea = 0;\n        for (Shape shape : shapes) {\n            totalArea += shape.calculateArea();\n        }\n        System.out.println(\"Total area of all shapes: \" + totalArea);\n        \n        System.out.println(\"\\n=== Accessing Subclass-specific Methods ===\");\n        \n        // To access subclass methods, we need to check type and cast\n        for (Shape shape : shapes) {\n            if (shape instanceof Circle) {\n                Circle circle = (Circle) shape;  // Downcasting\n                System.out.println(\"Circle circumference: \" + circle.calculateCircumference());\n            } else if (shape instanceof Rectangle) {\n                Rectangle rectangle = (Rectangle) shape;\n                System.out.println(\"Rectangle perimeter: \" + rectangle.calculatePerimeter());\n            }\n        }\n        \n        System.out.println(\"\\n=== Interface Polymorphism ===\");\n        \n        // Different payment methods treated as Payment interface\n        Payment[] payments = new Payment[3];\n        payments[0] = new CreditCardPayment(\"1234567812345678\", \"John Doe\");\n        payments[1] = new PayPalPayment(\"user@example.com\");\n        payments[2] = new BankTransferPayment(\"ACC789012\", \"City Bank\");\n        \n        double amount = 100.0;\n        \n        System.out.println(\"Processing payments polymorphically:\");\n        for (Payment payment : payments) {\n            if (payment.validatePayment()) {\n                payment.processPayment(amount);\n                payment.receipt();\n            } else {\n                System.out.println(\"Payment validation failed!\");\n            }\n            System.out.println();\n        }\n        \n        System.out.println(\"=== Abstract Class Polymorphism ===\");\n        \n        // Animals treated as Animal type but behave differently\n        Animal[] animals = new Animal[3];\n        animals[0] = new Dog(\"Buddy\");\n        animals[1] = new Cat(\"Whiskers\");\n        animals[2] = new Cow(\"Bessie\");\n        \n        System.out.println(\"Animal sounds (polymorphism):\");\n        for (Animal animal : animals) {\n            animal.makeSound();  // Each calls its own implementation\n        }\n        \n        System.out.println(\"\\nCommon behavior:\");\n        for (Animal animal : animals) {\n            animal.eat();  // Inherited concrete method\n        }\n        \n        System.out.println(\"\\n=== Runtime Polymorphism (Dynamic Binding) ===\");\n        \n        // The actual method called is determined at runtime\n        Shape shape;\n        \n        // At compile time, shape is Shape type\n        // At runtime, it can be any subclass\n        shape = new Circle(\"Yellow\", 7.0);\n        shape.displayInfo();  // Calls Circle's displayInfo\n        \n        shape = new Rectangle(\"Purple\", 5.0, 3.0);\n        shape.displayInfo();  // Calls Rectangle's displayInfo\n        \n        System.out.println(\"\\n=== Method Overloading vs Overriding ===\");\n        \n        // Method overloading (compile-time polymorphism)\n        Calculator calc = new Calculator();\n        System.out.println(\"Add integers: \" + calc.add(5, 3));\n        System.out.println(\"Add doubles: \" + calc.add(5.5, 3.2));\n        System.out.println(\"Add three numbers: \" + calc.add(1, 2, 3));\n    }\n}\n\n// Class demonstrating method overloading (compile-time polymorphism)\nclass Calculator {\n    // Method overloading - same name, different parameters\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public double add(double a, double b) {\n        return a + b;\n    }\n    \n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n    \n    public String add(String a, String b) {\n        return a + b;\n    }\n}",
                                      "real_world_example": "Polymorphism is fundamental in real-world applications. GUI frameworks use polymorphism where different components (buttons, labels, text fields) all respond to common methods like draw() or handleClick(). Payment systems process different payment methods (credit card, PayPal, bank transfer) through a common interface. Database systems use polymorphism to handle different database types through common JDBC interfaces. Game engines treat different game objects (players, enemies, items) polymorphically for rendering and collision detection. This makes systems extensible and maintainable.",
                                      "interactive_tasks": [
                                        "Create a MediaPlayer system with AudioPlayer and VideoPlayer classes that implement a common Media interface",
                                        "Write a Notification system with EmailNotification, SMSNotification, and PushNotification classes",
                                        "Create a Drawing application with different Tool classes (Pen, Brush, Eraser) that implement a Tool interface"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "What does polymorphism mean?",
                                          "options": ["Many forms", "One form", "Same shape", "Different names"],
                                          "answer": "Many forms",
                                          "reasoning": "Polymorphism allows objects of different types to be treated as same type."
                                        },
                                        {
                                          "question": "What is runtime polymorphism?",
                                          "options": ["Method overriding", "Method overloading", "Constructor overloading", "Variable hiding"],
                                          "answer": "Method overriding",
                                          "reasoning": "Runtime polymorphism is achieved through method overriding."
                                        },
                                        {
                                          "question": "What is compile-time polymorphism?",
                                          "options": ["Method overloading", "Method overriding", "Inheritance", "Interfaces"],
                                          "answer": "Method overloading",
                                          "reasoning": "Method overloading is resolved at compile time."
                                        },
                                        {
                                          "question": "What is required for method overriding?",
                                          "options": ["Inheritance and same signature", "Same class", "Different names", "Static methods"],
                                          "answer": "Inheritance and same signature",
                                          "reasoning": "Overriding requires inheritance and same method signature."
                                        },
                                        {
                                          "question": "Can we override static methods?",
                                          "options": ["No", "Yes", "Only in same package", "Only with same name"],
                                          "answer": "No",
                                          "reasoning": "Static methods cannot be overridden, only hidden."
                                        },
                                        {
                                          "question": "What is the @Override annotation for?",
                                          "options": ["Indicates overriding", "Improves performance", "Makes method final", "Hides method"],
                                          "answer": "Indicates overriding",
                                          "reasoning": "@Override annotation indicates method is intended to override parent method."
                                        },
                                        {
                                          "question": "What is dynamic method dispatch?",
                                          "options": ["Runtime method binding", "Compile-time binding", "Static binding", "Early binding"],
                                          "answer": "Runtime method binding",
                                          "reasoning": "Dynamic method dispatch determines method to call at runtime based on object type."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 24 – Encapsulation",
                                      "definition": "Encapsulation is the object-oriented programming concept of bundling data (attributes) and methods (behaviors) that operate on that data within a single unit (class), while restricting direct access to some components.",
                                      "explanation": "Think of encapsulation like a capsule that protects medicine inside. The outside world can use the capsule without knowing what's inside or how it works. In programming, encapsulation means keeping the internal details of an object hidden and providing controlled access through public methods. This is achieved using access modifiers (private, protected, public) and getter/setter methods. Encapsulation protects data from accidental corruption and makes code more maintainable by hiding implementation details.",
                                      "code_example": "// Demonstrating encapsulation in Java\n\n// Fully encapsulated class\nclass BankAccount {\n    // Private data members - cannot be accessed directly from outside\n    private String accountNumber;\n    private String accountHolder;\n    private double balance;\n    private String accountType;\n    private boolean isActive;\n    \n    // Constructor\n    public BankAccount(String accountNumber, String accountHolder, double initialBalance, String accountType) {\n        this.accountNumber = accountNumber;\n        this.accountHolder = accountHolder;\n        this.balance = Math.max(0, initialBalance); // Ensure non-negative balance\n        this.accountType = accountType;\n        this.isActive = true;\n    }\n    \n    // Public getter methods - provide read access\n    public String getAccountNumber() {\n        return accountNumber;\n    }\n    \n    public String getAccountHolder() {\n        return accountHolder;\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n    \n    public String getAccountType() {\n        return accountType;\n    }\n    \n    public boolean isActive() {\n        return isActive;\n    }\n    \n    // Public setter methods - provide controlled write access\n    public void setAccountHolder(String accountHolder) {\n        if (accountHolder != null && !accountHolder.trim().isEmpty()) {\n            this.accountHolder = accountHolder;\n            System.out.println(\"Account holder name updated to: \" + accountHolder);\n        } else {\n            System.out.println(\"Invalid account holder name!\");\n        }\n    }\n    \n    public void setAccountType(String accountType) {\n        if (accountType.equals(\"Savings\") || accountType.equals(\"Checking\") || accountType.equals(\"Business\")) {\n            this.accountType = accountType;\n            System.out.println(\"Account type updated to: \" + accountType);\n        } else {\n            System.out.println(\"Invalid account type! Must be Savings, Checking, or Business\");\n        }\n    }\n    \n    // No setter for accountNumber - cannot be changed after creation\n    // No setter for balance - can only be modified through deposit/withdraw methods\n    \n    // Business methods that manipulate the private data\n    public void deposit(double amount) {\n        if (!isActive) {\n            System.out.println(\"Cannot deposit: Account is inactive!\");\n            return;\n        }\n        \n        if (amount > 0) {\n            balance += amount;\n            System.out.println(\"Deposited: $\" + amount);\n            System.out.println(\"New balance: $\" + balance);\n        } else {\n            System.out.println(\"Deposit amount must be positive!\");\n        }\n    }\n    \n    public void withdraw(double amount) {\n        if (!isActive) {\n            System.out.println(\"Cannot withdraw: Account is inactive!\");\n            return;\n        }\n        \n        if (amount > 0) {\n            if (amount <= balance) {\n                balance -= amount;\n                System.out.println(\"Withdrawn: $\" + amount);\n                System.out.println(\"New balance: $\" + balance);\n            } else {\n                System.out.println(\"Insufficient funds! Current balance: $\" + balance);\n            }\n        } else {\n            System.out.println(\"Withdrawal amount must be positive!\");\n        }\n    }\n    \n    public void transfer(BankAccount recipient, double amount) {\n        if (!isActive || !recipient.isActive) {\n            System.out.println(\"Transfer failed: One or both accounts are inactive!\");\n            return;\n        }\n        \n        if (amount > 0 && amount <= balance) {\n            this.balance -= amount;\n            recipient.balance += amount;\n            System.out.println(\"Transferred: $\" + amount + \" to \" + recipient.getAccountHolder());\n            System.out.println(\"Your new balance: $\" + balance);\n        } else if (amount > balance) {\n            System.out.println(\"Transfer failed: Insufficient funds!\");\n        } else {\n            System.out.println(\"Transfer amount must be positive!\");\n        }\n    }\n    \n    // Administrative methods\n    public void activateAccount() {\n        isActive = true;\n        System.out.println(\"Account activated successfully!\");\n    }\n    \n    public void deactivateAccount() {\n        isActive = false;\n        System.out.println(\"Account deactivated successfully!\");\n    }\n    \n    // Display account information (controlled access)\n    public void displayAccountInfo() {\n        System.out.println(\"=== Account Information ===\");\n        System.out.println(\"Account Number: \" + accountNumber);\n        System.out.println(\"Account Holder: \" + accountHolder);\n        System.out.println(\"Account Type: \" + accountType);\n        System.out.println(\"Balance: $\" + balance);\n        System.out.println(\"Status: \" + (isActive ? \"Active\" : \"Inactive\"));\n    }\n    \n    // Private helper method - internal use only\n    private boolean isValidTransaction(double amount) {\n        return amount > 0 && isActive;\n    }\n}\n\n// Another encapsulated class example\nclass Student {\n    private String studentId;\n    private String name;\n    private int age;\n    private double gpa;\n    private String[] courses;\n    \n    public Student(String studentId, String name, int age) {\n        this.studentId = studentId;\n        this.name = name;\n        this.age = Math.max(0, age); // Age cannot be negative\n        this.gpa = 0.0;\n        this.courses = new String[0];\n    }\n    \n    // Getters\n    public String getStudentId() {\n        return studentId;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    public double getGpa() {\n        return gpa;\n    }\n    \n    public String[] getCourses() {\n        // Return a copy to protect the original array\n        return courses.clone();\n    }\n    \n    // Setters with validation\n    public void setName(String name) {\n        if (name != null && name.matches(\"[a-zA-Z\\\\s]+\")) {\n            this.name = name;\n        } else {\n            System.out.println(\"Invalid name! Only letters and spaces allowed.\");\n        }\n    }\n    \n    public void setAge(int age) {\n        if (age >= 0 && age <= 120) {\n            this.age = age;\n        } else {\n            System.out.println(\"Invalid age! Must be between 0 and 120.\");\n        }\n    }\n    \n    // No setter for studentId - immutable\n    // No direct setter for GPA - calculated from grades\n    \n    // Business methods\n    public void addCourse(String course) {\n        if (course == null || course.trim().isEmpty()) {\n            System.out.println(\"Invalid course name!\");\n            return;\n        }\n        \n        // Check if course already exists\n        for (String existingCourse : courses) {\n            if (existingCourse.equals(course)) {\n                System.out.println(\"Course '\" + course + \"' already exists!\");\n                return;\n            }\n        }\n        \n        // Add new course\n        String[] newCourses = new String[courses.length + 1];\n        System.arraycopy(courses, 0, newCourses, 0, courses.length);\n        newCourses[courses.length] = course;\n        courses = newCourses;\n        \n        System.out.println(\"Course '\" + course + \"' added successfully!\");\n    }\n    \n    public void removeCourse(String course) {\n        if (course == null) {\n            System.out.println(\"Invalid course name!\");\n            return;\n        }\n        \n        int index = -1;\n        for (int i = 0; i < courses.length; i++) {\n            if (courses[i].equals(course)) {\n                index = i;\n                break;\n            }\n        }\n        \n        if (index == -1) {\n            System.out.println(\"Course '\" + course + \"' not found!\");\n            return;\n        }\n        \n        // Remove course\n        String[] newCourses = new String[courses.length - 1];\n        for (int i = 0, j = 0; i < courses.length; i++) {\n            if (i != index) {\n                newCourses[j++] = courses[i];\n            }\n        }\n        courses = newCourses;\n        \n        System.out.println(\"Course '\" + course + \"' removed successfully!\");\n    }\n    \n    public void updateGPA(double newGPA) {\n        if (newGPA >= 0.0 && newGPA <= 4.0) {\n            this.gpa = newGPA;\n            System.out.println(name + \"'s GPA updated to: \" + gpa);\n        } else {\n            System.out.println(\"Invalid GPA! Must be between 0.0 and 4.0\");\n        }\n    }\n    \n    public void displayStudentInfo() {\n        System.out.println(\"=== Student Information ===\");\n        System.out.println(\"Student ID: \" + studentId);\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Age: \" + age);\n        System.out.println(\"GPA: \" + gpa);\n        System.out.println(\"Courses: \" + String.join(\", \", courses));\n    }\n    \n    // Private helper method\n    private boolean isValidCourse(String course) {\n        return course != null && !course.trim().isEmpty();\n    }\n}\n\n// Class demonstrating package-level encapsulation\nclass Employee {\n    private String employeeId;\n    private String name;\n    private double salary;\n    \n    // Package-private constructor\n    Employee(String employeeId, String name, double salary) {\n        this.employeeId = employeeId;\n        this.name = name;\n        this.salary = salary;\n    }\n    \n    // Public getters\n    public String getEmployeeId() {\n        return employeeId;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    // Package-private getter\n    double getSalary() {\n        return salary;\n    }\n    \n    // Package-private setter\n    void setSalary(double salary) {\n        if (salary >= 0) {\n            this.salary = salary;\n        }\n    }\n    \n    public void displayInfo() {\n        System.out.println(\"Employee: \" + name + \" (ID: \" + employeeId + \")\");\n    }\n}\n\npublic class EncapsulationDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Encapsulation Demonstration ===\\n\");\n        \n        System.out.println(\"=== Bank Account Example ===\");\n        \n        // Create bank account\n        BankAccount account1 = new BankAccount(\"ACC123456\", \"Alice Johnson\", 1000.0, \"Savings\");\n        BankAccount account2 = new BankAccount(\"ACC789012\", \"Bob Smith\", 500.0, \"Checking\");\n        \n        // Display account information using public methods\n        account1.displayAccountInfo();\n        \n        // Try to access private fields directly (this would cause compilation error)\n        // System.out.println(account1.balance);  // Error: balance has private access\n        // account1.balance = 5000;  // Error: balance has private access\n        \n        // Use public methods to interact with the object\n        System.out.println(\"\\n--- Performing Transactions ---\");\n        account1.deposit(250.0);\n        account1.withdraw(100.0);\n        account1.withdraw(2000.0);  // Should fail - insufficient funds\n        \n        // Transfer between accounts\n        System.out.println(\"\\n--- Transfer ---\");\n        account1.transfer(account2, 200.0);\n        \n        // Update account information using setters\n        System.out.println(\"\\n--- Updating Account Information ---\");\n        account1.setAccountHolder(\"Alice Smith\");  // Valid change\n        account1.setAccountType(\"Business\");       // Valid change\n        account1.setAccountType(\"InvalidType\");    // Invalid - should be rejected\n        \n        // Display updated information\n        System.out.println(\"\\n--- Updated Account Information ---\");\n        account1.displayAccountInfo();\n        account2.displayAccountInfo();\n        \n        // Account activation/deactivation\n        System.out.println(\"\\n--- Account Management ---\");\n        account1.deactivateAccount();\n        account1.deposit(100.0);  // Should fail - account inactive\n        account1.activateAccount();\n        account1.deposit(100.0);  // Should work now\n        \n        System.out.println(\"\\n=== Student Example ===\");\n        \n        Student student1 = new Student(\"S1001\", \"John Doe\", 20);\n        \n        // Use public methods to interact with student\n        student1.displayStudentInfo();\n        \n        System.out.println(\"\\n--- Managing Courses ---\");\n        student1.addCourse(\"Mathematics\");\n        student1.addCourse(\"Computer Science\");\n        student1.addCourse(\"Physics\");\n        student1.addCourse(\"Mathematics\");  // Should fail - duplicate\n        \n        student1.displayStudentInfo();\n        \n        student1.removeCourse(\"Physics\");\n        student1.removeCourse(\"Chemistry\");  // Should fail - not found\n        \n        student1.displayStudentInfo();\n        \n        System.out.println(\"\\n--- Updating Student Information ---\");\n        student1.setName(\"John Smith\");     // Valid\n        student1.setName(\"John123\");        // Invalid - should be rejected\n        student1.setAge(21);                // Valid\n        student1.setAge(150);               // Invalid - should be rejected\n        student1.updateGPA(3.75);           // Valid\n        student1.updateGPA(5.0);            // Invalid - should be rejected\n        \n        student1.displayStudentInfo();\n        \n        System.out.println(\"\\n=== Benefits of Encapsulation ===\");\n        \n        // 1. Data protection\n        System.out.println(\"1. Data Protection:\");\n        System.out.println(\"   - Private fields prevent direct modification\");\n        System.out.println(\"   - Setters provide validation\");\n        \n        // 2. Controlled access\n        System.out.println(\"2. Controlled Access:\");\n        System.out.println(\"   - Getters provide read access\");\n        System.out.println(\"   - Business methods control how data is modified\");\n        \n        // 3. Flexibility to change implementation\n        System.out.println(\"3. Implementation Flexibility:\");\n        System.out.println(\"   - Internal implementation can change without affecting users\");\n        System.out.println(\"   - Example: courses array could be changed to ArrayList without affecting callers\");\n        \n        // 4. Maintainability\n        System.out.println(\"4. Maintainability:\");\n        System.out.println(\"   - Validation logic is centralized\");\n        System.out.println(\"   - Easy to add new features or constraints\");\n    }\n}",
                                      "real_world_example": "Encapsulation is used everywhere in professional software. Banking systems encapsulate account details and provide transactions through controlled methods. E-commerce systems encapsulate product inventory and pricing logic. User authentication systems encapsulate password handling. Database connections encapsulate connection details. API clients encapsulate network communication. Game engines encapsulate rendering details. By hiding implementation details, encapsulation makes systems more secure, maintainable, and flexible to change.",
                                      "interactive_tasks": [
                                        "Create a Product class with encapsulated price that cannot be negative and has validation",
                                        "Write a User class with encapsulated password that is never exposed and can only be changed with verification",
                                        "Create a Temperature class that encapsulates Celsius value but provides getters for both Celsius and Fahrenheit"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "What is encapsulation?",
                                          "options": ["Bundling data and methods, restricting access", "Inheriting from parent class", "Creating multiple methods", "Hiding classes"],
                                          "answer": "Bundling data and methods, restricting access",
                                          "reasoning": "Encapsulation bundles data and methods together while controlling access to internal details."
                                        },
                                        {
                                          "question": "Which access modifier provides most restriction?",
                                          "options": ["private", "protected", "public", "package-private"],
                                          "answer": "private",
                                          "reasoning": "Private members are only accessible within their own class."
                                        },
                                        {
                                          "question": "What are getter methods?",
                                          "options": ["Methods that return field values", "Methods that set field values", "Constructor methods", "Private methods"],
                                          "answer": "Methods that return field values",
                                          "reasoning": "Getters provide read access to private fields."
                                        },
                                        {
                                          "question": "What are setter methods?",
                                          "options": ["Methods that modify field values with validation", "Methods that get values", "Static methods", "Final methods"],
                                          "answer": "Methods that modify field values with validation",
                                          "reasoning": "Setters provide controlled write access with validation."
                                        },
                                        {
                                          "question": "Why use encapsulation?",
                                          "options": ["Data protection and maintainability", "Code duplication", "Faster execution", "Smaller code size"],
                                          "answer": "Data protection and maintainability",
                                          "reasoning": "Encapsulation protects data and makes code easier to maintain."
                                        },
                                        {
                                          "question": "Can private methods be accessed from outside class?",
                                          "options": ["No", "Yes", "Only by subclasses", "Only in same package"],
                                          "answer": "No",
                                          "reasoning": "Private methods are only accessible within the same class."
                                        },
                                        {
                                          "question": "What is data hiding?",
                                          "options": ["Making fields private", "Deleting data", "Encrypting data", "Storing in database"],
                                          "answer": "Making fields private",
                                          "reasoning": "Data hiding means making fields private to restrict direct access."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 25 – Abstraction",
                                      "definition": "Abstraction is the concept of hiding complex implementation details and showing only essential features to the user, focusing on what an object does rather than how it does it.",
                                      "explanation": "Think of abstraction like driving a car - you don't need to know how the engine works internally; you just use the steering wheel, pedals, and gears to drive. Similarly, in programming, abstraction lets you create simple interfaces for complex systems. We achieve abstraction using abstract classes and interfaces. Abstract classes can have both implemented and unimplemented methods, while interfaces define contracts that classes must follow. Abstraction helps manage complexity by breaking systems into manageable pieces.",
                                      "code_example": "// Demonstrating abstraction in Java\n\n// Abstract class - cannot be instantiated\nabstract class Vehicle {\n    // Concrete fields\n    protected String brand;\n    protected String model;\n    protected int year;\n    \n    // Constructor\n    public Vehicle(String brand, String model, int year) {\n        this.brand = brand;\n        this.model = model;\n        this.year = year;\n    }\n    \n    // Concrete method - has implementation\n    public void displayInfo() {\n        System.out.println(year + \" \" + brand + \" \" + model);\n    }\n    \n    // Abstract methods - no implementation, must be implemented by subclasses\n    public abstract void start();\n    public abstract void stop();\n    public abstract void accelerate();\n    \n    // Another concrete method\n    public void honk() {\n        System.out.println(brand + \" \" + model + \" goes Beep Beep!\");\n    }\n}\n\n// Concrete class extending abstract class\nclass Car extends Vehicle {\n    private int doors;\n    \n    public Car(String brand, String model, int year, int doors) {\n        super(brand, model, year);\n        this.doors = doors;\n    }\n    \n    // Implementing abstract methods\n    @Override\n    public void start() {\n        System.out.println(brand + \" \" + model + \" car starting with key ignition...\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(brand + \" \" + model + \" car stopping with brakes...\");\n    }\n    \n    @Override\n    public void accelerate() {\n        System.out.println(brand + \" \" + model + \" car accelerating with gas pedal...\");\n    }\n    \n    // Additional concrete method specific to Car\n    public void openTrunk() {\n        System.out.println(brand + \" \" + model + \" trunk opened!\");\n    }\n    \n    @Override\n    public void displayInfo() {\n        super.displayInfo();\n        System.out.println(\"Doors: \" + doors);\n    }\n}\n\n// Another concrete class\nclass Motorcycle extends Vehicle {\n    private boolean hasSideCar;\n    \n    public Motorcycle(String brand, String model, int year, boolean hasSideCar) {\n        super(brand, model, year);\n        this.hasSideCar = hasSideCar;\n    }\n    \n    @Override\n    public void start() {\n        System.out.println(brand + \" \" + model + \" motorcycle starting with kick start...\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(brand + \" \" + model + \" motorcycle stopping...\");\n    }\n    \n    @Override\n    public void accelerate() {\n        System.out.println(brand + \" \" + model + \" motorcycle accelerating by twisting throttle...\");\n    }\n    \n    // Additional method specific to Motorcycle\n    public void wheelie() {\n        System.out.println(brand + \" \" + model + \" doing a wheelie!\");\n    }\n    \n    @Override\n    public void displayInfo() {\n        super.displayInfo();\n        System.out.println(\"Has side car: \" + (hasSideCar ? \"Yes\" : \"No\"));\n    }\n}\n\n// Interface - defines contract without implementation\ninterface SmartDevice {\n    // Constant fields (implicitly public static final)\n    String TYPE = \"Smart Device\";\n    \n    // Abstract methods (implicitly public abstract)\n    void connectToWiFi(String networkName);\n    void disconnectFromWiFi();\n    void updateSoftware();\n    \n    // Default method (Java 8+) - has implementation\n    default void displayType() {\n        System.out.println(\"This is a: \" + TYPE);\n    }\n    \n    // Static method (Java 8+)\n    static void showTechnology() {\n        System.out.println(\"Smart devices use IoT technology\");\n    }\n}\n\n// Another interface\ninterface EntertainmentSystem {\n    void playMusic(String song);\n    void stopMusic();\n    void adjustVolume(int level);\n    \n    default void emergencyAlert() {\n        System.out.println(\"Emergency alert: Check device status!\");\n    }\n}\n\n// Class implementing multiple interfaces\nclass SmartSpeaker implements SmartDevice, EntertainmentSystem {\n    private String brand;\n    private String model;\n    private boolean isConnected;\n    private boolean isPlaying;\n    private int volume;\n    \n    public SmartSpeaker(String brand, String model) {\n        this.brand = brand;\n        this.model = model;\n        this.isConnected = false;\n        this.isPlaying = false;\n        this.volume = 50;\n    }\n    \n    // Implement SmartDevice methods\n    @Override\n    public void connectToWiFi(String networkName) {\n        isConnected = true;\n        System.out.println(brand + \" \" + model + \" connected to WiFi: \" + networkName);\n    }\n    \n    @Override\n    public void disconnectFromWiFi() {\n        isConnected = false;\n        System.out.println(brand + \" \" + model + \" disconnected from WiFi\");\n    }\n    \n    @Override\n    public void updateSoftware() {\n        System.out.println(brand + \" \" + model + \" software updated to latest version\");\n    }\n    \n    // Implement EntertainmentSystem methods\n    @Override\n    public void playMusic(String song) {\n        if (isConnected) {\n            isPlaying = true;\n            System.out.println(brand + \" \" + model + \" playing: \" + song + \" at volume \" + volume);\n        } else {\n            System.out.println(\"Cannot play music: Not connected to WiFi!\");\n        }\n    }\n    \n    @Override\n    public void stopMusic() {\n        isPlaying = false;\n        System.out.println(brand + \" \" + model + \" stopped playing music\");\n    }\n    \n    @Override\n    public void adjustVolume(int level) {\n        if (level >= 0 && level <= 100) {\n            volume = level;\n            System.out.println(brand + \" \" + model + \" volume set to: \" + volume);\n        } else {\n            System.out.println(\"Volume must be between 0 and 100!\");\n        }\n    }\n    \n    // Own methods\n    public void displayStatus() {\n        System.out.println(\"=== \" + brand + \" \" + model + \" Status ===\");\n        System.out.println(\"WiFi Connected: \" + (isConnected ? \"Yes\" : \"No\"));\n        System.out.println(\"Playing Music: \" + (isPlaying ? \"Yes\" : \"No\"));\n        System.out.println(\"Volume Level: \" + volume);\n    }\n    \n    // Override default method\n    @Override\n    public void displayType() {\n        System.out.println(\"This is a Smart Speaker - \" + TYPE);\n    }\n}\n\n// Abstract class with interface\nabstract class BankAccount {\n    protected String accountNumber;\n    protected double balance;\n    protected String accountHolder;\n    \n    public BankAccount(String accountNumber, String accountHolder, double balance) {\n        this.accountNumber = accountNumber;\n        this.accountHolder = accountHolder;\n        this.balance = balance;\n    }\n    \n    // Concrete methods\n    public void displayBalance() {\n        System.out.println(accountHolder + \"'s balance: $\" + balance);\n    }\n    \n    public String getAccountNumber() {\n        return accountNumber;\n    }\n    \n    // Abstract methods\n    public abstract void withdraw(double amount);\n    public abstract void deposit(double amount);\n    public abstract double calculateInterest();\n    \n    // Final method - cannot be overridden\n    public final void displayAccountInfo() {\n        System.out.println(\"Account Number: \" + accountNumber);\n        System.out.println(\"Account Holder: \" + accountHolder);\n        System.out.println(\"Balance: $\" + balance);\n    }\n}\n\n// Concrete class extending abstract class\nclass SavingsAccount extends BankAccount {\n    private double interestRate;\n    \n    public SavingsAccount(String accountNumber, String accountHolder, double balance, double interestRate) {\n        super(accountNumber, accountHolder, balance);\n        this.interestRate = interestRate;\n    }\n    \n    @Override\n    public void withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            System.out.println(\"Withdrawn: $\" + amount + \" from savings account\");\n        } else {\n            System.out.println(\"Invalid withdrawal amount or insufficient funds!\");\n        }\n    }\n    \n    @Override\n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            System.out.println(\"Deposited: $\" + amount + \" to savings account\");\n        } else {\n            System.out.println(\"Invalid deposit amount!\");\n        }\n    }\n    \n    @Override\n    public double calculateInterest() {\n        double interest = balance * interestRate / 100;\n        System.out.println(\"Interest calculated: $\" + interest);\n        return interest;\n    }\n    \n    public void addInterest() {\n        double interest = calculateInterest();\n        balance += interest;\n        System.out.println(\"Interest added. New balance: $\" + balance);\n    }\n}\n\n// Another concrete class\nclass CheckingAccount extends BankAccount {\n    private double overdraftLimit;\n    \n    public CheckingAccount(String accountNumber, String accountHolder, double balance, double overdraftLimit) {\n        super(accountNumber, accountHolder, balance);\n        this.overdraftLimit = overdraftLimit;\n    }\n    \n    @Override\n    public void withdraw(double amount) {\n        if (amount > 0 && (balance - amount) >= -overdraftLimit) {\n            balance -= amount;\n            System.out.println(\"Withdrawn: $\" + amount + \" from checking account\");\n            if (balance < 0) {\n                System.out.println(\"Warning: Overdraft used! Balance: $\" + balance);\n            }\n        } else {\n            System.out.println(\"Invalid withdrawal amount or exceeds overdraft limit!\");\n        }\n    }\n    \n    @Override\n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            System.out.println(\"Deposited: $\" + amount + \" to checking account\");\n        } else {\n            System.out.println(\"Invalid deposit amount!\");\n        }\n    }\n    \n    @Override\n    public double calculateInterest() {\n        System.out.println(\"Checking accounts typically don't earn interest\");\n        return 0.0;\n    }\n    \n    public void writeCheck(double amount) {\n        System.out.println(\"Check written for: $\" + amount);\n        withdraw(amount);\n    }\n}\n\npublic class AbstractionDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Abstraction Demonstration ===\\n\");\n        \n        System.out.println(\"=== Abstract Class Example ===\");\n        \n        // Cannot instantiate abstract class\n        // Vehicle vehicle = new Vehicle(\"Generic\", \"Vehicle\", 2023);  // Error!\n        \n        // But we can use abstract class references\n        Vehicle car = new Car(\"Toyota\", \"Camry\", 2023, 4);\n        Vehicle motorcycle = new Motorcycle(\"Harley\", \"Davidson\", 2022, false);\n        \n        // Polymorphic behavior\n        Vehicle[] vehicles = {car, motorcycle};\n        \n        for (Vehicle vehicle : vehicles) {\n            vehicle.displayInfo();\n            vehicle.start();\n            vehicle.accelerate();\n            vehicle.honk();\n            vehicle.stop();\n            System.out.println();\n        }\n        \n        // Accessing subclass-specific methods\n        System.out.println(\"--- Subclass-specific Methods ---\");\n        Car myCar = (Car) car;\n        myCar.openTrunk();\n        \n        Motorcycle myMotorcycle = (Motorcycle) motorcycle;\n        myMotorcycle.wheelie();\n        \n        System.out.println(\"\\n=== Interface Example ===\");\n        \n        SmartSpeaker speaker = new SmartSpeaker(\"Amazon\", \"Echo\");\n        \n        // Using interface methods\n        speaker.displayType();  // Default method\n        speaker.connectToWiFi(\"HomeNetwork\");\n        speaker.playMusic(\"Yesterday - The Beatles\");\n        speaker.adjustVolume(75);\n        speaker.displayStatus();\n        \n        // Static interface method\n        SmartDevice.showTechnology();\n        \n        System.out.println(\"\\n--- Multiple Interfaces ---\");\n        \n        // Treat as different interface types\n        SmartDevice device = speaker;\n        EntertainmentSystem entertainment = speaker;\n        \n        device.updateSoftware();\n        entertainment.playMusic(\"Another Song\");\n        entertainment.emergencyAlert();  // Default method\n        \n        System.out.println(\"\\n=== Bank Account Abstraction ===\");\n        \n        BankAccount savings = new SavingsAccount(\"SAV123\", \"Alice\", 5000.0, 2.5);\n        BankAccount checking = new CheckingAccount(\"CHK456\", \"Bob\", 1000.0, 500.0);\n        \n        BankAccount[] accounts = {savings, checking};\n        \n        for (BankAccount account : accounts) {\n            account.displayAccountInfo();  // Final method - same for all\n            account.deposit(500.0);\n            account.withdraw(200.0);\n            account.calculateInterest();   // Abstract method - different implementations\n            System.out.println();\n        }\n        \n        // Subclass-specific methods\n        System.out.println(\"--- Account-specific Features ---\");\n        SavingsAccount savingsAcc = (SavingsAccount) savings;\n        savingsAcc.addInterest();\n        \n        CheckingAccount checkingAcc = (CheckingAccount) checking;\n        checkingAcc.writeCheck(300.0);\n        \n        System.out.println(\"\\n=== Benefits of Abstraction ===\");\n        \n        System.out.println(\"1. Simplifies Complex Systems:\");\n        System.out.println(\"   - Users don't need to know internal implementation\");\n        System.out.println(\"   - Focus on what objects do, not how they do it\");\n        \n        System.out.println(\"2. Promotes Code Reuse:\");\n        System.out.println(\"   - Common functionality in abstract classes\");\n        System.out.println(\"   - Multiple implementations of same interface\");\n        \n        System.out.println(\"3. Enables Polymorphism:\");\n        System.out.println(\"   - Treat different objects uniformly\");\n        System.out.println(\"   - Easy to extend with new types\");\n        \n        System.out.println(\"4. Loose Coupling:\");\n        System.out.println(\"   - Depend on abstractions, not concrete implementations\");\n        System.out.println(\"   - Easy to swap implementations\");\n    }\n}",
                                      "real_world_example": "Abstraction is used extensively in real software. Database systems provide abstract interfaces (JDBC) that work with different database vendors. Payment gateways offer abstract interfaces for different payment methods. File systems provide abstract interfaces for different storage types. GUI frameworks use abstraction for different UI components. Network protocols use abstraction for different communication methods. Cloud services provide abstract interfaces for different cloud providers. This allows systems to work with multiple implementations without knowing the details.",
                                      "interactive_tasks": [
                                        "Create an abstract Shape class with abstract area() method and concrete subclasses Circle, Rectangle",
                                        "Write a Notification interface with send() method and implement Email, SMS, and Push notifications",
                                        "Create an abstract DatabaseConnection class with concrete MySQL and PostgreSQL implementations"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "What is abstraction?",
                                          "options": ["Hiding implementation, showing functionality", "Showing all details", "Creating objects", "Inheriting classes"],
                                          "answer": "Hiding implementation, showing functionality",
                                          "reasoning": "Abstraction focuses on what objects do rather than how they do it."
                                        },
                                        {
                                          "question": "Can abstract classes be instantiated?",
                                          "options": ["No", "Yes", "Only with new", "Only in main method"],
                                          "answer": "No",
                                          "reasoning": "Abstract classes cannot be instantiated directly."
                                        },
                                        {
                                          "question": "What must subclasses do with abstract methods?",
                                          "options": ["Implement them", "Ignore them", "Make them private", "Delete them"],
                                          "answer": "Implement them",
                                          "reasoning": "Subclasses must provide implementation for all abstract methods."
                                        },
                                        {
                                          "question": "What is an interface?",
                                          "options": ["Contract that classes must follow", "Abstract class", "Concrete class", "Method collection"],
                                          "answer": "Contract that classes must follow",
                                          "reasoning": "Interface defines methods that implementing classes must provide."
                                        },
                                        {
                                          "question": "Can a class implement multiple interfaces?",
                                          "options": ["Yes", "No", "Only two", "Only if abstract"],
                                          "answer": "Yes",
                                          "reasoning": "Java classes can implement multiple interfaces."
                                        },
                                        {
                                          "question": "What are default methods in interfaces?",
                                          "options": ["Methods with implementation", "Abstract methods", "Static methods", "Private methods"],
                                          "answer": "Methods with implementation",
                                          "reasoning": "Default methods provide implementation in interfaces (Java 8+)."
                                        },
                                        {
                                          "question": "Why use abstraction?",
                                          "options": ["Reduce complexity and increase flexibility", "Make code longer", "Improve performance", "Create more objects"],
                                          "answer": "Reduce complexity and increase flexibility",
                                          "reasoning": "Abstraction simplifies complex systems and makes them more flexible."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 26 – Access Modifiers",
                                      "definition": "Access modifiers are keywords in Java that set the accessibility (visibility) of classes, methods, constructors, and other members, controlling where they can be accessed from.",
                                      "explanation": "Think of access modifiers like security levels in a building. Public areas are accessible to everyone (public), employee-only areas are restricted to staff (protected), department-specific areas are for team members only (package-private), and private offices are for individual use only (private). Access modifiers help you enforce encapsulation by controlling what parts of your code are exposed to other classes and packages. Understanding and using them properly is crucial for building secure, maintainable Java applications.",
                                      "code_example": "// Demonstrating access modifiers in Java\n\n// Public class - accessible from anywhere\npublic class AccessModifiersDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Access Modifiers Demonstration ===\\n\");\n        \n        // Test different access levels\n        TestClass test = new TestClass();\n        test.testAccess();\n        \n        // Test package access\n        PackageClass pkgClass = new PackageClass();\n        pkgClass.display();\n        \n        // Test inheritance access\n        System.out.println(\"\\n=== Inheritance Access Test ===\");\n        SubClass sub = new SubClass();\n        sub.testInheritanceAccess();\n        \n        // Test different package scenario\n        System.out.println(\"\\n=== Cross-Package Access ===\");\n        test.testCrossPackageAccess();\n    }\n}\n\n// Class with different access modifiers\nclass TestClass {\n    // Public field - accessible from anywhere\n    public String publicField = \"I am public\";\n    \n    // Protected field - accessible in package and subclasses\n    protected String protectedField = \"I am protected\";\n    \n    // Package-private (default) field - accessible only in same package\n    String packageField = \"I am package-private\";\n    \n    // Private field - accessible only in this class\n    private String privateField = \"I am private\";\n    \n    // Public method\n    public void publicMethod() {\n        System.out.println(\"Public method called\");\n    }\n    \n    // Protected method\n    protected void protectedMethod() {\n        System.out.println(\"Protected method called\");\n    }\n    \n    // Package-private method\n    void packageMethod() {\n        System.out.println(\"Package-private method called\");\n    }\n    \n    // Private method\n    private void privateMethod() {\n        System.out.println(\"Private method called\");\n    }\n    \n    // Method to test access within same class\n    public void testAccess() {\n        System.out.println(\"=== Access within Same Class ===\");\n        \n        // All access levels are accessible within the same class\n        System.out.println(publicField);     // OK\n        System.out.println(protectedField);  // OK\n        System.out.println(packageField);    // OK\n        System.out.println(privateField);    // OK\n        \n        publicMethod();      // OK\n        protectedMethod();   // OK\n        packageMethod();     // OK\n        privateMethod();     // OK\n    }\n    \n    // Method to test cross-package access (simulated)\n    public void testCrossPackageAccess() {\n        System.out.println(\"In different package, you can access:\");\n        System.out.println(\"- public members: YES\");\n        System.out.println(\"- protected members: NO (unless subclass)\");\n        System.out.println(\"- package-private members: NO\");\n        System.out.println(\"- private members: NO\");\n    }\n}\n\n// Package-private class (default access)\nclass PackageClass {\n    public void display() {\n        System.out.println(\"\\n=== Package Class Access ===\");\n        TestClass test = new TestClass();\n        \n        // In same package, can access public, protected, and package-private\n        System.out.println(test.publicField);     // OK\n        System.out.println(test.protectedField);  // OK\n        System.out.println(test.packageField);    // OK\n        // System.out.println(test.privateField); // Error: private access\n        \n        test.publicMethod();      // OK\n        test.protectedMethod();   // OK\n        test.packageMethod();     // OK\n        // test.privateMethod();   // Error: private access\n    }\n}\n\n// Subclass in same package\nclass SubClass extends TestClass {\n    public void testInheritanceAccess() {\n        System.out.println(\"=== Subclass Access (Same Package) ===\");\n        \n        // Subclass can access public, protected, and package-private\n        System.out.println(publicField);     // OK - inherited\n        System.out.println(protectedField);  // OK - inherited\n        System.out.println(packageField);    // OK - same package\n        // System.out.println(privateField); // Error: private not inherited\n        \n        publicMethod();      // OK - inherited\n        protectedMethod();   // OK - inherited\n        packageMethod();     // OK - same package\n        // privateMethod();   // Error: private not inherited\n    }\n}\n\n// Example demonstrating practical use of access modifiers\nclass BankAccount {\n    // Private fields - encapsulated data\n    private String accountNumber;\n    private String accountHolder;\n    private double balance;\n    private String accountType;\n    \n    // Protected field - accessible to subclasses\n    protected double interestRate;\n    \n    // Package-private field - for internal bank operations\n    String branchCode;\n    \n    // Public constant\n    public static final String BANK_NAME = \"Java Bank\";\n    \n    // Constructor\n    public BankAccount(String accountNumber, String accountHolder, double initialBalance, String accountType) {\n        this.accountNumber = accountNumber;\n        this.accountHolder = accountHolder;\n        this.balance = Math.max(0, initialBalance);\n        this.accountType = accountType;\n        this.interestRate = 0.0;\n        this.branchCode = \"MAIN\";\n    }\n    \n    // Public methods - interface for users\n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            System.out.println(\"Deposited: $\" + amount);\n        } else {\n            System.out.println(\"Invalid deposit amount!\");\n        }\n    }\n    \n    public void withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            System.out.println(\"Withdrawn: $\" + amount);\n        } else {\n            System.out.println(\"Invalid withdrawal amount or insufficient funds!\");\n        }\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n    \n    public String getAccountHolder() {\n        return accountHolder;\n    }\n    \n    // Protected method - for subclasses\n    protected void setInterestRate(double rate) {\n        if (rate >= 0) {\n            this.interestRate = rate;\n            System.out.println(\"Interest rate set to: \" + rate + \"%\");\n        }\n    }\n    \n    // Package-private method - for internal bank operations\n    void updateBranchCode(String newCode) {\n        this.branchCode = newCode;\n        System.out.println(\"Branch code updated to: \" + newCode);\n    }\n    \n    // Private method - internal helper\n    private boolean isValidAmount(double amount) {\n        return amount > 0;\n    }\n    \n    // Public method using private helper\n    public void displayAccountInfo() {\n        System.out.println(\"=== \" + BANK_NAME + \" ===\");\n        System.out.println(\"Account: \" + accountNumber);\n        System.out.println(\"Holder: \" + accountHolder);\n        System.out.println(\"Type: \" + accountType);\n        System.out.println(\"Balance: $\" + balance);\n        System.out.println(\"Branch: \" + branchCode);\n    }\n}\n\n// Savings account subclass\nclass SavingsAccount extends BankAccount {\n    public SavingsAccount(String accountNumber, String accountHolder, double initialBalance) {\n        super(accountNumber, accountHolder, initialBalance, \"Savings\");\n        // Can access protected field from parent\n        this.interestRate = 2.5; // 2.5% interest for savings\n    }\n    \n    // Can access protected method from parent\n    public void updateInterestRate(double newRate) {\n        setInterestRate(newRate); // OK - protected method\n    }\n    \n    public void addInterest() {\n        double interest = getBalance() * interestRate / 100;\n        // deposit(interest); // Would work but let's simulate differently\n        System.out.println(\"Interest added: $\" + interest);\n        // Note: We can't directly modify balance because it's private\n        // We have to use public methods\n    }\n    \n    // Cannot access private fields/methods from parent\n    // private void hackBalance() {\n    //     balance = 1000000; // Error: balance has private access\n    // }\n}\n\n// Bank employee class (same package)\nclass BankEmployee {\n    public void processAccount(BankAccount account) {\n        System.out.println(\"\\n=== Bank Employee Processing ===\");\n        \n        // Employee can access public methods\n        account.displayAccountInfo();\n        \n        // Employee can access package-private methods (same package)\n        account.updateBranchCode(\"DOWNTOWN\");\n        \n        // Employee cannot access private methods\n        // account.isValidAmount(100); // Error: private access\n        \n        // Employee cannot access protected methods from outside hierarchy\n        // account.setInterestRate(3.0); // Error: protected access\n    }\n}\n\n// Demonstration class\nclass AccessDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Practical Access Modifiers Example ===\\n\");\n        \n        // Create bank account\n        BankAccount account = new BankAccount(\"ACC123\", \"John Doe\", 1000.0, \"Checking\");\n        \n        // Public access - anyone can use\n        account.deposit(500.0);\n        account.withdraw(200.0);\n        account.displayAccountInfo();\n        \n        System.out.println(\"\\nBank Name: \" + BankAccount.BANK_NAME); // Public constant\n        \n        // Create savings account\n        SavingsAccount savings = new SavingsAccount(\"SAV456\", \"Jane Smith\", 5000.0);\n        savings.displayAccountInfo();\n        savings.updateInterestRate(3.0); // Using protected method via public wrapper\n        \n        // Bank employee processing\n        BankEmployee employee = new BankEmployee();\n        employee.processAccount(account);\n        \n        System.out.println(\"\\n=== Access Modifiers Summary ===\");\n        System.out.println(\"1. public: Accessible from anywhere\");\n        System.out.println(\"2. protected: Accessible in package + subclasses\");\n        System.out.println(\"3. package-private (default): Accessible only in package\");\n        System.out.println(\"4. private: Accessible only in same class\");\n        \n        System.out.println(\"\\n=== Best Practices ===\");\n        System.out.println(\"• Use private for fields (encapsulation)\");\n        System.out.println(\"• Use public for API methods\");\n        System.out.println(\"• Use protected for extension points\");\n        System.out.println(\"• Use package-private for internal implementation\");\n    }\n}",
                                      "real_world_example": "Access modifiers are crucial in real-world applications for security and maintainability. Banking systems use private fields for sensitive data like balances and account numbers. Framework libraries use protected methods to allow customization by subclasses. Internal APIs use package-private access to hide implementation details from users. Public interfaces are carefully designed to expose only safe, stable methods. Spring Framework uses access modifiers to control bean visibility. Hibernate uses them to manage entity relationships. Proper access control prevents unauthorized access and makes APIs clearer.",
                                      "interactive_tasks": [
                                        "Create a User class with private password field and public login method",
                                        "Write a Library class with protected methods for internal management and public methods for users",
                                        "Create a configuration class with package-private constructor and public static factory method"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "Which access modifier has the widest accessibility?",
                                          "options": ["public", "protected", "package-private", "private"],
                                          "answer": "public",
                                          "reasoning": "Public members are accessible from any other class."
                                        },
                                        {
                                          "question": "What is the default access modifier?",
                                          "options": ["package-private", "public", "protected", "private"],
                                          "answer": "package-private",
                                          "reasoning": "When no modifier is specified, it's package-private (default)."
                                        },
                                        {
                                          "question": "Where can protected members be accessed?",
                                          "options": ["Same package and subclasses", "Anywhere", "Same class only", "Same package only"],
                                          "answer": "Same package and subclasses",
                                          "reasoning": "Protected members are accessible within package and to subclasses."
                                        },
                                        {
                                          "question": "Can private methods be overridden?",
                                          "options": ["No", "Yes", "Only in same package", "Only by subclasses"],
                                          "answer": "No",
                                          "reasoning": "Private methods are not inherited, so they cannot be overridden."
                                        },
                                        {
                                          "question": "What access should class fields typically have?",
                                          "options": ["private", "public", "protected", "package-private"],
                                          "answer": "private",
                                          "reasoning": "Fields should be private for encapsulation, accessed via getters/setters."
                                        },
                                        {
                                          "question": "Can a subclass access private members of parent?",
                                          "options": ["No", "Yes", "Only if same package", "Only through reflection"],
                                          "answer": "No",
                                          "reasoning": "Private members are not accessible to subclasses."
                                        },
                                        {
                                          "question": "What access should constants typically have?",
                                          "options": ["public static final", "private", "protected", "package-private"],
                                          "answer": "public static final",
                                          "reasoning": "Constants are typically public static final for wide accessibility."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 27 – Static Members and Final Keyword",
                                      "definition": "Static members belong to the class rather than instances, and the final keyword makes variables constant, methods unoverrideable, and classes uninheritable.",
                                      "explanation": "Think of static members like shared resources in an office building - there's one photocopier (static) that everyone shares, rather than each person having their own. Static members exist independently of any object instances. The final keyword is like making something permanent - a final variable cannot be changed (constant), a final method cannot be overridden, and a final class cannot be extended. Understanding these concepts helps you create efficient, secure, and well-organized code.",
                                      "code_example": "// Demonstrating static members and final keyword\n\nclass MathUtils {\n    // Static final constant - belongs to class, cannot be changed\n    public static final double PI = 3.14159;\n    public static final double E = 2.71828;\n    \n    // Static variable - shared by all instances\n    private static int instanceCount = 0;\n    \n    // Instance variable - each object has its own copy\n    private int objectId;\n    \n    // Static initializer block - runs when class is loaded\n    static {\n        System.out.println(\"MathUtils class loaded!\");\n        System.out.println(\"PI = \" + PI + \", E = \" + E);\n    }\n    \n    // Constructor\n    public MathUtils() {\n        instanceCount++;  // Increment shared counter\n        objectId = instanceCount;  // Assign unique ID\n        System.out.println(\"MathUtils object #\" + objectId + \" created\");\n    }\n    \n    // Static method - can be called without creating object\n    public static double calculateCircleArea(double radius) {\n        return PI * radius * radius;\n    }\n    \n    public static double calculateCircleCircumference(double radius) {\n        return 2 * PI * radius;\n    }\n    \n    public static int factorial(int n) {\n        if (n <= 1) return 1;\n        return n * factorial(n - 1);\n    }\n    \n    // Static method to access static variable\n    public static int getInstanceCount() {\n        return instanceCount;\n    }\n    \n    // Instance method\n    public void displayInfo() {\n        System.out.println(\"Object ID: \" + objectId);\n        System.out.println(\"Total instances created: \" + instanceCount);\n    }\n    \n    // Final instance method - cannot be overridden\n    public final void cannotOverride() {\n        System.out.println(\"This method cannot be overridden by subclasses!\");\n    }\n}\n\n// Final class - cannot be extended\nfinal class Constants {\n    // Public static final constants\n    public static final String APPLICATION_NAME = \"MyJavaApp\";\n    public static final String VERSION = \"1.0.0\";\n    public static final int MAX_USERS = 1000;\n    public static final double TAX_RATE = 0.15;\n    \n    // Private constructor - cannot be instantiated\n    private Constants() {\n        // Utility class - no instances allowed\n    }\n    \n    // Static method\n    public static void displayAppInfo() {\n        System.out.println(APPLICATION_NAME + \" v\" + VERSION);\n        System.out.println(\"Max users: \" + MAX_USERS);\n        System.out.println(\"Tax rate: \" + (TAX_RATE * 100) + \"%\");\n    }\n}\n\n// Class demonstrating final parameters and variables\nclass FinalDemo {\n    // Final instance variable - must be initialized in constructor\n    private final int finalNumber;\n    \n    // Final static variable\n    private static final String FINAL_MESSAGE;\n    \n    // Static initializer for final static variable\n    static {\n        FINAL_MESSAGE = \"Hello from static final!\";\n    }\n    \n    // Constructor\n    public FinalDemo(int number) {\n        this.finalNumber = number;  // Must initialize final instance variable\n    }\n    \n    // Method with final parameter\n    public void processFinalParameter(final int value) {\n        // value = 100;  // Error: cannot assign value to final parameter\n        System.out.println(\"Processing final parameter: \" + value);\n    }\n    \n    // Method demonstrating final local variable\n    public void demonstrateFinalLocal() {\n        final String localFinal = \"I am final local\";\n        // localFinal = \"Try to change\";  // Error: cannot assign value to final variable\n        System.out.println(localFinal);\n        \n        // Final reference variable\n        final StringBuilder finalBuilder = new StringBuilder(\"Hello\");\n        // finalBuilder = new StringBuilder(\"World\");  // Error: cannot reassign final reference\n        finalBuilder.append(\" World\");  // But we can modify the object it refers to\n        System.out.println(finalBuilder.toString());\n    }\n    \n    public int getFinalNumber() {\n        return finalNumber;\n    }\n    \n    // Cannot modify finalNumber\n    // public void setFinalNumber(int num) {\n    //     this.finalNumber = num;  // Error: cannot assign value to final variable\n    // }\n}\n\n// Class extending MathUtils (but cannot extend Constants because it's final)\nclass AdvancedMath extends MathUtils {\n    // Static variable shadowing\n    private static String message = \"Advanced Math\";\n    \n    // Cannot override final method from parent\n    // @Override\n    // public void cannotOverride() {  // Error: cannot override final method\n    //     System.out.println(\"Trying to override...\");\n    // }\n    \n    // But we can overload it\n    public void cannotOverride(String text) {\n        System.out.println(\"Overloaded method: \" + text);\n    }\n    \n    // Static method - not overriding, but hiding\n    public static double calculateCircleArea(double radius, String unit) {\n        double area = MathUtils.calculateCircleArea(radius);\n        System.out.println(\"Area: \" + area + \" square \" + unit);\n        return area;\n    }\n    \n    // Instance method using parent's static method\n    public void demonstrateStaticUsage() {\n        System.out.println(\"PI value: \" + MathUtils.PI);\n        System.out.println(\"5! = \" + MathUtils.factorial(5));\n    }\n}\n\n// Singleton pattern using static\nclass DatabaseConnection {\n    // Static variable to hold single instance\n    private static DatabaseConnection instance;\n    \n    // Final instance variables\n    private final String connectionString;\n    private final String databaseName;\n    \n    // Private constructor - prevent instantiation\n    private DatabaseConnection() {\n        this.connectionString = \"jdbc:mysql://localhost:3306/mydb\";\n        this.databaseName = \"myDatabase\";\n        System.out.println(\"Database connection created!\");\n    }\n    \n    // Static method to get singleton instance\n    public static DatabaseConnection getInstance() {\n        if (instance == null) {\n            instance = new DatabaseConnection();\n        }\n        return instance;\n    }\n    \n    // Static method to reset instance (for testing)\n    public static void resetInstance() {\n        instance = null;\n    }\n    \n    public void connect() {\n        System.out.println(\"Connected to: \" + connectionString);\n    }\n    \n    public void disconnect() {\n        System.out.println(\"Disconnected from: \" + databaseName);\n    }\n    \n    // Final method\n    public final String getConnectionInfo() {\n        return \"Database: \" + databaseName + \", Connection: \" + connectionString;\n    }\n}\n\n// Utility class with only static methods\nfinal class StringUtils {\n    // Private constructor - prevent instantiation\n    private StringUtils() {\n        throw new AssertionError(\"Cannot instantiate utility class!\");\n    }\n    \n    // Static methods\n    public static boolean isNullOrEmpty(String str) {\n        return str == null || str.trim().isEmpty();\n    }\n    \n    public static String reverse(String str) {\n        if (str == null) return null;\n        return new StringBuilder(str).reverse().toString();\n    }\n    \n    public static int countWords(String text) {\n        if (isNullOrEmpty(text)) return 0;\n        return text.trim().split(\"\\\\s+\").length;\n    }\n    \n    public static String capitalize(String str) {\n        if (isNullOrEmpty(str)) return str;\n        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();\n    }\n}\n\npublic class StaticFinalDemo {\n    // Static variable\n    private static int demoCount = 0;\n    \n    // Final static variable\n    private static final String DEMO_NAME = \"StaticFinalDemo\";\n    \n    // Instance variable\n    private int instanceId;\n    \n    // Static initializer\n    static {\n        System.out.println(\"=== Static and Final Demonstration ===\\n\");\n        demoCount = 1;\n    }\n    \n    // Constructor\n    public StaticFinalDemo() {\n        this.instanceId = demoCount++;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"=== Static Members Demonstration ===\\n\");\n        \n        // Using static methods without creating objects\n        System.out.println(\"MathUtils.PI = \" + MathUtils.PI);\n        System.out.println(\"Circle area with radius 5: \" + MathUtils.calculateCircleArea(5.0));\n        System.out.println(\"5 factorial: \" + MathUtils.factorial(5));\n        \n        // Create objects to demonstrate instance counting\n        MathUtils math1 = new MathUtils();\n        MathUtils math2 = new MathUtils();\n        MathUtils math3 = new MathUtils();\n        \n        System.out.println(\"\\nTotal MathUtils instances: \" + MathUtils.getInstanceCount());\n        \n        math1.displayInfo();\n        math2.displayInfo();\n        \n        System.out.println(\"\\n=== Final Keyword Demonstration ===\\n\");\n        \n        // Using final class and constants\n        Constants.displayAppInfo();\n        System.out.println(\"Tax amount for $100: $\" + (100 * Constants.TAX_RATE));\n        \n        // Final variables demo\n        FinalDemo finalDemo = new FinalDemo(42);\n        System.out.println(\"Final number: \" + finalDemo.getFinalNumber());\n        finalDemo.processFinalParameter(10);\n        finalDemo.demonstrateFinalLocal();\n        \n        System.out.println(\"\\n=== Static and Final in Inheritance ===\\n\");\n        \n        AdvancedMath advanced = new AdvancedMath();\n        advanced.demonstrateStaticUsage();\n        advanced.cannotOverride();  // Inherited final method\n        advanced.cannotOverride(\"Custom text\");  // Overloaded method\n        AdvancedMath.calculateCircleArea(3.0, \"meters\");  // Static method\n        \n        System.out.println(\"\\n=== Singleton Pattern with Static ===\\n\");\n        \n        // Singleton demonstration\n        DatabaseConnection db1 = DatabaseConnection.getInstance();\n        DatabaseConnection db2 = DatabaseConnection.getInstance();\n        \n        System.out.println(\"db1 == db2: \" + (db1 == db2));  // Same instance\n        db1.connect();\n        System.out.println(db1.getConnectionInfo());\n        \n        System.out.println(\"\\n=== Utility Class with Static Methods ===\\n\");\n        \n        // Using utility class\n        String testString = \"hello world java programming\";\n        System.out.println(\"Original: \" + testString);\n        System.out.println(\"Reversed: \" + StringUtils.reverse(testString));\n        System.out.println(\"Word count: \" + StringUtils.countWords(testString));\n        System.out.println(\"Capitalized: \" + StringUtils.capitalize(testString));\n        System.out.println(\"Is null or empty: \" + StringUtils.isNullOrEmpty(\"\"));\n        \n        // Cannot instantiate utility class\n        // StringUtils utils = new StringUtils();  // Error: private constructor\n        \n        System.out.println(\"\\n=== Static Import Demonstration ===\");\n        \n        // Using static import (commented as we're not actually importing)\n        // import static java.lang.Math.*;\n        System.out.println(\"Math.PI: \" + Math.PI);\n        System.out.println(\"Math.sqrt(16): \" + Math.sqrt(16));\n        System.out.println(\"Math.max(10, 20): \" + Math.max(10, 20));\n        \n        System.out.println(\"\\n=== Best Practices Summary ===\");\n        System.out.println(\"• Use static for utility methods and constants\");\n        System.out.println(\"• Use final for constants and immutable data\");\n        System.out.println(\"• Use static final for global constants\");\n        System.out.println(\"• Consider final classes for utility classes\");\n        System.out.println(\"• Use static for singleton instances\");\n        System.out.println(\"• Avoid static for state that should be per-instance\");\n    }\n    \n    // Static method\n    public static void displayDemoInfo() {\n        System.out.println(\"Demo: \" + DEMO_NAME);\n        System.out.println(\"Demo count: \" + demoCount);\n    }\n    \n    // Instance method\n    public void displayInstanceInfo() {\n        System.out.println(\"Instance ID: \" + instanceId);\n        System.out.println(\"Total demos: \" + demoCount);\n    }\n}",
                                      "real_world_example": "Static members and final keyword are extensively used in real applications. Math.PI and Math.E are static final constants. Utility classes like Arrays, Collections, and StringUtils use static methods. Singleton patterns use static methods to control instance creation. Configuration values are often static final constants. Database connection pools use static members to manage shared resources. Logging frameworks use static methods for convenient access. Immutable classes like String use final fields. Framework constants (Spring profiles, HTTP status codes) are typically static final.",
                                      "interactive_tasks": [
                                        "Create a Counter class with static variable to track total instances created",
                                        "Write a Configuration class with static final constants for application settings",
                                        "Create a StringHelper utility class with only static methods for string operations"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "What does static mean?",
                                          "options": ["Belongs to class, not instances", "Cannot be changed", "Always available", "Required"],
                                          "answer": "Belongs to class, not instances",
                                          "reasoning": "Static members belong to the class and are shared by all instances."
                                        },
                                        {
                                          "question": "What does final mean for variables?",
                                          "options": ["Cannot be reassigned", "Must be static", "Must be public", "Cannot be used"],
                                          "answer": "Cannot be reassigned",
                                          "reasoning": "Final variables are constants that cannot be reassigned after initialization."
                                        },
                                        {
                                          "question": "Can static methods access instance variables?",
                                          "options": ["No", "Yes", "Only if public", "Only if final"],
                                          "answer": "No",
                                          "reasoning": "Static methods cannot access instance variables directly as they belong to instances."
                                        },
                                        {
                                          "question": "What is a static initializer block?",
                                          "options": ["Runs when class is loaded", "Runs for each instance", "Runs only once", "Runs before main"],
                                          "answer": "Runs when class is loaded",
                                          "reasoning": "Static blocks run when class is loaded, before any instances are created."
                                        },
                                        {
                                          "question": "Can final methods be overridden?",
                                          "options": ["No", "Yes", "Only in same package", "Only by subclasses"],
                                          "answer": "No",
                                          "reasoning": "Final methods cannot be overridden by subclasses."
                                        },
                                        {
                                          "question": "What is static final commonly used for?",
                                          "options": ["Constants", "Singleton pattern", "Utility methods", "All of the above"],
                                          "answer": "All of the above",
                                          "reasoning": "Static final is used for constants, singleton instances, and utility classes."
                                        },
                                        {
                                          "question": "Can a final class have subclasses?",
                                          "options": ["No", "Yes", "Only in same package", "Only if abstract"],
                                          "answer": "No",
                                          "reasoning": "Final classes cannot be extended (no subclasses allowed)."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 28 – Interfaces",
                                      "definition": "Interfaces in Java are abstract types that define a contract of methods that implementing classes must provide, enabling multiple inheritance and polymorphism.",
                                      "explanation": "Think of interfaces like universal plugs and sockets - different devices (classes) can plug into the same socket (interface) as long as they have the right plug (implement the required methods). Interfaces define what a class can do without specifying how it does it. A class can implement multiple interfaces, which is Java's way of supporting multiple inheritance. Interfaces promote loose coupling and make your code more flexible and testable. Modern Java interfaces can have default and static methods with implementations.",
                                      "code_example": "// Demonstrating interfaces in Java\n\n// Basic interface\ninterface Drawable {\n    // Constant (implicitly public static final)\n    String TYPE = \"Drawable Object\";\n    \n    // Abstract method (implicitly public abstract)\n    void draw();\n    \n    // Another abstract method\n    double calculateArea();\n    \n    // Default method (Java 8+) - has implementation\n    default void displayType() {\n        System.out.println(\"This is a: \" + TYPE);\n    }\n    \n    // Static method (Java 8+)\n    static void showDrawingTools() {\n        System.out.println(\"Common drawing tools: Pencil, Brush, Pen\");\n    }\n}\n\n// Another interface\ninterface Resizable {\n    void resize(double factor);\n    void resize(double width, double height);\n    \n    default void doubleSize() {\n        resize(2.0);\n    }\n}\n\n// Interface extending another interface\ninterface Colored extends Drawable {\n    String getColor();\n    void setColor(String color);\n    \n    default void makeTransparent() {\n        setColor(\"Transparent\");\n    }\n}\n\n// Class implementing single interface\nclass Circle implements Drawable {\n    private double radius;\n    \n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    \n    @Override\n    public void draw() {\n        System.out.println(\"Drawing a circle with radius \" + radius);\n    }\n    \n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n    \n    // Can override default method\n    @Override\n    public void displayType() {\n        System.out.println(\"This is a Circle - \" + TYPE);\n    }\n    \n    // Circle-specific method\n    public double getCircumference() {\n        return 2 * Math.PI * radius;\n    }\n}\n\n// Class implementing multiple interfaces\nclass Rectangle implements Drawable, Resizable {\n    private double width;\n    private double height;\n    \n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    @Override\n    public void draw() {\n        System.out.println(\"Drawing a rectangle \" + width + \"x\" + height);\n    }\n    \n    @Override\n    public double calculateArea() {\n        return width * height;\n    }\n    \n    @Override\n    public void resize(double factor) {\n        width *= factor;\n        height *= factor;\n        System.out.println(\"Resized to: \" + width + \"x\" + height);\n    }\n    \n    @Override\n    public void resize(double width, double height) {\n        this.width = width;\n        this.height = height;\n        System.out.println(\"Resized to: \" + width + \"x\" + height);\n    }\n    \n    public double getPerimeter() {\n        return 2 * (width + height);\n    }\n}\n\n// Class implementing extended interface\nclass ColoredCircle implements Colored {\n    private double radius;\n    private String color;\n    \n    public ColoredCircle(double radius, String color) {\n        this.radius = radius;\n        this.color = color;\n    }\n    \n    @Override\n    public void draw() {\n        System.out.println(\"Drawing a \" + color + \" circle with radius \" + radius);\n    }\n    \n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n    \n    @Override\n    public String getColor() {\n        return color;\n    }\n    \n    @Override\n    public void setColor(String color) {\n        this.color = color;\n        System.out.println(\"Circle color changed to: \" + color);\n    }\n}\n\n// Functional interface (for lambda expressions)\n@FunctionalInterface\ninterface Calculator {\n    double calculate(double a, double b);\n    \n    // Can have default methods\n    default void describe() {\n        System.out.println(\"This is a calculator operation\");\n    }\n    \n    // Can have static methods\n    static Calculator createAddition() {\n        return (a, b) -> a + b;\n    }\n}\n\n// Another functional interface\ninterface Validator {\n    boolean isValid(String input);\n    \n    default Validator and(Validator other) {\n        return input -> this.isValid(input) && other.isValid(input);\n    }\n}\n\n// Real-world example: Payment system\ninterface Payment {\n    void processPayment(double amount);\n    boolean validatePayment();\n    \n    default void receipt() {\n        System.out.println(\"Payment processed successfully!\");\n    }\n    \n    static void showSupportedPayments() {\n        System.out.println(\"Supported: Credit Card, PayPal, Bank Transfer\");\n    }\n}\n\nclass CreditCardPayment implements Payment {\n    private String cardNumber;\n    private String cardHolder;\n    \n    public CreditCardPayment(String cardNumber, String cardHolder) {\n        this.cardNumber = cardNumber;\n        this.cardHolder = cardHolder;\n    }\n    \n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing credit card payment of $\" + amount);\n        System.out.println(\"Card: \" + cardNumber + \" (\" + cardHolder + \")\");\n    }\n    \n    @Override\n    public boolean validatePayment() {\n        boolean isValid = cardNumber != null && cardNumber.length() == 16;\n        System.out.println(\"Credit card validation: \" + (isValid ? \"PASS\" : \"FAIL\"));\n        return isValid;\n    }\n    \n    @Override\n    public void receipt() {\n        System.out.println(\"Credit Card Payment - Transaction Complete!\");\n    }\n}\n\nclass PayPalPayment implements Payment {\n    private String email;\n    \n    public PayPalPayment(String email) {\n        this.email = email;\n    }\n    \n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing PayPal payment of $\" + amount);\n        System.out.println(\"Email: \" + email);\n    }\n    \n    @Override\n    public boolean validatePayment() {\n        boolean isValid = email != null && email.contains(\"@\");\n        System.out.println(\"PayPal validation: \" + (isValid ? \"PASS\" : \"FAIL\"));\n        return isValid;\n    }\n}\n\n// Real-world example: Vehicle system\ninterface Vehicle {\n    void start();\n    void stop();\n    void accelerate();\n    \n    default void honk() {\n        System.out.println(\"Beep Beep!\");\n    }\n    \n    static void showVehicleTypes() {\n        System.out.println(\"Car, Motorcycle, Truck, Bus\");\n    }\n}\n\ninterface ElectricVehicle extends Vehicle {\n    void chargeBattery();\n    int getBatteryLevel();\n    \n    @Override\n    default void start() {\n        System.out.println(\"Electric vehicle starting silently...\");\n    }\n}\n\nclass ElectricCar implements ElectricVehicle {\n    private int batteryLevel;\n    \n    public ElectricCar() {\n        this.batteryLevel = 100;\n    }\n    \n    @Override\n    public void start() {\n        System.out.println(\"Electric car powered on!\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(\"Electric car powered off!\");\n    }\n    \n    @Override\n    public void accelerate() {\n        if (batteryLevel > 0) {\n            batteryLevel -= 5;\n            System.out.println(\"Electric car accelerating silently! Battery: \" + batteryLevel + \"%\");\n        } else {\n            System.out.println(\"Cannot accelerate: Low battery!\");\n        }\n    }\n    \n    @Override\n    public void chargeBattery() {\n        batteryLevel = 100;\n        System.out.println(\"Battery fully charged!\");\n    }\n    \n    @Override\n    public int getBatteryLevel() {\n        return batteryLevel;\n    }\n}\n\npublic class InterfacesDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Interfaces Demonstration ===\\n\");\n        \n        System.out.println(\"=== Basic Interface Usage ===\");\n        \n        // Using interface type references\n        Drawable circle = new Circle(5.0);\n        Drawable rectangle = new Rectangle(4.0, 6.0);\n        \n        circle.draw();\n        System.out.println(\"Circle area: \" + circle.calculateArea());\n        circle.displayType();  // Default method\n        \n        rectangle.draw();\n        System.out.println(\"Rectangle area: \" + rectangle.calculateArea());\n        \n        // Static interface method\n        Drawable.showDrawingTools();\n        \n        System.out.println(\"\\n=== Multiple Interfaces ===\");\n        \n        Rectangle rect = new Rectangle(3.0, 4.0);\n        rect.draw();\n        rect.resize(2.0);  // Double size\n        rect.doubleSize();  // Default method\n        \n        System.out.println(\"\\n=== Extended Interface ===\");\n        \n        Colored coloredCircle = new ColoredCircle(3.0, \"Red\");\n        coloredCircle.draw();\n        coloredCircle.setColor(\"Blue\");\n        coloredCircle.makeTransparent();  // Default method from extended interface\n        \n        System.out.println(\"\\n=== Real-world: Payment System ===\");\n        \n        Payment.showSupportedPayments();\n        \n        Payment[] payments = {\n            new CreditCardPayment(\"1234567812345678\", \"John Doe\"),\n            new PayPalPayment(\"user@example.com\")\n        };\n        \n        double amount = 100.0;\n        for (Payment payment : payments) {\n            if (payment.validatePayment()) {\n                payment.processPayment(amount);\n                payment.receipt();\n            }\n            System.out.println();\n        }\n        \n        System.out.println(\"=== Real-world: Electric Vehicle ===\");\n        \n        ElectricVehicle tesla = new ElectricCar();\n        tesla.start();\n        tesla.accelerate();\n        tesla.accelerate();\n        tesla.honk();\n        System.out.println(\"Battery level: \" + tesla.getBatteryLevel() + \"%\");\n        tesla.chargeBattery();\n        tesla.stop();\n        \n        System.out.println(\"\\n=== Functional Interfaces and Lambdas ===\");\n        \n        // Using functional interface with lambda expressions\n        Calculator addition = (a, b) -> a + b;\n        Calculator multiplication = (a, b) -> a * b;\n        Calculator division = (a, b) -> b != 0 ? a / b : 0;\n        \n        System.out.println(\"5 + 3 = \" + addition.calculate(5, 3));\n        System.out.println(\"5 * 3 = \" + multiplication.calculate(5, 3));\n        System.out.println(\"10 / 2 = \" + division.calculate(10, 2));\n        \n        // Using static factory method\n        Calculator add = Calculator.createAddition();\n        System.out.println(\"7 + 8 = \" + add.calculate(7, 8));\n        \n        // Validator example\n        Validator emailValidator = email -> email != null && email.contains(\"@\");\n        Validator lengthValidator = str -> str != null && str.length() >= 5;\n        \n        Validator combinedValidator = emailValidator.and(lengthValidator);\n        \n        System.out.println(\"\\nEmail validation:\");\n        System.out.println(\"test@example.com: \" + combinedValidator.isValid(\"test@example.com\"));\n        System.out.println(\"short: \" + combinedValidator.isValid(\"short\"));\n        \n        System.out.println(\"\\n=== Interface Polymorphism ===\");\n        \n        // Array of different types implementing same interface\n        Drawable[] drawables = {\n            new Circle(7.0),\n            new Rectangle(5.0, 3.0),\n            new ColoredCircle(4.0, \"Green\")\n        };\n        \n        System.out.println(\"Drawing all shapes:\");\n        for (Drawable drawable : drawables) {\n            drawable.draw();\n            System.out.println(\"Area: \" + drawable.calculateArea());\n        }\n        \n        System.out.println(\"\\n=== instanceof with Interfaces ===\");\n        \n        for (Drawable drawable : drawables) {\n            if (drawable instanceof Resizable) {\n                System.out.println(\"This shape is resizable\");\n            }\n            if (drawable instanceof Colored) {\n                System.out.println(\"This shape is colored: \" + ((Colored) drawable).getColor());\n            }\n        }\n        \n        System.out.println(\"\\n=== Benefits of Interfaces ===\");\n        System.out.println(\"1. Multiple Inheritance: Classes can implement multiple interfaces\");\n        System.out.println(\"2. Loose Coupling: Depend on interfaces, not implementations\");\n        System.out.println(\"3. Polymorphism: Treat different objects uniformly\");\n        System.out.println(\"4. Testability: Easy to mock interfaces for testing\");\n        System.out.println(\"5. Extensibility: Easy to add new implementations\");\n    }\n}",
                                      "real_world_example": "Interfaces are fundamental in enterprise Java development. The Java Collections Framework uses interfaces like List, Set, and Map. JDBC uses interfaces like Connection, Statement, and ResultSet. Spring Framework heavily uses interfaces for dependency injection. JPA uses interfaces for entity management. REST APIs use interfaces for controllers and services. Microservices communicate through interface-based APIs. Testing frameworks use interfaces for mocking. Payment gateways, notification systems, and data access layers all rely on interfaces for flexibility and testability.",
                                      "interactive_tasks": [
                                        "Create a Logger interface with methods for different log levels and implement FileLogger and ConsoleLogger",
                                        "Write a Sortable interface with sort() method and implement BubbleSort and QuickSort classes",
                                        "Create a Notification interface and implement Email, SMS, and Push notification classes"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "What is an interface?",
                                          "options": ["Contract of methods classes must implement", "Class with implementation", "Abstract class", "Final class"],
                                          "answer": "Contract of methods classes must implement",
                                          "reasoning": "Interface defines method signatures that implementing classes must provide."
                                        },
                                        {
                                          "question": "Can a class implement multiple interfaces?",
                                          "options": ["Yes", "No", "Only two", "Only if abstract"],
                                          "answer": "Yes",
                                          "reasoning": "Java classes can implement multiple interfaces."
                                        },
                                        {
                                          "question": "What are default methods?",
                                          "options": ["Methods with implementation in interfaces", "Abstract methods", "Static methods", "Private methods"],
                                          "answer": "Methods with implementation in interfaces",
                                          "reasoning": "Default methods provide implementation in interfaces (Java 8+)."
                                        },
                                        {
                                          "question": "Can interfaces have fields?",
                                          "options": ["Yes, only constants", "No", "Yes, any fields", "Only static fields"],
                                          "answer": "Yes, only constants",
                                          "reasoning": "Interface fields are implicitly public static final (constants)."
                                        },
                                        {
                                          "question": "What is a functional interface?",
                                          "options": ["Interface with one abstract method", "Interface with no methods", "Interface with default methods", "Abstract class"],
                                          "answer": "Interface with one abstract method",
                                          "reasoning": "Functional interfaces have exactly one abstract method for lambdas."
                                        },
                                        {
                                          "question": "Can interfaces extend other interfaces?",
                                          "options": ["Yes", "No", "Only one", "Only if same package"],
                                          "answer": "Yes",
                                          "reasoning": "Interfaces can extend multiple other interfaces."
                                        },
                                        {
                                          "question": "What is the main benefit of using interfaces?",
                                          "options": ["Loose coupling and polymorphism", "Faster execution", "Smaller code", "Easier inheritance"],
                                          "answer": "Loose coupling and polymorphism",
                                          "reasoning": "Interfaces enable loose coupling and treat different implementations polymorphically."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 29 – Collections Framework (ArrayList, HashMap, etc.)",
                                      "definition": "The Java Collections Framework is a unified architecture for representing and manipulating collections, providing common data structures like lists, sets, and maps with ready-to-use implementations.",
                                      "explanation": "Think of the Collections Framework like a well-organized toolbox with different containers for different purposes. ArrayList is like a flexible bookshelf where you can easily add/remove books. HashMap is like a dictionary where you can quickly look up words. HashSet is like a unique item collection that doesn't allow duplicates. These collections save you from writing complex data structures from scratch and provide optimized, tested implementations for common programming needs.",
                                      "code_example": "// Demonstrating Java Collections Framework\nimport java.util.*;\n\npublic class CollectionsDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Java Collections Framework ===\\n\");\n        \n        System.out.println(\"=== ArrayList Demonstration ===\\n\");\n        \n        // ArrayList - dynamic array\n        ArrayList<String> fruits = new ArrayList<>();\n        \n        // Adding elements\n        fruits.add(\"Apple\");\n        fruits.add(\"Banana\");\n        fruits.add(\"Orange\");\n        fruits.add(\"Mango\");\n        fruits.add(\"Grape\");\n        \n        System.out.println(\"Fruits: \" + fruits);\n        System.out.println(\"Size: \" + fruits.size());\n        System.out.println(\"First fruit: \" + fruits.get(0));\n        System.out.println(\"Contains 'Apple': \" + fruits.contains(\"Apple\"));\n        \n        // Modifying ArrayList\n        fruits.set(1, \"Blueberry\");  // Replace Banana with Blueberry\n        System.out.println(\"After modification: \" + fruits);\n        \n        fruits.remove(\"Orange\");  // Remove by object\n        fruits.remove(2);         // Remove by index\n        System.out.println(\"After removal: \" + fruits);\n        \n        // Iterating through ArrayList\n        System.out.println(\"\\nIterating with for-each:\");\n        for (String fruit : fruits) {\n            System.out.println(\" - \" + fruit);\n        }\n        \n        System.out.println(\"\\nIterating with iterator:\");\n        Iterator<String> iterator = fruits.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(\" * \" + iterator.next());\n        }\n        \n        // Sorting\n        Collections.sort(fruits);\n        System.out.println(\"\\nSorted fruits: \" + fruits);\n        \n        System.out.println(\"\\n=== LinkedList Demonstration ===\\n\");\n        \n        // LinkedList - efficient for add/remove at ends\n        LinkedList<Integer> numbers = new LinkedList<>();\n        \n        numbers.add(10);\n        numbers.add(20);\n        numbers.addFirst(5);   // Add at beginning\n        numbers.addLast(30);   // Add at end\n        \n        System.out.println(\"Numbers: \" + numbers);\n        System.out.println(\"First: \" + numbers.getFirst());\n        System.out.println(\"Last: \" + numbers.getLast());\n        \n        numbers.removeFirst();\n        numbers.removeLast();\n        System.out.println(\"After removing first and last: \" + numbers);\n        \n        System.out.println(\"\\n=== HashSet Demonstration ===\\n\");\n        \n        // HashSet - no duplicates, no order\n        HashSet<String> uniqueNames = new HashSet<>();\n        \n        uniqueNames.add(\"John\");\n        uniqueNames.add(\"Jane\");\n        uniqueNames.add(\"John\");  // Duplicate - won't be added\n        uniqueNames.add(\"Bob\");\n        uniqueNames.add(\"Alice\");\n        \n        System.out.println(\"Unique names: \" + uniqueNames);\n        System.out.println(\"Size: \" + uniqueNames.size());\n        System.out.println(\"Contains 'John': \" + uniqueNames.contains(\"John\"));\n        \n        // Iterating HashSet\n        System.out.println(\"\\nHashSet elements:\");\n        for (String name : uniqueNames) {\n            System.out.println(\" - \" + name);\n        }\n        \n        System.out.println(\"\\n=== HashMap Demonstration ===\\n\");\n        \n        // HashMap - key-value pairs\n        HashMap<String, Integer> studentGrades = new HashMap<>();\n        \n        // Adding key-value pairs\n        studentGrades.put(\"Alice\", 85);\n        studentGrades.put(\"Bob\", 92);\n        studentGrades.put(\"Charlie\", 78);\n        studentGrades.put(\"Diana\", 95);\n        \n        System.out.println(\"Student grades: \" + studentGrades);\n        System.out.println(\"Alice's grade: \" + studentGrades.get(\"Alice\"));\n        System.out.println(\"Contains key 'Bob': \" + studentGrades.containsKey(\"Bob\"));\n        System.out.println(\"Contains value 100: \" + studentGrades.containsValue(100));\n        \n        // Updating values\n        studentGrades.put(\"Charlie\", 82);  // Update existing key\n        System.out.println(\"After update: \" + studentGrades);\n        \n        // Removing entry\n        studentGrades.remove(\"Diana\");\n        System.out.println(\"After removal: \" + studentGrades);\n        \n        // Iterating HashMap\n        System.out.println(\"\\nIterating HashMap:\");\n        for (String name : studentGrades.keySet()) {\n            System.out.println(name + \" : \" + studentGrades.get(name));\n        }\n        \n        System.out.println(\"\\nEntry set iteration:\");\n        for (Map.Entry<String, Integer> entry : studentGrades.entrySet()) {\n            System.out.println(entry.getKey() + \" -> \" + entry.getValue());\n        }\n        \n        System.out.println(\"\\n=== TreeSet Demonstration ===\\n\");\n        \n        // TreeSet - sorted set\n        TreeSet<Integer> sortedNumbers = new TreeSet<>();\n        \n        sortedNumbers.add(50);\n        sortedNumbers.add(20);\n        sortedNumbers.add(80);\n        sortedNumbers.add(10);\n        sortedNumbers.add(30);\n        \n        System.out.println(\"Sorted numbers: \" + sortedNumbers);\n        System.out.println(\"First: \" + sortedNumbers.first());\n        System.out.println(\"Last: \" + sortedNumbers.last());\n        System.out.println(\"Numbers less than 30: \" + sortedNumbers.headSet(30));\n        System.out.println(\"Numbers greater than or equal to 30: \" + sortedNumbers.tailSet(30));\n        \n        System.out.println(\"\\n=== Stack and Queue Demonstration ===\\n\");\n        \n        // Stack - LIFO (Last In First Out)\n        Stack<String> stack = new Stack<>();\n        stack.push(\"First\");\n        stack.push(\"Second\");\n        stack.push(\"Third\");\n        \n        System.out.println(\"Stack: \" + stack);\n        System.out.println(\"Top element: \" + stack.peek());\n        System.out.println(\"Popped: \" + stack.pop());\n        System.out.println(\"Stack after pop: \" + stack);\n        \n        // Queue - FIFO (First In First Out)\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(\"First\");\n        queue.offer(\"Second\");\n        queue.offer(\"Third\");\n        \n        System.out.println(\"\\nQueue: \" + queue);\n        System.out.println(\"Front element: \" + queue.peek());\n        System.out.println(\"Removed: \" + queue.poll());\n        System.out.println(\"Queue after removal: \" + queue);\n        \n        System.out.println(\"\\n=== Practical Examples ===\\n\");\n        \n        // Example 1: Student Management\n        System.out.println(\"=== Student Management Example ===\");\n        \n        HashMap<String, ArrayList<Integer>> studentScores = new HashMap<>();\n        \n        // Add students with their scores\n        studentScores.put(\"Alice\", new ArrayList<>(Arrays.asList(85, 92, 78)));\n        studentScores.put(\"Bob\", new ArrayList<>(Arrays.asList(76, 88, 90)));\n        studentScores.put(\"Charlie\", new ArrayList<>(Arrays.asList(92, 95, 87)));\n        \n        // Calculate and display averages\n        for (String student : studentScores.keySet()) {\n            ArrayList<Integer> scores = studentScores.get(student);\n            double average = scores.stream().mapToInt(Integer::intValue).average().orElse(0.0);\n            System.out.println(student + \"'s average: \" + String.format(\"%.2f\", average));\n        }\n        \n        // Example 2: Word Frequency Counter\n        System.out.println(\"\\n=== Word Frequency Counter ===\");\n        \n        String text = \"hello world hello java world programming java hello\";\n        String[] words = text.split(\" \");\n        \n        HashMap<String, Integer> wordCount = new HashMap<>();\n        \n        for (String word : words) {\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n        }\n        \n        System.out.println(\"Word frequencies:\");\n        for (Map.Entry<String, Integer> entry : wordCount.entrySet()) {\n            System.out.println(entry.getKey() + \": \" + entry.getValue());\n        }\n        \n        // Example 3: Unique Values\n        System.out.println(\"\\n=== Unique Values Example ===\");\n        \n        ArrayList<Integer> numbersWithDuplicates = new ArrayList<>(Arrays.asList(1, 2, 2, 3, 4, 4, 4, 5, 5));\n        HashSet<Integer> uniqueNumbers = new HashSet<>(numbersWithDuplicates);\n        \n        System.out.println(\"Original list: \" + numbersWithDuplicates);\n        System.out.println(\"Unique numbers: \" + uniqueNumbers);\n        \n        System.out.println(\"\\n=== Collection Operations ===\");\n        \n        // Collection utility methods\n        ArrayList<Integer> list1 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));\n        ArrayList<Integer> list2 = new ArrayList<>(Arrays.asList(4, 5, 6, 7, 8));\n        \n        System.out.println(\"List 1: \" + list1);\n        System.out.println(\"List 2: \" + list2);\n        \n        // Union\n        HashSet<Integer> union = new HashSet<>(list1);\n        union.addAll(list2);\n        System.out.println(\"Union: \" + union);\n        \n        // Intersection\n        HashSet<Integer> intersection = new HashSet<>(list1);\n        intersection.retainAll(list2);\n        System.out.println(\"Intersection: \" + intersection);\n        \n        // Difference\n        HashSet<Integer> difference = new HashSet<>(list1);\n        difference.removeAll(list2);\n        System.out.println(\"Difference (list1 - list2): \" + difference);\n        \n        System.out.println(\"\\n=== Choosing the Right Collection ===\");\n        System.out.println(\"• ArrayList: When you need fast random access\");\n        System.out.println(\"• LinkedList: When you need frequent add/remove at ends\");\n        System.out.println(\"• HashSet: When you need unique elements, no order\");\n        System.out.println(\"• TreeSet: When you need unique elements, sorted\");\n        System.out.println(\"• HashMap: When you need key-value pairs, fast lookup\");\n        System.out.println(\"• TreeMap: When you need sorted key-value pairs\");\n        System.out.println(\"• Stack: When you need LIFO behavior\");\n        System.out.println(\"• Queue: When you need FIFO behavior\");\n    }\n}",
                                      "real_world_example": "The Collections Framework is used everywhere in Java applications. E-commerce sites use ArrayList for shopping carts and HashMap for product catalogs. Social media apps use HashSet for tracking likes and follows. Banking systems use TreeSet for sorted transactions. Cache systems use HashMap for fast lookups. Task schedulers use Queue for processing jobs. Configuration systems use Properties (which extends Hashtable). Database results are often stored in ArrayList. Understanding collections is essential for efficient data handling in any Java application.",
                                      "interactive_tasks": [
                                        "Create a program that counts character frequencies in a string using HashMap",
                                        "Write a program that removes duplicates from a list using HashSet",
                                        "Create a simple phone book using HashMap to store name-phone number pairs"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "Which collection maintains insertion order?",
                                          "options": ["ArrayList", "HashSet", "HashMap", "TreeSet"],
                                          "answer": "ArrayList",
                                          "reasoning": "ArrayList maintains the order in which elements are inserted."
                                        },
                                        {
                                          "question": "Which collection does not allow duplicates?",
                                          "options": ["HashSet", "ArrayList", "LinkedList", "All allow duplicates"],
                                          "answer": "HashSet",
                                          "reasoning": "HashSet stores unique elements only, no duplicates allowed."
                                        },
                                        {
                                          "question": "What is the time complexity of HashMap get()?",
                                          "options": ["O(1)", "O(n)", "O(log n)", "O(n²)"],
                                          "answer": "O(1)",
                                          "reasoning": "HashMap provides constant time performance for basic operations."
                                        },
                                        {
                                          "question": "Which collection is best for frequent add/remove at both ends?",
                                          "options": ["LinkedList", "ArrayList", "HashSet", "TreeSet"],
                                          "answer": "LinkedList",
                                          "reasoning": "LinkedList provides O(1) time for add/remove at both ends."
                                        },
                                        {
                                          "question": "What does TreeSet provide?",
                                          "options": ["Sorted unique elements", "Fast random access", "Key-value pairs", "Duplicate elements"],
                                          "answer": "Sorted unique elements",
                                          "reasoning": "TreeSet maintains elements in sorted order without duplicates."
                                        },
                                        {
                                          "question": "How to iterate through HashMap entries?",
                                          "options": ["entrySet()", "keySet()", "values()", "All of the above"],
                                          "answer": "All of the above",
                                          "reasoning": "HashMap can be iterated using entrySet, keySet, or values."
                                        },
                                        {
                                          "question": "What is the difference between ArrayList and Vector?",
                                          "options": ["ArrayList is not synchronized", "Vector is faster", "ArrayList allows nulls", "Vector is deprecated"],
                                          "answer": "ArrayList is not synchronized",
                                          "reasoning": "ArrayList is not thread-safe, while Vector is synchronized."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 30 – Exception Handling",
                                      "definition": "Exception handling is a mechanism to handle runtime errors gracefully, allowing programs to continue execution or terminate properly when unexpected situations occur.",
                                      "explanation": "Think of exception handling like airbags in a car - they don't prevent accidents, but they protect you when something goes wrong. Exceptions are events that disrupt the normal flow of program execution. Java provides try-catch blocks to 'try' risky code and 'catch' any exceptions that occur. You can also 'throw' exceptions to signal problems and 'finally' execute cleanup code regardless of what happens. Proper exception handling makes your programs more robust and user-friendly.",
                                      "code_example": "// Demonstrating exception handling in Java\n\npublic class ExceptionHandlingDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Exception Handling Demonstration ===\\n\");\n        \n        System.out.println(\"=== Basic Try-Catch ===\\n\");\n        \n        // Basic try-catch\n        try {\n            int result = 10 / 0;  // This will cause ArithmeticException\n            System.out.println(\"Result: \" + result);\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error: Cannot divide by zero!\");\n            System.out.println(\"Exception message: \" + e.getMessage());\n        }\n        \n        System.out.println(\"\\nProgram continues after handling exception...\\n\");\n        \n        System.out.println(\"=== Multiple Catch Blocks ===\\n\");\n        \n        // Multiple catch blocks\n        try {\n            String text = null;\n            System.out.println(text.length());  // NullPointerException\n            \n            int[] numbers = {1, 2, 3};\n            System.out.println(numbers[5]);     // ArrayIndexOutOfBoundsException\n            \n        } catch (NullPointerException e) {\n            System.out.println(\"NullPointerException caught: \" + e.getMessage());\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"ArrayIndexOutOfBoundsException caught: \" + e.getMessage());\n        } catch (Exception e) {\n            System.out.println(\"General exception caught: \" + e.getMessage());\n        }\n        \n        System.out.println(\"\\n=== Finally Block ===\\n\");\n        \n        // Finally block - always executes\n        try {\n            int[] array = {1, 2, 3};\n            System.out.println(\"Array element: \" + array[1]);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"Array index error: \" + e.getMessage());\n        } finally {\n            System.out.println(\"This finally block always executes!\");\n        }\n        \n        System.out.println(\"\\n=== Checked vs Unchecked Exceptions ===\\n\");\n        \n        // Unchecked exception (RuntimeException) - not required to handle\n        try {\n            throw new RuntimeException(\"This is an unchecked exception\");\n        } catch (RuntimeException e) {\n            System.out.println(\"Caught unchecked exception: \" + e.getMessage());\n        }\n        \n        // Checked exception - must be handled or declared\n        try {\n            readFile(\"nonexistent.txt\");\n        } catch (Exception e) {\n            System.out.println(\"Caught checked exception: \" + e.getMessage());\n        }\n        \n        System.out.println(\"\\n=== Custom Exception ===\\n\");\n        \n        // Using custom exception\n        try {\n            validateAge(15);  // This will throw our custom exception\n        } catch (InvalidAgeException e) {\n            System.out.println(\"Custom exception caught: \" + e.getMessage());\n            System.out.println(\"Invalid age: \" + e.getInvalidAge());\n        }\n        \n        System.out.println(\"\\n=== Exception Propagation ===\\n\");\n        \n        // Exception propagation through method calls\n        try {\n            methodA();\n        } catch (Exception e) {\n            System.out.println(\"Exception caught in main: \" + e.getMessage());\n            System.out.println(\"Stack trace:\");\n            e.printStackTrace();\n        }\n        \n        System.out.println(\"\\n=== Try-with-Resources ===\\n\");\n        \n        // Try-with-resources (Java 7+)\n        try (MyResource resource = new MyResource()) {\n            resource.useResource();\n            // Resource automatically closed even if exception occurs\n        } catch (Exception e) {\n            System.out.println(\"Exception in try-with-resources: \" + e.getMessage());\n        }\n        \n        System.out.println(\"\\n=== Practical Examples ===\\n\");\n        \n        // Example 1: Number parsing with exception handling\n        System.out.println(\"=== Number Parsing Example ===\");\n        \n        String[] numberStrings = {\"123\", \"45.67\", \"abc\", \"789\"};\n        \n        for (String str : numberStrings) {\n            try {\n                int number = Integer.parseInt(str);\n                System.out.println(\"Parsed number: \" + number);\n            } catch (NumberFormatException e) {\n                System.out.println(\"Cannot parse '\" + str + \"' as integer: \" + e.getMessage());\n            }\n        }\n        \n        // Example 2: Bank account with exception handling\n        System.out.println(\"\\n=== Bank Account Example ===\");\n        \n        BankAccount account = new BankAccount(\"ACC123\", 1000.0);\n        \n        try {\n            account.withdraw(1500.0);  // This should fail\n        } catch (InsufficientFundsException e) {\n            System.out.println(\"Bank error: \" + e.getMessage());\n            System.out.println(\"Current balance: $\" + e.getCurrentBalance());\n            System.out.println(\"Requested amount: $\" + e.getRequestedAmount());\n        }\n        \n        try {\n            account.deposit(-100.0);  // Invalid amount\n        } catch (InvalidAmountException e) {\n            System.out.println(\"Deposit error: \" + e.getMessage());\n        }\n        \n        System.out.println(\"\\n=== Best Practices ===\");\n        System.out.println(\"• Catch specific exceptions before general ones\");\n        System.out.println(\"• Don't catch exceptions you can't handle\");\n        System.out.println(\"• Use finally for cleanup operations\");\n        System.out.println(\"• Provide meaningful exception messages\");\n        System.out.println(\"• Use try-with-resources for AutoCloseable objects\");\n        System.out.println(\"• Don't ignore exceptions in catch blocks\");\n    }\n    \n    // Method that throws a checked exception\n    public static void readFile(String filename) throws Exception {\n        // Simulating file reading that might fail\n        if (!filename.equals(\"existing.txt\")) {\n            throw new Exception(\"File not found: \" + filename);\n        }\n        System.out.println(\"Reading file: \" + filename);\n    }\n    \n    // Method using custom exception\n    public static void validateAge(int age) throws InvalidAgeException {\n        if (age < 18) {\n            throw new InvalidAgeException(\"Age must be 18 or older\", age);\n        }\n        System.out.println(\"Age validated: \" + age);\n    }\n    \n    // Method demonstrating exception propagation\n    public static void methodA() {\n        methodB();\n    }\n    \n    public static void methodB() {\n        methodC();\n    }\n    \n    public static void methodC() {\n        throw new RuntimeException(\"Exception thrown in methodC\");\n    }\n}\n\n// Custom exception class\nclass InvalidAgeException extends Exception {\n    private int invalidAge;\n    \n    public InvalidAgeException(String message, int invalidAge) {\n        super(message);\n        this.invalidAge = invalidAge;\n    }\n    \n    public int getInvalidAge() {\n        return invalidAge;\n    }\n}\n\n// Another custom exception\nclass InsufficientFundsException extends Exception {\n    private double currentBalance;\n    private double requestedAmount;\n    \n    public InsufficientFundsException(String message, double currentBalance, double requestedAmount) {\n        super(message);\n        this.currentBalance = currentBalance;\n        this.requestedAmount = requestedAmount;\n    }\n    \n    public double getCurrentBalance() {\n        return currentBalance;\n    }\n    \n    public double getRequestedAmount() {\n        return requestedAmount;\n    }\n}\n\nclass InvalidAmountException extends Exception {\n    public InvalidAmountException(String message) {\n        super(message);\n    }\n}\n\n// Resource class for try-with-resources demonstration\nclass MyResource implements AutoCloseable {\n    public void useResource() {\n        System.out.println(\"Using the resource...\");\n        // Simulate something that might work or fail\n        if (Math.random() > 0.5) {\n            throw new RuntimeException(\"Resource operation failed!\");\n        }\n        System.out.println(\"Resource operation successful!\");\n    }\n    \n    @Override\n    public void close() {\n        System.out.println(\"Resource closed automatically!\");\n    }\n}\n\n// Bank account class with exception handling\nclass BankAccount {\n    private String accountNumber;\n    private double balance;\n    \n    public BankAccount(String accountNumber, double initialBalance) {\n        this.accountNumber = accountNumber;\n        this.balance = initialBalance;\n    }\n    \n    public void deposit(double amount) throws InvalidAmountException {\n        if (amount <= 0) {\n            throw new InvalidAmountException(\"Deposit amount must be positive: $\" + amount);\n        }\n        balance += amount;\n        System.out.println(\"Deposited: $\" + amount + \", New balance: $\" + balance);\n    }\n    \n    public void withdraw(double amount) throws InsufficientFundsException {\n        if (amount <= 0) {\n            throw new IllegalArgumentException(\"Withdrawal amount must be positive\");\n        }\n        \n        if (amount > balance) {\n            throw new InsufficientFundsException(\"Insufficient funds for withdrawal\", balance, amount);\n        }\n        \n        balance -= amount;\n        System.out.println(\"Withdrawn: $\" + amount + \", New balance: $\" + balance);\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n    \n    public String getAccountNumber() {\n        return accountNumber;\n    }\n}\n\n// Exception hierarchy demonstration\nclass ExceptionHierarchyDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Exception Hierarchy ===\\n\");\n        \n        // Throwable is the superclass of all errors and exceptions\n        // ├── Error (serious problems that should not be caught)\n        // │   ├── OutOfMemoryError\n        // │   ├── StackOverflowError\n        // │   └── ...\n        // └── Exception (problems that can be caught)\n        //     ├── RuntimeException (unchecked)\n        //     │   ├── NullPointerException\n        //     │   ├── ArrayIndexOutOfBoundsException\n        //     │   ├── IllegalArgumentException\n        //     │   └── ...\n        //     └── Other exceptions (checked)\n        //         ├── IOException\n        //         ├── SQLException\n        //         └── ...\n        \n        System.out.println(\"Common Exception Types:\");\n        System.out.println(\"• NullPointerException - accessing null object\");\n        System.out.println(\"• ArrayIndexOutOfBoundsException - invalid array index\");\n        System.out.println(\"• ArithmeticException - math errors like division by zero\");\n        System.out.println(\"• NumberFormatException - invalid number parsing\");\n        System.out.println(\"• IllegalArgumentException - invalid method argument\");\n        System.out.println(\"• IOException - input/output operations\");\n        System.out.println(\"• FileNotFoundException - file not found\");\n    }\n}",
                                      "real_world_example": "Exception handling is critical in real applications. Web applications handle exceptions to show user-friendly error pages instead of stack traces. Database applications handle SQL exceptions when connections fail or queries have errors. File processing applications handle IO exceptions when files are missing or corrupted. Network applications handle socket exceptions when connections time out. Payment systems handle custom exceptions for insufficient funds or invalid transactions. Proper exception handling ensures applications remain stable and provide good user experience even when things go wrong.",
                                      "interactive_tasks": [
                                        "Create a method that reads numbers from user input and handles invalid number format exceptions",
                                        "Write a file reader that handles FileNotFoundException and IOException",
                                        "Create a calculator class that throws custom exceptions for division by zero and invalid operations"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "What is the purpose of exception handling?",
                                          "options": ["Gracefully handle runtime errors", "Prevent all errors", "Make code faster", "Replace if-else statements"],
                                          "answer": "Gracefully handle runtime errors",
                                          "reasoning": "Exception handling allows programs to recover from or gracefully handle runtime errors."
                                        },
                                        {
                                          "question": "What is the difference between checked and unchecked exceptions?",
                                          "options": ["Checked must be handled, unchecked don't", "Checked are faster", "Unchecked are errors", "No difference"],
                                          "answer": "Checked must be handled, unchecked don't",
                                          "reasoning": "Checked exceptions must be caught or declared, unchecked exceptions (RuntimeException) don't."
                                        },
                                        {
                                          "question": "When does finally block execute?",
                                          "options": ["Always", "Only if no exception", "Only if exception", "Never if return in try"],
                                          "answer": "Always",
                                          "reasoning": "Finally block always executes regardless of whether exception occurred or not."
                                        },
                                        {
                                          "question": "What is try-with-resources?",
                                          "options": ["Automatic resource management", "Try block with resources", "Resource allocation", "Memory management"],
                                          "answer": "Automatic resource management",
                                          "reasoning": "Try-with-resources automatically closes resources that implement AutoCloseable."
                                        },
                                        {
                                          "question": "Can you have multiple catch blocks?",
                                          "options": ["Yes", "No", "Only two", "Only for checked exceptions"],
                                          "answer": "Yes",
                                          "reasoning": "You can have multiple catch blocks for different exception types."
                                        },
                                        {
                                          "question": "What should you catch first?",
                                          "options": ["Specific exceptions", "General Exception", "RuntimeException", "It doesn't matter"],
                                          "answer": "Specific exceptions",
                                          "answer": "Specific exceptions",
                                          "reasoning": "Catch specific exceptions before general ones to handle them appropriately."
                                        },
                                        {
                                          "question": "What is exception propagation?",
                                          "options": ["Exceptions moving up call stack", "Creating new exceptions", "Handling multiple exceptions", "Exception inheritance"],
                                          "answer": "Exceptions moving up call stack",
                                          "reasoning": "Exception propagation means exceptions move up through method calls until caught."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 31 – File Handling",
                                      "definition": "File handling involves reading from and writing to files using Java's I/O classes, allowing programs to persist data between executions and work with external data sources.",
                                      "explanation": "Think of file handling like using a notebook - you can write information to save it (writing files), read previous notes (reading files), add new information (appending), and organize your notes (file management). Java provides comprehensive file handling capabilities through classes like File, FileReader, FileWriter, BufferedReader, and Scanner. Understanding file I/O is essential for creating applications that need to save user data, read configuration files, process data files, or work with any persistent storage.",
                                      "code_example": "// Demonstrating file handling in Java\nimport java.io.*;\nimport java.nio.file.*;\nimport java.util.*;\n\npublic class FileHandlingDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== File Handling Demonstration ===\\n\");\n        \n        // Create a directory for our files\n        File directory = new File(\"file_demo\");\n        if (!directory.exists()) {\n            directory.mkdir();\n            System.out.println(\"Created directory: \" + directory.getAbsolutePath());\n        }\n        \n        System.out.println(\"=== Writing to Files ===\\n\");\n        \n        // Writing to file using FileWriter\n        try (FileWriter writer = new FileWriter(\"file_demo/sample.txt\")) {\n            writer.write(\"Hello, File Handling!\\n\");\n            writer.write(\"This is line 2.\\n\");\n            writer.write(\"This is line 3.\\n\");\n            writer.write(\"Java File I/O is powerful!\\n\");\n            System.out.println(\"File written successfully!\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing file: \" + e.getMessage());\n        }\n        \n        // Writing with BufferedWriter (more efficient)\n        try (BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(\"file_demo/buffered.txt\"))) {\n            bufferedWriter.write(\"This is written with BufferedWriter.\\n\");\n            bufferedWriter.write(\"It's more efficient for multiple writes.\\n\");\n            bufferedWriter.newLine();  // Platform-independent newline\n            bufferedWriter.write(\"End of file.\\n\");\n            System.out.println(\"Buffered file written successfully!\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing buffered file: \" + e.getMessage());\n        }\n        \n        System.out.println(\"\\n=== Reading from Files ===\\n\");\n        \n        // Reading using FileReader\n        System.out.println(\"Reading with FileReader:\");\n        try (FileReader reader = new FileReader(\"file_demo/sample.txt\")) {\n            int character;\n            while ((character = reader.read()) != -1) {\n                System.out.print((char) character);\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error reading file: \" + e.getMessage());\n        }\n        \n        // Reading with BufferedReader (more efficient)\n        System.out.println(\"\\nReading with BufferedReader:\");\n        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(\"file_demo/sample.txt\"))) {\n            String line;\n            int lineNumber = 1;\n            while ((line = bufferedReader.readLine()) != null) {\n                System.out.println(lineNumber + \": \" + line);\n                lineNumber++;\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error reading file: \" + e.getMessage());\n        }\n        \n        // Reading with Scanner\n        System.out.println(\"\\nReading with Scanner:\");\n        try (Scanner scanner = new Scanner(new File(\"file_demo/sample.txt\"))) {\n            int lineNumber = 1;\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                System.out.println(lineNumber + \": \" + line);\n                lineNumber++;\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(\"File not found: \" + e.getMessage());\n        }\n        \n        System.out.println(\"\\n=== Appending to Files ===\\n\");\n        \n        // Appending to existing file\n        try (FileWriter appendWriter = new FileWriter(\"file_demo/sample.txt\", true)) {\n            appendWriter.write(\"\\nThis line was appended!\\n\");\n            appendWriter.write(\"Appending is useful for logs.\\n\");\n            System.out.println(\"Content appended successfully!\");\n        } catch (IOException e) {\n            System.out.println(\"Error appending to file: \" + e.getMessage());\n        }\n        \n        System.out.println(\"\\n=== File Operations ===\\n\");\n        \n        File file = new File(\"file_demo/sample.txt\");\n        \n        // File information\n        System.out.println(\"File Information:\");\n        System.out.println(\"Name: \" + file.getName());\n        System.out.println(\"Path: \" + file.getPath());\n        System.out.println(\"Absolute Path: \" + file.getAbsolutePath());\n        System.out.println(\"Exists: \" + file.exists());\n        System.out.println(\"Is File: \" + file.isFile());\n        System.out.println(\"Is Directory: \" + file.isDirectory());\n        System.out.println(\"Readable: \" + file.canRead());\n        System.out.println(\"Writable: \" + file.canWrite());\n        System.out.println(\"Size: \" + file.length() + \" bytes\");\n        \n        // Create a new file\n        File newFile = new File(\"file_demo/newfile.txt\");\n        try {\n            if (newFile.createNewFile()) {\n                System.out.println(\"\\nNew file created: \" + newFile.getName());\n            } else {\n                System.out.println(\"\\nFile already exists.\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error creating file: \" + e.getMessage());\n        }\n        \n        // List files in directory\n        System.out.println(\"\\nFiles in directory:\");\n        File[] files = directory.listFiles();\n        if (files != null) {\n            for (File f : files) {\n                System.out.println(\" - \" + f.getName() + \" (\" + f.length() + \" bytes)\");\n            }\n        }\n        \n        System.out.println(\"\\n=== Practical Examples ===\\n\");\n        \n        // Example 1: Student data management\n        System.out.println(\"=== Student Data Management ===\");\n        \n        // Write student data\n        try (BufferedWriter studentWriter = new BufferedWriter(new FileWriter(\"file_demo/students.csv\"))) {\n            studentWriter.write(\"Name,Age,Grade\\n\");\n            studentWriter.write(\"Alice,20,A\\n\");\n            studentWriter.write(\"Bob,22,B\\n\");\n            studentWriter.write(\"Charlie,19,A\\n\");\n            studentWriter.write(\"Diana,21,C\\n\");\n            System.out.println(\"Student data written to CSV file.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing student data: \" + e.getMessage());\n        }\n        \n        // Read and process student data\n        System.out.println(\"\\nReading student data:\");\n        try (BufferedReader studentReader = new BufferedReader(new FileReader(\"file_demo/students.csv\"))) {\n            String line;\n            boolean isHeader = true;\n            while ((line = studentReader.readLine()) != null) {\n                if (isHeader) {\n                    isHeader = false;\n                    continue; // Skip header\n                }\n                String[] data = line.split(\",\");\n                System.out.println(\"Student: \" + data[0] + \", Age: \" + data[1] + \", Grade: \" + data[2]);\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error reading student data: \" + e.getMessage());\n        }\n        \n        // Example 2: Configuration file\n        System.out.println(\"\\n=== Configuration File Example ===\");\n        \n        // Write configuration\n        try (BufferedWriter configWriter = new BufferedWriter(new FileWriter(\"file_demo/config.properties\"))) {\n            configWriter.write(\"# Application Configuration\\n\");\n            configWriter.write(\"app.name=MyJavaApp\\n\");\n            configWriter.write(\"app.version=1.0.0\\n\");\n            configWriter.write(\"database.url=jdbc:mysql://localhost/mydb\\n\");\n            configWriter.write(\"database.user=admin\\n\");\n            configWriter.write(\"max.connections=10\\n\");\n            System.out.println(\"Configuration file created.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing config: \" + e.getMessage());\n        }\n        \n        // Read configuration\n        System.out.println(\"\\nReading configuration:\");\n        Properties config = new Properties();\n        try (FileInputStream configInput = new FileInputStream(\"file_demo/config.properties\")) {\n            config.load(configInput);\n            System.out.println(\"App Name: \" + config.getProperty(\"app.name\"));\n            System.out.println(\"Version: \" + config.getProperty(\"app.version\"));\n            System.out.println(\"Database URL: \" + config.getProperty(\"database.url\"));\n            System.out.println(\"Max Connections: \" + config.getProperty(\"max.connections\"));\n        } catch (IOException e) {\n            System.out.println(\"Error reading config: \" + e.getMessage());\n        }\n        \n        // Example 3: Log file\n        System.out.println(\"\\n=== Log File Example ===\");\n        \n        try (BufferedWriter logWriter = new BufferedWriter(new FileWriter(\"file_demo/app.log\", true))) {\n            String timestamp = new Date().toString();\n            logWriter.write(timestamp + \" - Application started\\n\");\n            logWriter.write(timestamp + \" - User logged in\\n\");\n            logWriter.write(timestamp + \" - Data processed successfully\\n\");\n            System.out.println(\"Log entries written.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing log: \" + e.getMessage());\n        }\n        \n        System.out.println(\"\\n=== Modern File Handling (NIO) ===\\n\");\n        \n        // Using Java NIO (New I/O) - more modern approach\n        try {\n            // Read all lines at once\n            List<String> lines = Files.readAllLines(Paths.get(\"file_demo/sample.txt\"));\n            System.out.println(\"Reading with NIO - All lines:\");\n            for (String line : lines) {\n                System.out.println(\"  \" + line);\n            }\n            \n            // Write with NIO\n            List<String> newLines = Arrays.asList(\"Line 1 from NIO\", \"Line 2 from NIO\", \"Line 3 from NIO\");\n            Files.write(Paths.get(\"file_demo/nio_demo.txt\"), newLines);\n            System.out.println(\"\\nFile written using NIO.\");\n            \n        } catch (IOException e) {\n            System.out.println(\"Error with NIO operations: \" + e.getMessage());\n        }\n        \n        System.out.println(\"\\n=== File Cleanup ===\\n\");\n        \n        // Clean up demo files (optional - comment out if you want to keep files)\n        System.out.println(\"Cleaning up demo files...\");\n        deleteDirectory(directory);\n        \n        System.out.println(\"\\n=== Best Practices ===\");\n        System.out.println(\"• Always use try-with-resources for automatic closing\");\n        System.out.println(\"• Handle IOException properly\");\n        System.out.println(\"• Use BufferedReader/BufferedWriter for efficiency\");\n        System.out.println(\"• Check file existence before operations\");\n        System.out.println(\"• Use relative paths for portability\");\n        System.out.println(\"• Consider using NIO for modern file operations\");\n    }\n    \n    // Helper method to delete directory recursively\n    private static void deleteDirectory(File directory) {\n        if (directory.exists()) {\n            File[] files = directory.listFiles();\n            if (files != null) {\n                for (File file : files) {\n                    if (file.isDirectory()) {\n                        deleteDirectory(file);\n                    } else {\n                        file.delete();\n                    }\n                }\n            }\n            directory.delete();\n        }\n    }\n}\n\n// Additional example: File utility class\nclass FileUtils {\n    \n    // Method to copy file\n    public static void copyFile(String sourcePath, String destPath) throws IOException {\n        try (InputStream in = new FileInputStream(sourcePath);\n             OutputStream out = new FileOutputStream(destPath)) {\n            \n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = in.read(buffer)) > 0) {\n                out.write(buffer, 0, length);\n            }\n        }\n    }\n    \n    // Method to count lines in file\n    public static int countLines(String filePath) throws IOException {\n        int lines = 0;\n        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n            while (reader.readLine() != null) {\n                lines++;\n            }\n        }\n        return lines;\n    }\n    \n    // Method to find file with largest size in directory\n    public static File findLargestFile(String directoryPath) {\n        File directory = new File(directoryPath);\n        if (!directory.isDirectory()) {\n            return null;\n        }\n        \n        File largestFile = null;\n        File[] files = directory.listFiles();\n        \n        if (files != null) {\n            for (File file : files) {\n                if (file.isFile()) {\n                    if (largestFile == null || file.length() > largestFile.length()) {\n                        largestFile = file;\n                    }\n                }\n            }\n        }\n        \n        return largestFile;\n    }\n}",
                                      "real_world_example": "File handling is essential in real applications. Configuration files store application settings. Log files record application events and errors. Data files store user information, products, or transactions. Import/export features read from and write to CSV, JSON, or XML files. Backup systems create copies of important data. Report generators create PDF or text reports. Image processing applications read and write image files. Database applications often use file-based databases. Understanding file I/O is crucial for building applications that need persistent storage.",
                                      "interactive_tasks": [
                                        "Create a program that reads a text file and counts the frequency of each word",
                                        "Write a program that copies a file while converting all text to uppercase",
                                        "Create a simple diary application that allows adding entries and reading previous entries"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "Which class is used for efficient reading of text files?",
                                          "options": ["BufferedReader", "FileReader", "Scanner", "FileInputStream"],
                                          "answer": "BufferedReader",
                                          "reasoning": "BufferedReader provides efficient reading of text data with buffering."
                                        },
                                        {
                                          "question": "What does try-with-resources do for file handling?",
                                          "options": ["Automatically closes resources", "Opens files faster", "Handles exceptions", "Creates backups"],
                                          "answer": "Automatically closes resources",
                                          "reasoning": "Try-with-resources automatically closes files and other resources."
                                        },
                                        {
                                          "question": "How to append to an existing file?",
                                          "options": ["Use FileWriter with true parameter", "Use append mode", "Use BufferedAppender", "Files are always appended"],
                                          "answer": "Use FileWriter with true parameter",
                                          "reasoning": "FileWriter constructor with true parameter enables append mode."
                                        },
                                        {
                                          "question": "Which exception is common in file operations?",
                                          "options": ["IOException", "NullPointerException", "ArithmeticException", "ArrayIndexOutOfBoundsException"],
                                          "answer": "IOException",
                                          "reasoning": "IOException is the base class for exceptions in I/O operations."
                                        },
                                        {
                                          "question": "What is the difference between FileReader and FileInputStream?",
                                          "options": ["FileReader for text, FileInputStream for bytes", "No difference", "FileReader is faster", "FileInputStream for text"],
                                          "answer": "FileReader for text, FileInputStream for bytes",
                                          "reasoning": "FileReader reads characters (text), FileInputStream reads bytes (binary)."
                                        },
                                        {
                                          "question": "How to check if a file exists?",
                                          "options": ["file.exists()", "file.isFile()", "file.canRead()", "file.length() > 0"],
                                          "answer": "file.exists()",
                                          "reasoning": "exists() method returns true if the file or directory exists."
                                        },
                                        {
                                          "question": "What is Java NIO?",
                                          "options": ["New I/O with better performance", "Network I/O only", "Old I/O", "Non-blocking I/O"],
                                          "answer": "New I/O with better performance",
                                          "reasoning": "NIO (New I/O) provides improved performance and additional features."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 32 – Mini Project: Student Management System",
                                      "definition": "A comprehensive Student Management System that combines all Java concepts learned so far to manage student records, courses, and grades in a console-based application.",
                                      "explanation": "This mini project is like building a small but complete application that brings together everything you've learned. We'll create a system that can add students, enroll them in courses, assign grades, generate reports, and persist data to files. This project demonstrates real-world programming patterns like separation of concerns, data encapsulation, exception handling, and file I/O. You'll see how all the individual concepts work together to create a functional application.",
                                      "code_example": "// Mini Project: Student Management System\n\nimport java.io.*;\nimport java.util.*;\n\n// Custom exception for student operations\nclass StudentManagementException extends Exception {\n    public StudentManagementException(String message) {\n        super(message);\n    }\n}\n\n// Student class\nclass Student {\n    private String studentId;\n    private String name;\n    private int age;\n    private String email;\n    private HashMap<String, Double> courses; // courseName -> grade\n    \n    public Student(String studentId, String name, int age, String email) {\n        this.studentId = studentId;\n        this.name = name;\n        this.age = age;\n        this.email = email;\n        this.courses = new HashMap<>();\n    }\n    \n    // Getters\n    public String getStudentId() { return studentId; }\n    public String getName() { return name; }\n    public int getAge() { return age; }\n    public String getEmail() { return email; }\n    public HashMap<String, Double> getCourses() { return new HashMap<>(courses); }\n    \n    // Setters with validation\n    public void setName(String name) {\n        if (name != null && !name.trim().isEmpty()) {\n            this.name = name;\n        }\n    }\n    \n    public void setAge(int age) {\n        if (age >= 0 && age <= 120) {\n            this.age = age;\n        }\n    }\n    \n    public void setEmail(String email) {\n        if (email != null && email.contains(\"@\")) {\n            this.email = email;\n        }\n    }\n    \n    // Course management\n    public void enrollCourse(String courseName) {\n        if (courseName != null && !courseName.trim().isEmpty()) {\n            courses.put(courseName, null); // null means no grade assigned yet\n        }\n    }\n    \n    public void assignGrade(String courseName, double grade) throws StudentManagementException {\n        if (!courses.containsKey(courseName)) {\n            throw new StudentManagementException(\"Student is not enrolled in course: \" + courseName);\n        }\n        if (grade < 0 || grade > 100) {\n            throw new StudentManagementException(\"Grade must be between 0 and 100\");\n        }\n        courses.put(courseName, grade);\n    }\n    \n    public double calculateGPA() {\n        if (courses.isEmpty()) return 0.0;\n        \n        double total = 0.0;\n        int count = 0;\n        \n        for (Double grade : courses.values()) {\n            if (grade != null) {\n                total += grade;\n                count++;\n            }\n        }\n        \n        return count > 0 ? total / count : 0.0;\n    }\n    \n    public String getLetterGrade(double grade) {\n        if (grade >= 90) return \"A\";\n        else if (grade >= 80) return \"B\";\n        else if (grade >= 70) return \"C\";\n        else if (grade >= 60) return \"D\";\n        else return \"F\";\n    }\n    \n    public void displayStudentInfo() {\n        System.out.println(\"=== Student Information ===\");\n        System.out.println(\"ID: \" + studentId);\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Age: \" + age);\n        System.out.println(\"Email: \" + email);\n        System.out.println(\"GPA: \" + String.format(\"%.2f\", calculateGPA()));\n        \n        System.out.println(\"\\nCourses and Grades:\");\n        if (courses.isEmpty()) {\n            System.out.println(\"  No courses enrolled\");\n        } else {\n            for (Map.Entry<String, Double> entry : courses.entrySet()) {\n                String course = entry.getKey();\n                Double grade = entry.getValue();\n                if (grade != null) {\n                    System.out.println(\"  \" + course + \": \" + grade + \" (\" + getLetterGrade(grade) + \")\");\n                } else {\n                    System.out.println(\"  \" + course + \": No grade assigned\");\n                }\n            }\n        }\n        System.out.println();\n    }\n    \n    // For file operations\n    public String toFileString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(studentId).append(\",\");\n        sb.append(name).append(\",\");\n        sb.append(age).append(\",\");\n        sb.append(email);\n        \n        // Add courses and grades\n        for (Map.Entry<String, Double> entry : courses.entrySet()) {\n            sb.append(\",\").append(entry.getKey());\n            sb.append(\":\").append(entry.getValue() != null ? entry.getValue() : \"null\");\n        }\n        \n        return sb.toString();\n    }\n    \n    public static Student fromFileString(String fileString) {\n        String[] parts = fileString.split(\",\", 4);\n        if (parts.length < 4) return null;\n        \n        Student student = new Student(parts[0], parts[1], Integer.parseInt(parts[2]), parts[3]);\n        \n        // Parse courses and grades if present\n        if (parts.length > 4) {\n            for (int i = 4; i < parts.length; i++) {\n                String[] courseGrade = parts[i].split(\":\");\n                if (courseGrade.length == 2) {\n                    String courseName = courseGrade[0];\n                    String gradeStr = courseGrade[1];\n                    if (!gradeStr.equals(\"null\")) {\n                        try {\n                            student.assignGrade(courseName, Double.parseDouble(gradeStr));\n                        } catch (StudentManagementException e) {\n                            student.enrollCourse(courseName);\n                        }\n                    } else {\n                        student.enrollCourse(courseName);\n                    }\n                }\n            }\n        }\n        \n        return student;\n    }\n}\n\n// Student Management System class\nclass StudentManagementSystem {\n    private HashMap<String, Student> students; // studentId -> Student\n    private final String dataFile = \"students.data\";\n    \n    public StudentManagementSystem() {\n        this.students = new HashMap<>();\n        loadStudentsFromFile();\n    }\n    \n    // Student operations\n    public void addStudent(Student student) throws StudentManagementException {\n        if (students.containsKey(student.getStudentId())) {\n            throw new StudentManagementException(\"Student ID already exists: \" + student.getStudentId());\n        }\n        students.put(student.getStudentId(), student);\n        saveStudentsToFile();\n    }\n    \n    public Student getStudent(String studentId) {\n        return students.get(studentId);\n    }\n    \n    public void updateStudent(String studentId, String name, int age, String email) throws StudentManagementException {\n        Student student = students.get(studentId);\n        if (student == null) {\n            throw new StudentManagementException(\"Student not found: \" + studentId);\n        }\n        student.setName(name);\n        student.setAge(age);\n        student.setEmail(email);\n        saveStudentsToFile();\n    }\n    \n    public void deleteStudent(String studentId) throws StudentManagementException {\n        if (!students.containsKey(studentId)) {\n            throw new StudentManagementException(\"Student not found: \" + studentId);\n        }\n        students.remove(studentId);\n        saveStudentsToFile();\n    }\n    \n    public void enrollStudentInCourse(String studentId, String courseName) throws StudentManagementException {\n        Student student = students.get(studentId);\n        if (student == null) {\n            throw new StudentManagementException(\"Student not found: \" + studentId);\n        }\n        student.enrollCourse(courseName);\n        saveStudentsToFile();\n    }\n    \n    public void assignGradeToStudent(String studentId, String courseName, double grade) throws StudentManagementException {\n        Student student = students.get(studentId);\n        if (student == null) {\n            throw new StudentManagementException(\"Student not found: \" + studentId);\n        }\n        student.assignGrade(courseName, grade);\n        saveStudentsToFile();\n    }\n    \n    // Reporting methods\n    public void displayAllStudents() {\n        if (students.isEmpty()) {\n            System.out.println(\"No students in the system.\");\n            return;\n        }\n        \n        System.out.println(\"=== All Students ===\");\n        for (Student student : students.values()) {\n            student.displayStudentInfo();\n        }\n    }\n    \n    public void displayStudentsByGPA() {\n        if (students.isEmpty()) {\n            System.out.println(\"No students in the system.\");\n            return;\n        }\n        \n        List<Student> studentList = new ArrayList<>(students.values());\n        studentList.sort((s1, s2) -> Double.compare(s2.calculateGPA(), s1.calculateGPA()));\n        \n        System.out.println(\"=== Students by GPA (Highest First) ===\");\n        for (Student student : studentList) {\n            System.out.println(student.getName() + \" (ID: \" + student.getStudentId() + \") - GPA: \" + \n                             String.format(\"%.2f\", student.calculateGPA()));\n        }\n        System.out.println();\n    }\n    \n    public void displayCourseStatistics(String courseName) {\n        List<Double> grades = new ArrayList<>();\n        int enrolled = 0;\n        \n        for (Student student : students.values()) {\n            HashMap<String, Double> studentCourses = student.getCourses();\n            if (studentCourses.containsKey(courseName)) {\n                enrolled++;\n                Double grade = studentCourses.get(courseName);\n                if (grade != null) {\n                    grades.add(grade);\n                }\n            }\n        }\n        \n        System.out.println(\"=== Course Statistics: \" + courseName + \" ===\");\n        System.out.println(\"Enrolled students: \" + enrolled);\n        System.out.println(\"Students with grades: \" + grades.size());\n        \n        if (!grades.isEmpty()) {\n            double average = grades.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);\n            double max = grades.stream().mapToDouble(Double::doubleValue).max().orElse(0.0);\n            double min = grades.stream().mapToDouble(Double::doubleValue).min().orElse(0.0);\n            \n            System.out.println(\"Average grade: \" + String.format(\"%.2f\", average));\n            System.out.println(\"Highest grade: \" + max);\n            System.out.println(\"Lowest grade: \" + min);\n        }\n        System.out.println();\n    }\n    \n    // File operations\n    private void saveStudentsToFile() {\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(dataFile))) {\n            for (Student student : students.values()) {\n                writer.write(student.toFileString());\n                writer.newLine();\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error saving students to file: \" + e.getMessage());\n        }\n    }\n    \n    private void loadStudentsFromFile() {\n        File file = new File(dataFile);\n        if (!file.exists()) return;\n        \n        try (BufferedReader reader = new BufferedReader(new FileReader(dataFile))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                Student student = Student.fromFileString(line);\n                if (student != null) {\n                    students.put(student.getStudentId(), student);\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error loading students from file: \" + e.getMessage());\n        }\n    }\n    \n    // Utility methods\n    public boolean studentExists(String studentId) {\n        return students.containsKey(studentId);\n    }\n    \n    public int getStudentCount() {\n        return students.size();\n    }\n}\n\n// Main application class\npublic class StudentManagementSystemApp {\n    private static StudentManagementSystem sms = new StudentManagementSystem();\n    private static Scanner scanner = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        System.out.println(\"=== Student Management System ===\\n\");\n        \n        boolean running = true;\n        while (running) {\n            displayMenu();\n            int choice = getIntInput(\"Enter your choice: \");\n            \n            switch (choice) {\n                case 1:\n                    addStudent();\n                    break;\n                case 2:\n                    viewStudent();\n                    break;\n                case 3:\n                    updateStudent();\n                    break;\n                case 4:\n                    deleteStudent();\n                    break;\n                case 5:\n                    enrollInCourse();\n                    break;\n                case 6:\n                    assignGrade();\n                    break;\n                case 7:\n                    viewAllStudents();\n                    break;\n                case 8:\n                    viewStudentsByGPA();\n                    break;\n                case 9:\n                    viewCourseStatistics();\n                    break;\n                case 10:\n                    displaySystemInfo();\n                    break;\n                case 0:\n                    running = false;\n                    System.out.println(\"Thank you for using Student Management System!\");\n                    break;\n                default:\n                    System.out.println(\"Invalid choice! Please try again.\");\n            }\n        }\n        \n        scanner.close();\n    }\n    \n    private static void displayMenu() {\n        System.out.println(\"\\n=== Main Menu ===\");\n        System.out.println(\"1. Add Student\");\n        System.out.println(\"2. View Student\");\n        System.out.println(\"3. Update Student\");\n        System.out.println(\"4. Delete Student\");\n        System.out.println(\"5. Enroll in Course\");\n        System.out.println(\"6. Assign Grade\");\n        System.out.println(\"7. View All Students\");\n        System.out.println(\"8. View Students by GPA\");\n        System.out.println(\"9. View Course Statistics\");\n        System.out.println(\"10. System Information\");\n        System.out.println(\"0. Exit\");\n        System.out.println(\"=================\");\n    }\n    \n    private static void addStudent() {\n        System.out.println(\"\\n=== Add New Student ===\");\n        \n        String studentId = getStringInput(\"Enter Student ID: \");\n        if (sms.studentExists(studentId)) {\n            System.out.println(\"Error: Student ID already exists!\");\n            return;\n        }\n        \n        String name = getStringInput(\"Enter Name: \");\n        int age = getIntInput(\"Enter Age: \");\n        String email = getStringInput(\"Enter Email: \");\n        \n        try {\n            Student student = new Student(studentId, name, age, email);\n            sms.addStudent(student);\n            System.out.println(\"Student added successfully!\");\n        } catch (StudentManagementException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n    \n    private static void viewStudent() {\n        System.out.println(\"\\n=== View Student ===\");\n        String studentId = getStringInput(\"Enter Student ID: \");\n        \n        Student student = sms.getStudent(studentId);\n        if (student != null) {\n            student.displayStudentInfo();\n        } else {\n            System.out.println(\"Student not found!\");\n        }\n    }\n    \n    private static void updateStudent() {\n        System.out.println(\"\\n=== Update Student ===\");\n        String studentId = getStringInput(\"Enter Student ID: \");\n        \n        if (!sms.studentExists(studentId)) {\n            System.out.println(\"Student not found!\");\n            return;\n        }\n        \n        String name = getStringInput(\"Enter new Name: \");\n        int age = getIntInput(\"Enter new Age: \");\n        String email = getStringInput(\"Enter new Email: \");\n        \n        try {\n            sms.updateStudent(studentId, name, age, email);\n            System.out.println(\"Student updated successfully!\");\n        } catch (StudentManagementException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n    \n    private static void deleteStudent() {\n        System.out.println(\"\\n=== Delete Student ===\");\n        String studentId = getStringInput(\"Enter Student ID: \");\n        \n        try {\n            sms.deleteStudent(studentId);\n            System.out.println(\"Student deleted successfully!\");\n        } catch (StudentManagementException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n    \n    private static void enrollInCourse() {\n        System.out.println(\"\\n=== Enroll Student in Course ===\");\n        String studentId = getStringInput(\"Enter Student ID: \");\n        String courseName = getStringInput(\"Enter Course Name: \");\n        \n        try {\n            sms.enrollStudentInCourse(studentId, courseName);\n            System.out.println(\"Student enrolled in course successfully!\");\n        } catch (StudentManagementException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n    \n    private static void assignGrade() {\n        System.out.println(\"\\n=== Assign Grade ===\");\n        String studentId = getStringInput(\"Enter Student ID: \");\n        String courseName = getStringInput(\"Enter Course Name: \");\n        double grade = getDoubleInput(\"Enter Grade (0-100): \");\n        \n        try {\n            sms.assignGradeToStudent(studentId, courseName, grade);\n            System.out.println(\"Grade assigned successfully!\");\n        } catch (StudentManagementException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n    \n    private static void viewAllStudents() {\n        sms.displayAllStudents();\n    }\n    \n    private static void viewStudentsByGPA() {\n        sms.displayStudentsByGPA();\n    }\n    \n    private static void viewCourseStatistics() {\n        System.out.println(\"\\n=== Course Statistics ===\");\n        String courseName = getStringInput(\"Enter Course Name: \");\n        sms.displayCourseStatistics(courseName);\n    }\n    \n    private static void displaySystemInfo() {\n        System.out.println(\"\\n=== System Information ===\");\n        System.out.println(\"Total Students: \" + sms.getStudentCount());\n        System.out.println(\"Data File: students.data\");\n        System.out.println(\"Data is automatically saved after each operation.\");\n    }\n    \n    // Utility methods for input\n    private static String getStringInput(String prompt) {\n        System.out.print(prompt);\n        return scanner.nextLine().trim();\n    }\n    \n    private static int getIntInput(String prompt) {\n        while (true) {\n            try {\n                System.out.print(prompt);\n                return Integer.parseInt(scanner.nextLine().trim());\n            } catch (NumberFormatException e) {\n                System.out.println(\"Invalid input! Please enter a valid integer.\");\n            }\n        }\n    }\n    \n    private static double getDoubleInput(String prompt) {\n        while (true) {\n            try {\n                System.out.print(prompt);\n                return Double.parseDouble(scanner.nextLine().trim());\n            } catch (NumberFormatException e) {\n                System.out.println(\"Invalid input! Please enter a valid number.\");\n            }\n        }\n    }\n}",
                                      "real_world_example": "This Student Management System demonstrates real-world application patterns used in enterprise systems. Educational institutions use similar systems for student records. The concepts apply to any CRUD (Create, Read, Update, Delete) application like inventory management, customer relationship management, or content management systems. The separation of data model (Student), business logic (StudentManagementSystem), and user interface (main application) follows professional software architecture patterns. File persistence mimics database operations in simpler applications.",
                                      "interactive_tasks": [
                                        "Add a feature to search students by name or email",
                                        "Implement a backup system that creates timestamped backup files",
                                        "Add input validation for email format and age ranges"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "What design pattern is used in the Student class?",
                                          "options": ["Encapsulation", "Singleton", "Factory", "Observer"],
                                          "answer": "Encapsulation",
                                          "reasoning": "Student class uses encapsulation by making fields private and providing public getters/setters."
                                        },
                                        {
                                          "question": "How is data persistence implemented?",
                                          "options": ["File I/O with automatic saving", "Database", "Cloud storage", "In-memory only"],
                                          "answer": "File I/O with automatic saving",
                                          "reasoning": "The system uses file I/O to save and load student data automatically."
                                        },
                                        {
                                          "question": "What collection is used to store students?",
                                          "options": ["HashMap", "ArrayList", "HashSet", "LinkedList"],
                                          "answer": "HashMap",
                                          "reasoning": "HashMap is used for O(1) access to students by their ID."
                                        },
                                        {
                                          "question": "How are custom exceptions used?",
                                          "options": ["For specific business logic errors", "For all exceptions", "Only for file errors", "Not used"],
                                          "answer": "For specific business logic errors",
                                          "reasoning": "Custom exceptions are used for business logic errors like duplicate student IDs."
                                        },
                                        {
                                          "question": "What is the purpose of the toFileString method?",
                                          "options": ["Serialize student data for storage", "Display student info", "Calculate GPA", "Validate data"],
                                          "answer": "Serialize student data for storage",
                                          "reasoning": "toFileString converts student object to string format for file storage."
                                        },
                                        {
                                          "question": "How is the menu system implemented?",
                                          "options": ["Switch-case in loop", "If-else statements", "Separate classes", "No menu system"],
                                          "answer": "Switch-case in loop",
                                          "reasoning": "A while loop with switch-case handles the menu navigation."
                                        },
                                        {
                                          "question": "What Java concepts are demonstrated?",
                                          "options": ["All major OOP concepts", "Only basic syntax", "Only collections", "Only file I/O"],
                                          "answer": "All major OOP concepts",
                                          "reasoning": "The project uses classes, objects, inheritance, polymorphism, encapsulation, collections, exceptions, and file I/O."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 33 – Java Packages and Imports",
                                      "definition": "Packages are Java's way of organizing classes into namespaces, and imports allow you to use classes from other packages without fully qualifying their names.",
                                      "explanation": "Think of packages like folders in a file system - they help organize related classes together and prevent naming conflicts. Just like you have folders for documents, pictures, and music, Java has packages for different functionalities. The import statement is like telling Java 'I want to use classes from this specific folder'. Packages follow a reverse domain naming convention (com.company.project) to ensure uniqueness. Understanding packages and imports is crucial for organizing large projects and using external libraries.",
                                      "code_example": "// Demonstrating packages and imports\n\n// This file would typically be in a package declaration\n// For demonstration, we'll show package usage conceptually\n\nimport java.util.*; // Import all classes from java.util package\nimport java.util.ArrayList; // Import specific class\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport static java.lang.Math.*; // Static import for Math class\n\n// Custom package demonstration (conceptual)\n// package com.myschool.studentmanagement;\n\nclass PackageDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Packages and Imports Demonstration ===\\n\");\n        \n        System.out.println(\"=== Using Imported Classes ===\\n\");\n        \n        // Using classes from java.util package\n        ArrayList<String> list = new ArrayList<>();\n        HashMap<String, Integer> map = new HashMap<>();\n        Scanner scanner = new Scanner(System.in);\n        \n        list.add(\"Apple\");\n        list.add(\"Banana\");\n        list.add(\"Orange\");\n        \n        map.put(\"John\", 25);\n        map.put(\"Alice\", 30);\n        \n        System.out.println(\"List: \" + list);\n        System.out.println(\"Map: \" + map);\n        \n        // Using static imports\n        System.out.println(\"\\n=== Using Static Imports ===\");\n        System.out.println(\"PI value: \" + PI); // Instead of Math.PI\n        System.out.println(\"Square root of 16: \" + sqrt(16)); // Instead of Math.sqrt(16)\n        System.out.println(\"Power: 2^3 = \" + pow(2, 3)); // Instead of Math.pow(2, 3)\n        \n        System.out.println(\"\\n=== Package Organization Example ===\");\n        \n        // Simulating package structure\n        System.out.println(\"Typical package structure:\");\n        System.out.println(\"com/\");\n        System.out.println(\"  company/\");\n        System.out.println(\"    project/\");\n        System.out.println(\"      model/\");\n        System.out.println(\"        Student.java\");\n        System.out.println(\"        Course.java\");\n        System.out.println(\"      service/\");\n        System.out.println(\"        StudentService.java\");\n        System.out.println(\"      util/\");\n        System.out.println(\"        DateUtils.java\");\n        \n        System.out.println(\"\\n=== Creating and Using Custom Packages ===\");\n        \n        // In real usage, these would be in separate files with package declarations\n        \n        // Using our custom classes (simulated)\n        com.myschool.studentmanagement.Student student = \n            new com.myschool.studentmanagement.Student(\"S001\", \"John Doe\", 20);\n        \n        com.myschool.studentmanagement.Course course = \n            new com.myschool.studentmanagement.Course(\"C001\", \"Java Programming\");\n        \n        student.displayInfo();\n        course.displayInfo();\n        \n        System.out.println(\"\\n=== Common Java Packages ===\");\n        \n        System.out.println(\"java.lang - automatically imported (String, System, Math)\");\n        System.out.println(\"java.util - utility classes (ArrayList, HashMap, Date)\");\n        System.out.println(\"java.io - input/output (File, FileReader, FileWriter)\");\n        System.out.println(\"java.net - networking (URL, Socket, ServerSocket)\");\n        System.out.println(\"java.awt - GUI components (Button, Frame, Panel)\");\n        System.out.println(\"javax.swing - advanced GUI (JFrame, JButton, JPanel)\");\n        \n        System.out.println(\"\\n=== Import Best Practices ===\");\n        System.out.println(\"• Use specific imports instead of wildcards for clarity\");\n        System.out.println(\"• Organize packages by functionality\");\n        System.out.println(\"• Use reverse domain naming for your packages\");\n        System.out.println(\"• Keep package names lowercase\");\n        System.out.println(\"• Use sub-packages for better organization\");\n        \n        System.out.println(\"\\n=== Classpath and Packages ===\");\n        System.out.println(\"Classpath tells JVM where to find classes\");\n        System.out.println(\"Packages must match directory structure\");\n        System.out.println(\"Example: com/company/Main.java must have package com.company;\");\n    }\n}\n\n// Custom package classes (for demonstration)\n// These would normally be in separate files\n\n// File: com/myschool/studentmanagement/Student.java\npackage com.myschool.studentmanagement;\n\nclass Student {\n    private String studentId;\n    private String name;\n    private int age;\n    \n    public Student(String studentId, String name, int age) {\n        this.studentId = studentId;\n        this.name = name;\n        this.age = age;\n    }\n    \n    public void displayInfo() {\n        System.out.println(\"Student: \" + name + \" (ID: \" + studentId + \", Age: \" + age + \")\");\n    }\n    \n    // Getters and setters\n    public String getStudentId() { return studentId; }\n    public String getName() { return name; }\n    public int getAge() { return age; }\n}\n\n// File: com/myschool/studentmanagement/Course.java\npackage com.myschool.studentmanagement;\n\nclass Course {\n    private String courseId;\n    private String courseName;\n    \n    public Course(String courseId, String courseName) {\n        this.courseId = courseId;\n        this.courseName = courseName;\n    }\n    \n    public void displayInfo() {\n        System.out.println(\"Course: \" + courseName + \" (ID: \" + courseId + \")\");\n    }\n    \n    // Getters and setters\n    public String getCourseId() { return courseId; }\n    public String getCourseName() { return courseName; }\n}\n\n// File: com/myschool/util/DateUtils.java\npackage com.myschool.util;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class DateUtils {\n    \n    public static String getCurrentDate() {\n        SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n        return formatter.format(new Date());\n    }\n    \n    public static String getCurrentDateTime() {\n        SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return formatter.format(new Date());\n    }\n    \n    public static String formatDate(Date date, String pattern) {\n        SimpleDateFormat formatter = new SimpleDateFormat(pattern);\n        return formatter.format(date);\n    }\n}\n\n// File: com/myschool/service/StudentService.java\npackage com.myschool.service;\n\nimport com.myschool.studentmanagement.Student;\nimport com.myschool.util.DateUtils;\nimport java.util.*;\n\npublic class StudentService {\n    private HashMap<String, Student> students = new HashMap<>();\n    \n    public void addStudent(Student student) {\n        students.put(student.getStudentId(), student);\n        System.out.println(\"Student added on: \" + DateUtils.getCurrentDateTime());\n    }\n    \n    public Student getStudent(String studentId) {\n        return students.get(studentId);\n    }\n    \n    public List<Student> getAllStudents() {\n        return new ArrayList<>(students.values());\n    }\n    \n    public void displayAllStudents() {\n        System.out.println(\"=== All Students (as of \" + DateUtils.getCurrentDateTime() + \") ===\");\n        for (Student student : students.values()) {\n            student.displayInfo();\n        }\n    }\n}\n\n// Demonstration of using the packaged classes\nclass PackageUsageDemo {\n    public static void main(String[] args) {\n        System.out.println(\"=== Using Packaged Classes ===\\n\");\n        \n        // Create service instance\n        com.myschool.service.StudentService studentService = new com.myschool.service.StudentService();\n        \n        // Create students\n        com.myschool.studentmanagement.Student student1 = \n            new com.myschool.studentmanagement.Student(\"S001\", \"Alice Johnson\", 20);\n        \n        com.myschool.studentmanagement.Student student2 = \n            new com.myschool.studentmanagement.Student(\"S002\", \"Bob Smith\", 22);\n        \n        // Add students to service\n        studentService.addStudent(student1);\n        studentService.addStudent(student2);\n        \n        // Display all students\n        studentService.displayAllStudents();\n        \n        // Using DateUtils from util package\n        System.out.println(\"\\n=== Date Utils Demo ===\");\n        System.out.println(\"Current Date: \" + com.myschool.util.DateUtils.getCurrentDate());\n        System.out.println(\"Current DateTime: \" + com.myschool.util.DateUtils.getCurrentDateTime());\n        \n        System.out.println(\"\\n=== Import vs Fully Qualified Names ===\");\n        System.out.println(\"With imports:\");\n        System.out.println(\"  import com.myschool.service.StudentService;\");\n        System.out.println(\"  StudentService service = new StudentService();\");\n        \n        System.out.println(\"\\nWithout imports:\");\n        System.out.println(\"  com.myschool.service.StudentService service = \");\n        System.out.println(\"      new com.myschool.service.StudentService();\");\n        \n        System.out.println(\"\\n=== Package Access Levels ===\");\n        System.out.println(\"• public: accessible from anywhere\");\n        System.out.println(\"• protected: accessible in package + subclasses\");\n        System.out.println(\"• (default): accessible only in same package\");\n        System.out.println(\"• private: accessible only in same class\");\n    }\n}",
                                      "real_world_example": "Packages are fundamental in enterprise Java development. Spring Framework uses packages like org.springframework.context, org.springframework.beans. Apache Commons uses org.apache.commons.lang3. Companies use reverse domain packages like com.google.gson, com.amazonaws.services. Large applications have packages organized by layers: com.company.app.web (controllers), com.company.app.service (business logic), com.company.app.repository (data access), com.company.app.model (data models). This organization makes code maintainable and prevents naming conflicts when using multiple libraries.",
                                      "interactive_tasks": [
                                        "Create a package structure for a banking application with model, service, and util packages",
                                        "Write a program that uses multiple imports from different Java standard packages",
                                        "Create a custom utility package with math helper methods and use it in another class"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "What is the purpose of packages?",
                                          "options": ["Organize classes and prevent naming conflicts", "Make code faster", "Reduce file size", "Compile faster"],
                                          "answer": "Organize classes and prevent naming conflicts",
                                          "reasoning": "Packages organize related classes and provide unique namespaces."
                                        },
                                        {
                                          "question": "Which package is automatically imported?",
                                          "options": ["java.lang", "java.util", "java.io", "java.net"],
                                          "answer": "java.lang",
                                          "reasoning": "java.lang package is automatically imported in every Java program."
                                        },
                                        {
                                          "question": "What does import java.util.*; do?",
                                          "options": ["Imports all classes from java.util", "Imports only ArrayList", "Imports utilities", "Imports nothing"],
                                          "answer": "Imports all classes from java.util",
                                          "reasoning": "The asterisk (*) is a wildcard that imports all classes from the package."
                                        },
                                        {
                                          "question": "What is the conventional package naming pattern?",
                                          "options": ["Reverse domain name", "Company name only", "Project name only", "Random names"],
                                          "answer": "Reverse domain name",
                                          "reasoning": "Reverse domain naming (com.company.project) ensures global uniqueness."
                                        },
                                        {
                                          "question": "What is static import?",
                                          "options": ["Import static members", "Import all static classes", "Make imports static", "Import final classes"],
                                          "answer": "Import static members",
                                          "reasoning": "Static import allows using static members without class name qualification."
                                        },
                                        {
                                          "question": "Where should package statement appear?",
                                          "options": ["First line in file", "After imports", "Before class", "Anywhere"],
                                          "answer": "First line in file",
                                          "reasoning": "Package statement must be the first non-comment line in a Java file."
                                        },
                                        {
                                          "question": "What is default package access?",
                                          "options": ["Accessible only in same package", "Public access", "Private access", "Protected access"],
                                          "answer": "Accessible only in same package",
                                          "reasoning": "Default (no modifier) means accessible only within the same package."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 34 – Recap and Best Practices",
                                      "definition": "A comprehensive review of all Java concepts learned, along with industry best practices for writing clean, efficient, and maintainable Java code.",
                                      "explanation": "Today we'll revisit everything we've learned and organize it into a coherent mental model. Think of this like cleaning and organizing your workshop - you know where all your tools are and how to use them effectively. We'll cover coding standards, performance tips, common pitfalls to avoid, and professional development practices. This recap will help solidify your understanding and prepare you for writing real-world Java applications.",
                                      "code_example": "// Demonstrating Java best practices and recap\n\nimport java.util.*;\n\n/**\n * This class demonstrates Java best practices and serves as a recap\n * of all concepts covered in the course.\n * \n * Key principles demonstrated:\n * - Clean code organization\n * - Proper naming conventions\n * - Effective use of OOP principles\n * - Exception handling\n * - Collections usage\n * - Documentation\n */\npublic class JavaBestPracticesRecap {\n    \n    // Constants should be UPPER_CASE with underscores\n    private static final int MAX_STUDENTS = 100;\n    private static final String DEFAULT_SCHOOL_NAME = \"Java Academy\";\n    \n    // Static variables for shared data\n    private static int totalStudentsCreated = 0;\n    \n    // Instance variables should be private with getters/setters\n    private String schoolName;\n    private List<Student> students;\n    \n    /**\n     * Constructor with validation and proper initialization.\n     */\n    public JavaBestPracticesRecap(String schoolName) {\n        // Use 'this' to distinguish instance variables from parameters\n        this.schoolName = (schoolName != null && !schoolName.trim().isEmpty()) \n                         ? schoolName : DEFAULT_SCHOOL_NAME;\n        this.students = new ArrayList<>();\n    }\n    \n    // Public getter for schoolName\n    public String getSchoolName() {\n        return schoolName;\n    }\n    \n    // Public setter with validation\n    public void setSchoolName(String schoolName) {\n        if (schoolName != null && !schoolName.trim().isEmpty()) {\n            this.schoolName = schoolName;\n        }\n    }\n    \n    /**\n     * Adds a student to the system with proper validation.\n     * Demonstrates exception handling and business logic.\n     */\n    public void addStudent(Student student) throws IllegalArgumentException {\n        // Input validation\n        if (student == null) {\n            throw new IllegalArgumentException(\"Student cannot be null\");\n        }\n        \n        if (students.size() >= MAX_STUDENTS) {\n            throw new IllegalStateException(\"Maximum student capacity reached: \" + MAX_STUDENTS);\n        }\n        \n        // Business logic validation\n        if (isStudentIdDuplicate(student.getStudentId())) {\n            throw new IllegalArgumentException(\"Student ID already exists: \" + student.getStudentId());\n        }\n        \n        // Add to collection\n        students.add(student);\n        totalStudentsCreated++;\n        \n        System.out.println(\"Student added: \" + student.getName());\n    }\n    \n    /**\n     * Helper method to check for duplicate student IDs.\n     * Demonstrates private helper methods and streams.\n     */\n    private boolean isStudentIdDuplicate(String studentId) {\n        return students.stream()\n                      .anyMatch(student -> student.getStudentId().equals(studentId));\n    }\n    \n    /**\n     * Finds a student by ID using Optional for null-safe operations.\n     * Demonstrates modern Java practices.\n     */\n    public Optional<Student> findStudentById(String studentId) {\n        return students.stream()\n                      .filter(student -> student.getStudentId().equals(studentId))\n                      .findFirst();\n    }\n    \n    /**\n     * Gets all students sorted by name.\n     * Demonstrates sorting and defensive copying.\n     */\n    public List<Student> getAllStudentsSortedByName() {\n        List<Student> sortedStudents = new ArrayList<>(students); // Defensive copy\n        sortedStudents.sort(Comparator.comparing(Student::getName));\n        return sortedStudents;\n    }\n    \n    /**\n     * Calculates average GPA of all students.\n     * Demonstrates stream operations and Optional handling.\n     */\n    public double calculateAverageGPA() {\n        return students.stream()\n                      .mapToDouble(Student::calculateGPA)\n                      .average()\n                      .orElse(0.0); // Default value if no students\n    }\n    \n    /**\n     * Displays school statistics.\n     * Demonstrates string formatting and data presentation.\n     */\n    public void displaySchoolStatistics() {\n        System.out.println(\"=== \" + schoolName + \" Statistics ===\");\n        System.out.println(\"Total Students: \" + students.size());\n        System.out.println(\"Average GPA: \" + String.format(\"%.2f\", calculateAverageGPA()));\n        System.out.println(\"Total Students Created: \" + totalStudentsCreated);\n        \n        // Group students by grade level\n        Map<String, Long> studentsByGrade = students.stream()\n            .collect(Collectors.groupingBy(\n                student -> student.getLetterGrade(student.calculateGPA()),\n                Collectors.counting()\n            ));\n        \n        System.out.println(\"\\nStudents by Grade:\");\n        studentsByGrade.forEach((grade, count) -> \n            System.out.println(\"  \" + grade + \": \" + count + \" students\"));\n    }\n    \n    // Static method demonstrating utility functionality\n    public static void displayBestPractices() {\n        System.out.println(\"\\n=== Java Best Practices ===\\n\");\n        \n        System.out.println(\"1. Naming Conventions:\");\n        System.out.println(\"   • Classes: PascalCase (StudentManagement)\");\n        System.out.println(\"   • Methods: camelCase (calculateAverageGPA)\");\n        System.out.println(\"   • Variables: camelCase (studentName)\");\n        System.out.println(\"   • Constants: UPPER_CASE (MAX_STUDENTS)\");\n        \n        System.out.println(\"\\n2. Code Organization:\");\n        System.out.println(\"   • One class per file\");\n        System.out.println(\"   • Package by feature, not by layer\");\n        System.out.println(\"   • Use meaningful package names\");\n        \n        System.out.println(\"\\n3. OOP Principles:\");\n        System.out.println(\"   • Encapsulation: private fields with public getters/setters\");\n        System.out.println(\"   • Inheritance: Use for 'is-a' relationships\");\n        System.out.println(\"   • Polymorphism: Program to interfaces\");\n        System.out.println(\"   • Abstraction: Hide implementation details\");\n        \n        System.out.println(\"\\n4. Exception Handling:\");\n        System.out.println(\"   • Catch specific exceptions first\");\n        System.out.println(\"   • Don't ignore exceptions\");\n        System.out.println(\"   • Use try-with-resources\");\n        System.out.println(\"   • Throw meaningful exceptions\");\n        \n        System.out.println(\"\\n5. Collections:\");\n        System.out.println(\"   • Use interface types for declarations\");\n        System.out.println(\"   • Prefer ArrayList for random access\");\n        System.out.println(\"   • Use HashMap for key-value pairs\");\n        System.out.println(\"   • Use streams for functional operations\");\n        \n        System.out.println(\"\\n6. Performance:\");\n        System.out.println(\"   • Use StringBuilder for string concatenation in loops\");\n        System.out.println(\"   • Initialize collections with expected size\");\n        System.out.println(\"   • Use primitive types when possible\");\n        \n        System.out.println(\"\\n7. Readability:\");\n        System.out.println(\"   • Write self-documenting code\");\n        System.out.println(\"   • Use meaningful variable names\");\n        System.out.println(\"   • Keep methods small and focused\");\n        System.out.println(\"   • Use comments for 'why', not 'what'\");\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"=== Java Recap and Best Practices ===\\n\");\n        \n        // Create school instance\n        JavaBestPracticesRecap school = new JavaBestPracticesRecap(\"Best Practices High School\");\n        \n        // Create and add students\n        try {\n            school.addStudent(new Student(\"S001\", \"Alice Johnson\", 20, \"Computer Science\"));\n            school.addStudent(new Student(\"S002\", \"Bob Smith\", 22, \"Mathematics\"));\n            school.addStudent(new Student(\"S003\", \"Charlie Brown\", 21, \"Physics\"));\n            \n            // Assign grades\n            school.findStudentById(\"S001\").ifPresent(student -> {\n                student.enrollCourse(\"Java Programming\");\n                student.enrollCourse(\"Data Structures\");\n                try {\n                    student.assignGrade(\"Java Programming\", 95.0);\n                    student.assignGrade(\"Data Structures\", 88.0);\n                } catch (StudentManagementException e) {\n                    System.out.println(\"Error assigning grade: \" + e.getMessage());\n                }\n            });\n            \n            school.findStudentById(\"S002\").ifPresent(student -> {\n                student.enrollCourse(\"Java Programming\");\n                try {\n                    student.assignGrade(\"Java Programming\", 78.0);\n                } catch (StudentManagementException e) {\n                    System.out.println(\"Error assigning grade: \" + e.getMessage());\n                }\n            });\n            \n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Error adding student: \" + e.getMessage());\n        }\n        \n        // Display school statistics\n        school.displaySchoolStatistics();\n        \n        // Display all students sorted by name\n        System.out.println(\"\\n=== Students Sorted by Name ===\");\n        school.getAllStudentsSortedByName().forEach(Student::displayStudentInfo);\n        \n        // Demonstrate best practices\n        displayBestPractices();\n        \n        // Additional recap examples\n        System.out.println(\"\\n=== Key Java Concepts Recap ===\\n\");\n        \n        System.out.println(\"Variables and Data Types:\");\n        demonstrateVariablesAndTypes();\n        \n        System.out.println(\"\\nControl Structures:\");\n        demonstrateControlStructures();\n        \n        System.out.println(\"\\nMethods:\");\n        demonstrateMethods();\n        \n        System.out.println(\"\\nCollections:\");\n        demonstrateCollections();\n        \n        System.out.println(\"\\n=== Next Steps ===\");\n        System.out.println(\"1. Practice building small projects\");\n        System.out.println(\"2. Learn about Java frameworks (Spring, Hibernate)\");\n        System.out.println(\"3. Study design patterns\");\n        System.out.println(\"4. Learn about databases and JDBC\");\n        System.out.println(\"5. Explore multithreading and concurrency\");\n        System.out.println(\"6. Practice problem-solving on coding platforms\");\n    }\n    \n    private static void demonstrateVariablesAndTypes() {\n        // Primitive types\n        int age = 25;\n        double salary = 55000.75;\n        boolean isActive = true;\n        char grade = 'A';\n        \n        // Reference types\n        String name = \"John Doe\";\n        int[] numbers = {1, 2, 3, 4, 5};\n        \n        System.out.println(\"  Primitive: age=\" + age + \", salary=\" + salary);\n        System.out.println(\"  Reference: name=\\\"\" + name + \"\\\", array length=\" + numbers.length);\n    }\n    \n    private static void demonstrateControlStructures() {\n        // If-else\n        int score = 85;\n        if (score >= 90) {\n            System.out.println(\"  Grade: A\");\n        } else if (score >= 80) {\n            System.out.println(\"  Grade: B\");\n        } else {\n            System.out.println(\"  Grade: C or below\");\n        }\n        \n        // Switch\n        String day = \"Monday\";\n        switch (day) {\n            case \"Monday\":\n                System.out.println(\"  Start of work week\");\n                break;\n            case \"Friday\":\n                System.out.println(\"  Weekend is near\");\n                break;\n            default:\n                System.out.println(\"  Regular day\");\n        }\n        \n        // Loops\n        System.out.println(\"  For loop:\");\n        for (int i = 1; i <= 3; i++) {\n            System.out.println(\"    Iteration: \" + i);\n        }\n        \n        System.out.println(\"  While loop:\");\n        int count = 1;\n        while (count <= 3) {\n            System.out.println(\"    Count: \" + count);\n            count++;\n        }\n    }\n    \n    private static void demonstrateMethods() {\n        // Method with return value\n        int sum = addNumbers(5, 3);\n        System.out.println(\"  Sum: \" + sum);\n        \n        // Method with exception\n        try {\n            double result = divideNumbers(10, 2);\n            System.out.println(\"  Division: \" + result);\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"  Error: \" + e.getMessage());\n        }\n    }\n    \n    private static int addNumbers(int a, int b) {\n        return a + b;\n    }\n    \n    private static double divideNumbers(double a, double b) {\n        if (b == 0) {\n            throw new IllegalArgumentException(\"Cannot divide by zero\");\n        }\n        return a / b;\n    }\n    \n    private static void demonstrateCollections() {\n        // List\n        List<String> fruits = new ArrayList<>();\n        fruits.add(\"Apple\");\n        fruits.add(\"Banana\");\n        fruits.add(\"Orange\");\n        System.out.println(\"  List: \" + fruits);\n        \n        // Set\n        Set<Integer> uniqueNumbers = new HashSet<>();\n        uniqueNumbers.add(1);\n        uniqueNumbers.add(2);\n        uniqueNumbers.add(1); // Duplicate\n        System.out.println(\"  Set: \" + uniqueNumbers);\n        \n        // Map\n        Map<String, Integer> studentAges = new HashMap<>();\n        studentAges.put(\"Alice\", 20);\n        studentAges.put(\"Bob\", 22);\n        System.out.println(\"  Map: \" + studentAges);\n        \n        // Stream operations\n        List<String> filteredFruits = fruits.stream()\n                                          .filter(fruit -> fruit.startsWith(\"A\"))\n                                          .collect(Collectors.toList());\n        System.out.println(\"  Stream filter: \" + filteredFruits);\n    }\n}\n\n// Supporting Student class with best practices\nclass Student {\n    private String studentId;\n    private String name;\n    private int age;\n    private String major;\n    private Map<String, Double> courses;\n    \n    public Student(String studentId, String name, int age, String major) {\n        this.studentId = studentId;\n        this.name = name;\n        this.age = age;\n        this.major = major;\n        this.courses = new HashMap<>();\n    }\n    \n    // Getters\n    public String getStudentId() { return studentId; }\n    public String getName() { return name; }\n    public int getAge() { return age; }\n    public String getMajor() { return major; }\n    \n    // Course management\n    public void enrollCourse(String courseName) {\n        courses.put(courseName, null);\n    }\n    \n    public void assignGrade(String courseName, double grade) throws StudentManagementException {\n        if (!courses.containsKey(courseName)) {\n            throw new StudentManagementException(\"Student not enrolled in: \" + courseName);\n        }\n        if (grade < 0 || grade > 100) {\n            throw new StudentManagementException(\"Grade must be between 0 and 100\");\n        }\n        courses.put(courseName, grade);\n    }\n    \n    public double calculateGPA() {\n        if (courses.isEmpty()) return 0.0;\n        \n        return courses.values().stream()\n                     .filter(grade -> grade != null)\n                     .mapToDouble(Double::doubleValue)\n                     .average()\n                     .orElse(0.0);\n    }\n    \n    public String getLetterGrade(double grade) {\n        if (grade >= 90) return \"A\";\n        else if (grade >= 80) return \"B\";\n        else if (grade >= 70) return \"C\";\n        else if (grade >= 60) return \"D\";\n        else return \"F\";\n    }\n    \n    public void displayStudentInfo() {\n        System.out.println(\"  \" + name + \" (ID: \" + studentId + \") - GPA: \" + \n                         String.format(\"%.2f\", calculateGPA()));\n    }\n}\n\nclass StudentManagementException extends Exception {\n    public StudentManagementException(String message) {\n        super(message);\n    }\n}",
                                      "real_world_example": "These best practices are used by professional Java developers in companies like Google, Amazon, and Netflix. Clean code principles make code maintainable for teams. Proper exception handling ensures application stability. Effective use of collections and streams improves performance. Good naming conventions make code self-documenting. These practices are enforced through code reviews, static analysis tools, and team coding standards in professional environments.",
                                      "interactive_tasks": [
                                        "Refactor a piece of code to follow all best practices discussed",
                                        "Write documentation for a class using JavaDoc comments",
                                        "Create a utility class that demonstrates single responsibility principle"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "What is the recommended naming convention for constants?",
                                          "options": ["UPPER_CASE_WITH_UNDERSCORES", "camelCase", "PascalCase", "lowercase"],
                                          "answer": "UPPER_CASE_WITH_UNDERSCORES",
                                          "reasoning": "Constants should be in all uppercase with words separated by underscores."
                                        },
                                        {
                                          "question": "When should you use StringBuilder?",
                                          "options": ["String concatenation in loops", "All string operations", "Simple concatenation", "Never use it"],
                                          "answer": "String concatenation in loops",
                                          "reasoning": "StringBuilder is more efficient than + operator for multiple concatenations."
                                        },
                                        {
                                          "question": "What is defensive copying?",
                                          "options": ["Returning copies of mutable objects", "Copying all objects", "Making objects immutable", "Using copy constructors"],
                                          "answer": "Returning copies of mutable objects",
                                          "reasoning": "Defensive copying prevents callers from modifying internal state."
                                        },
                                        {
                                          "question": "What should you program to?",
                                          "options": ["Interfaces", "Implementations", "Abstract classes", "Concrete classes"],
                                          "answer": "Interfaces",
                                          "reasoning": "Programming to interfaces provides flexibility and loose coupling."
                                        },
                                        {
                                          "question": "How should exceptions be handled?",
                                          "options": ["Catch specific exceptions first", "Catch Exception always", "Ignore exceptions", "Use only runtime exceptions"],
                                          "answer": "Catch specific exceptions first",
                                          "reasoning": "Specific exceptions should be caught before general ones."
                                        },
                                        {
                                          "question": "What is the single responsibility principle?",
                                          "options": ["One class, one reason to change", "One method, one task", "One package, one feature", "All of the above"],
                                          "answer": "One class, one reason to change",
                                          "reasoning": "A class should have only one reason to change (one responsibility)."
                                        },
                                        {
                                          "question": "Why use meaningful variable names?",
                                          "options": ["Self-documenting code", "Faster execution", "Smaller code", "Compiler optimization"],
                                          "answer": "Self-documenting code",
                                          "reasoning": "Meaningful names make code easier to understand without comments."
                                        }
                                      ]
                                    },
                                    {
                                      "title": "Day 35 – Course Wrap-Up and Next Steps",
                                      "definition": "A comprehensive conclusion to the Java beginner course, summarizing key learnings and providing guidance for continued learning and practical application.",
                                      "explanation": "Congratulations! You've completed an incredible journey from Java beginner to having solid programming foundations. Today we'll celebrate your achievements, review what you've accomplished, and map out your path forward. Think of this as graduation day - you've learned the fundamentals, and now it's time to decide where to apply them. We'll cover practical next steps, project ideas, learning resources, and how to continue growing as a Java developer.",
                                      "code_example": "// Course wrap-up and celebration of learning\n\nimport java.util.*;\n\n/**\n * Final demonstration combining all key concepts from the course.\n * This class serves as both a recap and an inspiration for future projects.\n */\npublic class CourseWrapUp {\n    \n    // Constants for application configuration\n    private static final String APP_NAME = \"Java Learning Tracker\";\n    private static final String VERSION = \"1.0\";\n    \n    // Collection to track learning progress\n    private static Map<String, Boolean> topicsMastered = new HashMap<>();\n    \n    static {\n        // Initialize with course topics\n        initializeTopics();\n    }\n    \n    /**\n     * Initializes the learning topics map with all concepts covered.\n     */\n    private static void initializeTopics() {\n        topicsMastered.put(\"Variables and Data Types\", true);\n        topicsMastered.put(\"Operators and Expressions\", true);\n        topicsMastered.put(\"Control Flow Statements\", true);\n        topicsMastered.put(\"Methods\", true);\n        topicsMastered.put(\"Arrays\", true);\n        topicsMastered.put(\"Object-Oriented Programming\", true);\n        topicsMastered.put(\"Inheritance\", true);\n        topicsMastered.put(\"Polymorphism\", true);\n        topicsMastered.put(\"Encapsulation\", true);\n        topicsMastered.put(\"Abstraction\", true);\n        topicsMastered.put(\"Interfaces\", true);\n        topicsMastered.put(\"Collections Framework\", true);\n        topicsMastered.put(\"Exception Handling\", true);\n        topicsMastered.put(\"File Handling\", true);\n        topicsMastered.put(\"Packages and Imports\", true);\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"╔══════════════════════════════════════════════════════════════╗\");\n        System.out.println(\"║                    COURSE COMPLETION CELEBRATION            ║\");\n        System.out.println(\"║                   Java Beginner Level - 35 Days             ║\");\n        System.out.println(\"╚══════════════════════════════════════════════════════════════╝\\n\");\n        \n        displayCongratulations();\n        displayLearningSummary();\n        displaySkillsAcquired();\n        displayProjectIdeas();\n        displayNextSteps();\n        displayFinalEncouragement();\n    }\n    \n    /**\n     * Displays congratulations message and achievement summary.\n     */\n    private static void displayCongratulations() {\n        System.out.println(\"🎉 CONGRATULATIONS! 🎉\\n\");\n        System.out.println(\"You have successfully completed the Java Beginner Level course!\");\n        System.out.println(\"Over 35 days, you've built a solid foundation in Java programming.\");\n        System.out.println(\"This is a significant achievement worth celebrating!\\n\");\n        \n        int daysCompleted = 35;\n        int topicsCovered = topicsMastered.size();\n        double completionPercentage = 100.0; // You made it!\n        \n        System.out.println(\"📊 Your Learning Journey:\");\n        System.out.println(\"   • Days of consistent learning: \" + daysCompleted);\n        System.out.println(\"   • Core topics mastered: \" + topicsCovered);\n        System.out.println(\"   • Completion: \" + completionPercentage + \"%\");\n        System.out.println();\n    }\n    \n    /**\n     * Displays summary of what was learned in the course.\n     */\n    private static void displayLearningSummary() {\n        System.out.println(\"📚 What You've Accomplished:\\n\");\n        \n        System.out.println(\"🏗️  Foundation Building:\");\n        System.out.println(\"   • Java syntax and structure\");\n        System.out.println(\"   • Variables, data types, and operators\");\n        System.out.println(\"   • Control flow (if, switch, loops)\");\n        System.out.println(\"   • Methods and code organization\");\n        \n        System.out.println(\"\\n💼 Object-Oriented Programming:\");\n        System.out.println(\"   • Classes and objects\");\n        System.out.println(\"   • The four pillars of OOP:\");\n        System.out.println(\"     - Encapsulation (data hiding)\");\n        System.out.println(\"     - Inheritance (code reuse)\");\n        System.out.println(\"     - Polymorphism (flexibility)\");\n        System.out.println(\"     - Abstraction (simplification)\");\n        \n        System.out.println(\"\\n🛠️  Advanced Concepts:\");\n        System.out.println(\"   • Collections Framework\");\n        System.out.println(\"   • Exception handling\");\n        System.out.println(\"   • File I/O operations\");\n        System.out.println(\"   • Packages and imports\");\n        \n        System.out.println(\"\\n🎯 Practical Application:\");\n        System.out.println(\"   • Student Management System project\");\n        System.out.println(\"   • Problem-solving skills\");\n        System.out.println(\"   • Debugging and testing\");\n        System.out.println(\"   • Code organization best practices\");\n        System.out.println();\n    }\n    \n    /**\n     * Displays the skills you've acquired and how to apply them.\n     */\n    private static void displaySkillsAcquired() {\n        System.out.println(\"🚀 Skills You Now Possess:\\n\");\n        \n        List<String> skills = Arrays.asList(\n            \"Writing clean, readable Java code\",\n            \"Solving problems using programming logic\",\n            \"Designing and implementing classes\",\n            \"Working with arrays and collections\",\n            \"Handling errors and exceptions gracefully\",\n            \"Reading from and writing to files\",\n            \"Organizing code into packages\",\n            \"Applying object-oriented principles\",\n            \"Debugging and fixing code issues\",\n            \"Building complete applications\"\n        );\n        \n        for (int i = 0; i < skills.size(); i++) {\n            System.out.println(\"   \" + (i + 1) + \". \" + skills.get(i));\n        }\n        System.out.println();\n    }\n    \n    /**\n     * Provides project ideas for continued practice.\n     */\n    private static void displayProjectIdeas() {\n        System.out.println(\"💡 Project Ideas for Practice:\\n\");\n        \n        System.out.println(\"🔹 Beginner Projects:\");\n        System.out.println(\"   • Calculator application\");\n        System.out.println(\"   • Number guessing game\");\n        System.out.println(\"   • Simple bank account system\");\n        System.out.println(\"   • Student grade tracker\");\n        System.out.println(\"   • To-do list manager\");\n        \n        System.out.println(\"\\n🔹 Intermediate Projects:\");\n        System.out.println(\"   • Library management system\");\n        System.out.println(\"   • Inventory management\");\n        System.out.println(\"   • Weather data analyzer\");\n        System.out.println(\"   • Quiz application\");\n        System.out.println(\"   • File organizer utility\");\n        \n        System.out.println(\"\\n🔹 Advanced Projects:\");\n        System.out.println(\"   • E-commerce shopping cart\");\n        System.out.println(\"   • Social media user management\");\n        System.out.println(\"   • Hotel reservation system\");\n        System.out.println(\"   • Stock portfolio tracker\");\n        System.out.println(\"   • Multi-user blog platform\");\n        System.out.println();\n    }\n    \n    /**\n     * Suggests next steps for continuing the Java journey.\n     */\n    private static void displayNextSteps() {\n        System.out.println(\"🛣️  Your Path Forward:\\n\");\n        \n        System.out.println(\"📖 Continue Learning:\");\n        System.out.println(\"   • Java Intermediate concepts:\");\n        System.out.println(\"     - Multithreading and concurrency\");\n        System.out.println(\"     - Generics and type safety\");\n        System.out.println(\"     - Lambda expressions and streams\");\n        System.out.println(\"     - Design patterns\");\n        System.out.println(\"     - Data structures and algorithms\");\n        \n        System.out.println(\"\\n🌐 Explore Java Ecosystem:\");\n        System.out.println(\"   • Spring Framework (enterprise applications)\");\n        System.out.println(\"   • Hibernate (database operations)\");\n        System.out.println(\"   • Maven/Gradle (build tools)\");\n        System.out.println(\"   • JUnit (testing)\");\n        System.out.println(\"   • Android development\");\n        \n        System.out.println(\"\\n🔧 Practical Steps:\");\n        System.out.println(\"   • Build at least 3 complete projects\");\n        System.out.println(\"   • Contribute to open source projects\");\n        System.out.println(\"   • Practice on coding platforms (LeetCode, HackerRank)\");\n        System.out.println(\"   • Join Java communities and forums\");\n        System.out.println(\"   • Read Java documentation and blogs\");\n        System.out.println();\n    }\n    \n    /**\n     * Displays final encouragement and motivational message.\n     */\n    private static void displayFinalEncouragement() {\n        System.out.println(\"🌟 Final Words of Encouragement:\\n\");\n        \n        System.out.println(\"Remember:\");\n        System.out.println(\"• Programming is a journey, not a destination\");\n        System.out.println(\"• Every expert was once a beginner\");\n        System.out.println(\"• Consistency is more important than intensity\");\n        System.out.println(\"• Don't be afraid to make mistakes - that's how we learn\");\n        System.out.println(\"• Build things that excite you\");\n        \n        System.out.println(\"\\n🎯 Your Java Journey Continues...\");\n        System.out.println(\"You now have the foundation to build amazing things with Java!\");\n        System.out.println(\"Keep coding, keep learning, and most importantly, have fun!\");\n        \n        System.out.println(\"\\n\" + \"=\".repeat(60));\n        System.out.println(\"Thank you for completing the Java Beginner Level course!\");\n        System.out.println(\"We can't wait to see what you build next! 🚀\");\n        System.out.println(\"=\".repeat(60));\n    }\n    \n    /**\n     * Utility method to demonstrate a final code example combining multiple concepts.\n     */\n    public static void demonstrateFinalExample() {\n        System.out.println(\"\\n=== Final Code Example: Learning Progress Tracker ===\\n\");\n        \n        // Using collections to track progress\n        List<String> completedProjects = new ArrayList<>();\n        completedProjects.add(\"Student Management System\");\n        completedProjects.add(\"Number Guessing Game\");\n        \n        // Using maps for skill levels\n        Map<String, String> skillLevels = new HashMap<>();\n        skillLevels.put(\"OOP Concepts\", \"Intermediate\");\n        skillLevels.put(\"Collections\", \"Intermediate\");\n        skillLevels.put(\"File I/O\", \"Beginner\");\n        \n        // Using streams for data processing\n        long intermediateSkills = skillLevels.values().stream()\n                                           .filter(level -> level.equals(\"Intermediate\"))\n                                           .count();\n        \n        System.out.println(\"Completed Projects: \" + completedProjects);\n        System.out.println(\"Skill Levels: \" + skillLevels);\n        System.out.println(\"Intermediate Skills: \" + intermediateSkills);\n        \n        // Demonstrating exception handling\n        try {\n            String nextSkill = \"Multithreading\";\n            if (!skillLevels.containsKey(nextSkill)) {\n                throw new IllegalArgumentException(\"New skill to learn: \" + nextSkill);\n            }\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Learning opportunity: \" + e.getMessage());\n        }\n    }\n}\n\n/**\n * Additional resource provider class.\n */\nclass LearningResources {\n    \n    public static void displayResources() {\n        System.out.println(\"\\n📚 Recommended Learning Resources:\\n\");\n        \n        System.out.println(\"📖 Books:\");\n        System.out.println(\"   • 'Head First Java' by Kathy Sierra & Bert Bates\");\n        System.out.println(\"   • 'Effective Java' by Joshua Bloch\");\n        System.out.println(\"   • 'Java: The Complete Reference' by Herbert Schildt\");\n        \n        System.out.println(\"\\n🌐 Online Platforms:\");\n        System.out.println(\"   • Oracle Java Tutorials\");\n        System.out.println(\"   • Baeldung Java Tutorials\");\n        System.out.println(\"   • GeeksforGeeks Java Section\");\n        System.out.println(\"   • Stack Overflow for problem-solving\");\n        \n        System.out.println(\"\\n🎓 Practice Platforms:\");\n        System.out.println(\"   • LeetCode (algorithm practice)\");\n        System.out.println(\"   • HackerRank (coding challenges)\");\n        System.out.println(\"   • Codecademy (interactive learning)\");\n        System.out.println(\"   • GitHub (project hosting and collaboration)\");\n        \n        System.out.println(\"\\n👥 Communities:\");\n        System.out.println(\"   • Stack Overflow\");\n        System.out.println(\"   • Reddit r/learnjava\");\n        System.out.println(\"   • Java Discord servers\");\n        System.out.println(\"   • Local Java user groups\");\n    }\n}\n\n/**\n * Career guidance for Java developers.\n */\nclass CareerGuidance {\n    \n    public static void displayCareerPaths() {\n        System.out.println(\"\\n💼 Java Career Paths:\\n\");\n        \n        System.out.println(\"🚀 Entry-Level Positions:\");\n        System.out.println(\"   • Junior Java Developer\");\n        System.out.println(\"   • Software Development Intern\");\n        System.out.println(\"   • Application Support Engineer\");\n        \n        System.out.println(\"\\n🎯 Mid-Level Positions:\");\n        System.out.println(\"   • Java Developer\");\n        System.out.println(\"   • Software Engineer\");\n        System.out.println(\"   • Backend Developer\");\n        \n        System.out.println(\"\\n🏆 Senior-Level Positions:\");\n        System.out.println(\"   • Senior Java Developer\");\n        System.out.println(\"   • Technical Lead\");\n        System.out.println(\"   • Software Architect\");\n        System.out.println(\"   • Engineering Manager\");\n        \n        System.out.println(\"\\n🌍 Industries Using Java:\");\n        System.out.println(\"   • Finance and Banking\");\n        System.out.println(\"   • E-commerce\");\n        System.out.println(\"   • Healthcare\");\n        System.out.println(\"   • Government\");\n        System.out.println(\"   • Technology Companies\");\n        System.out.println(\"   • Startups\");\n    }\n}",
                                      "real_world_example": "The completion of this course represents a significant milestone similar to finishing foundational training in any professional field. Just as medical students complete basic science before specialization, you've built the programming fundamentals needed for various career paths. Java developers work on everything from Android apps and web services to enterprise systems and financial applications. The concepts you've learned are transferable to other programming languages and technologies, making you well-prepared for a career in software development.",
                                      "interactive_tasks": [
                                        "Create a personal learning plan for the next 3 months",
                                        "Design and start building your first independent Java project",
                                        "Join a programming community and introduce yourself"
                                      ],
                                      "quiz": [
                                        {
                                          "question": "What is the most important next step after completing this course?",
                                          "options": ["Build projects and practice consistently", "Learn another language", "Take a break", "Memorize all syntax"],
                                          "answer": "Build projects and practice consistently",
                                          "reasoning": "Consistent practice through project building is key to solidifying and advancing skills."
                                        },
                                        {
                                          "question": "Which OOP concept helps in code reuse?",
                                          "options": ["Inheritance", "Encapsulation", "Polymorphism", "Abstraction"],
                                          "answer": "Inheritance",
                                          "reasoning": "Inheritance allows creating new classes based on existing ones, promoting code reuse."
                                        },
                                        {
                                          "question": "What should you use for efficient string concatenation in loops?",
                                          "options": ["StringBuilder", "String + operator", "String.concat()", "Arrays"],
                                          "answer": "StringBuilder",
                                          "reasoning": "StringBuilder is more efficient for multiple string concatenations."
                                        },
                                        {
                                          "question": "Which collection maintains unique elements?",
                                          "options": ["HashSet", "ArrayList", "LinkedList", "HashMap"],
                                          "answer": "HashSet",
                                          "reasoning": "HashSet stores only unique elements, no duplicates allowed."
                                        },
                                        {
                                          "question": "What is the purpose of exception handling?",
                                          "options": ["Graceful error recovery", "Prevent all errors", "Make code faster", "Reduce code size"],
                                          "answer": "Graceful error recovery",
                                          "reasoning": "Exception handling allows programs to recover from or handle errors gracefully."
                                        },
                                        {
                                          "question": "Why are packages important?",
                                          "options": ["Organization and namespace management", "Make code run faster", "Required for compilation", "Only for large projects"],
                                          "answer": "Organization and namespace management",
                                          "reasoning": "Packages organize code and prevent naming conflicts."
                                        },
                                        {
                                          "question": "What is the key to becoming a better programmer?",
                                          "options": ["Consistent practice and building projects", "Reading many books", "Watching tutorials", "Memorizing code"],
                                          "answer": "Consistent practice and building projects",
                                          "reasoning": "Hands-on practice through project building is the most effective way to improve."
                                        }
                                      ]
                                    }
                                  ]
                                }